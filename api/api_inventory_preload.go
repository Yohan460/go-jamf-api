/*
Jamf Pro API

## Overview The Jamf Pro API is a RESTful API for Jamf Pro built to enable consistent and efficient programmatic access to Jamf Pro.<br/><br/> The swagger schema can be found [here](/api/schema/). 

API version: production
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


type InventoryPreloadAPI interface {

	/*
	InventoryPreloadCsvTemplateGet Get the Inventory Preload CSV template 

	Retrieves the Inventory Preload CSV template.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return InventoryPreloadAPIInventoryPreloadCsvTemplateGetRequest

	Deprecated
	*/
	InventoryPreloadCsvTemplateGet(ctx context.Context) InventoryPreloadAPIInventoryPreloadCsvTemplateGetRequest

	// InventoryPreloadCsvTemplateGetExecute executes the request
	//  @return map[string]interface{}
	// Deprecated
	InventoryPreloadCsvTemplateGetExecute(r InventoryPreloadAPIInventoryPreloadCsvTemplateGetRequest) (map[string]interface{}, *http.Response, error)

	/*
	InventoryPreloadDelete Delete all Inventory Preload records 

	Deletes all Inventory Preload records.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return InventoryPreloadAPIInventoryPreloadDeleteRequest

	Deprecated
	*/
	InventoryPreloadDelete(ctx context.Context) InventoryPreloadAPIInventoryPreloadDeleteRequest

	// InventoryPreloadDeleteExecute executes the request
	// Deprecated
	InventoryPreloadDeleteExecute(r InventoryPreloadAPIInventoryPreloadDeleteRequest) (*http.Response, error)

	/*
	InventoryPreloadGet Return all Inventory Preload records 

	Returns all Inventory Preload records.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return InventoryPreloadAPIInventoryPreloadGetRequest

	Deprecated
	*/
	InventoryPreloadGet(ctx context.Context) InventoryPreloadAPIInventoryPreloadGetRequest

	// InventoryPreloadGetExecute executes the request
	//  @return []InventoryPreloadRecordSearchResults
	// Deprecated
	InventoryPreloadGetExecute(r InventoryPreloadAPIInventoryPreloadGetRequest) ([]InventoryPreloadRecordSearchResults, *http.Response, error)

	/*
	InventoryPreloadHistoryGet Get Inventory Preload history entries 

	Gets Inventory Preload history entries.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return InventoryPreloadAPIInventoryPreloadHistoryGetRequest

	Deprecated
	*/
	InventoryPreloadHistoryGet(ctx context.Context) InventoryPreloadAPIInventoryPreloadHistoryGetRequest

	// InventoryPreloadHistoryGetExecute executes the request
	//  @return HistorySearchResults
	// Deprecated
	InventoryPreloadHistoryGetExecute(r InventoryPreloadAPIInventoryPreloadHistoryGetRequest) (*HistorySearchResults, *http.Response, error)

	/*
	InventoryPreloadHistoryNotesPost Add Inventory Preload history object notes 

	Adds Inventory Preload history object notes.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return InventoryPreloadAPIInventoryPreloadHistoryNotesPostRequest

	Deprecated
	*/
	InventoryPreloadHistoryNotesPost(ctx context.Context) InventoryPreloadAPIInventoryPreloadHistoryNotesPostRequest

	// InventoryPreloadHistoryNotesPostExecute executes the request
	//  @return ObjectHistory
	// Deprecated
	InventoryPreloadHistoryNotesPostExecute(r InventoryPreloadAPIInventoryPreloadHistoryNotesPostRequest) (*ObjectHistory, *http.Response, error)

	/*
	InventoryPreloadIdDelete Delete an Inventory Preload record 

	Deletes an Inventory Preload record.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Inventory Preload identifier
	@return InventoryPreloadAPIInventoryPreloadIdDeleteRequest

	Deprecated
	*/
	InventoryPreloadIdDelete(ctx context.Context, id int32) InventoryPreloadAPIInventoryPreloadIdDeleteRequest

	// InventoryPreloadIdDeleteExecute executes the request
	// Deprecated
	InventoryPreloadIdDeleteExecute(r InventoryPreloadAPIInventoryPreloadIdDeleteRequest) (*http.Response, error)

	/*
	InventoryPreloadIdGet Get an Inventory Preload record 

	Retrieves an Inventory Preload record.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Inventory Preload identifier
	@return InventoryPreloadAPIInventoryPreloadIdGetRequest

	Deprecated
	*/
	InventoryPreloadIdGet(ctx context.Context, id int32) InventoryPreloadAPIInventoryPreloadIdGetRequest

	// InventoryPreloadIdGetExecute executes the request
	//  @return InventoryPreloadRecord
	// Deprecated
	InventoryPreloadIdGetExecute(r InventoryPreloadAPIInventoryPreloadIdGetRequest) (*InventoryPreloadRecord, *http.Response, error)

	/*
	InventoryPreloadIdPut Update an Inventory Preload record 

	Updates an Inventory Preload record.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Inventory Preload identifier
	@return InventoryPreloadAPIInventoryPreloadIdPutRequest

	Deprecated
	*/
	InventoryPreloadIdPut(ctx context.Context, id int32) InventoryPreloadAPIInventoryPreloadIdPutRequest

	// InventoryPreloadIdPutExecute executes the request
	//  @return InventoryPreloadRecord
	// Deprecated
	InventoryPreloadIdPutExecute(r InventoryPreloadAPIInventoryPreloadIdPutRequest) (*InventoryPreloadRecord, *http.Response, error)

	/*
	InventoryPreloadPost Create a new Inventory Preload record using JSON or CSV 

	Create a new Inventory Preload record using JSON or CSV.
A CSV template can be downloaded from /api/inventory-preload/csv-template.
Serial number and device type are required. All other fields are optional.
When a matching serial number exists in the Inventory Preload data, the record will be overwritten with the CSV data.
If the CSV file contains a new username and an email address is provided, the new user is created in Jamf Pro.
If the CSV file contains an existing username, the following user-related fields are updated in Jamf Pro.
Full Name,
Email Address,
Phone Number,
Position.
This endpoint does not do full validation of each record in the CSV data.
To do full validation, use the /inventory-preload/validate-csv endpoint first.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return InventoryPreloadAPIInventoryPreloadPostRequest

	Deprecated
	*/
	InventoryPreloadPost(ctx context.Context) InventoryPreloadAPIInventoryPreloadPostRequest

	// InventoryPreloadPostExecute executes the request
	//  @return InventoryPreloadRecord
	// Deprecated
	InventoryPreloadPostExecute(r InventoryPreloadAPIInventoryPreloadPostRequest) (*InventoryPreloadRecord, *http.Response, error)

	/*
	InventoryPreloadValidateCsvPost Validate a given CSV file 

	Validate a given CSV file.
Serial number and device type are required. All other fields are optional.
A CSV template can be downloaded from /api/inventory-preload/csv-template.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return InventoryPreloadAPIInventoryPreloadValidateCsvPostRequest

	Deprecated
	*/
	InventoryPreloadValidateCsvPost(ctx context.Context) InventoryPreloadAPIInventoryPreloadValidateCsvPostRequest

	// InventoryPreloadValidateCsvPostExecute executes the request
	//  @return InventoryPreloadCsvValidationSuccess
	// Deprecated
	InventoryPreloadValidateCsvPostExecute(r InventoryPreloadAPIInventoryPreloadValidateCsvPostRequest) (*InventoryPreloadCsvValidationSuccess, *http.Response, error)

	/*
	V1InventoryPreloadCsvTemplateGet Retrieve the Inventory Preload CSV template 

	Retrieves the Inventory Preload CSV template.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return InventoryPreloadAPIV1InventoryPreloadCsvTemplateGetRequest

	Deprecated
	*/
	V1InventoryPreloadCsvTemplateGet(ctx context.Context) InventoryPreloadAPIV1InventoryPreloadCsvTemplateGetRequest

	// V1InventoryPreloadCsvTemplateGetExecute executes the request
	//  @return map[string]interface{}
	// Deprecated
	V1InventoryPreloadCsvTemplateGetExecute(r InventoryPreloadAPIV1InventoryPreloadCsvTemplateGetRequest) (map[string]interface{}, *http.Response, error)

	/*
	V1InventoryPreloadDelete Delete all Inventory Preload records 

	Deletes all Inventory Preload records.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return InventoryPreloadAPIV1InventoryPreloadDeleteRequest

	Deprecated
	*/
	V1InventoryPreloadDelete(ctx context.Context) InventoryPreloadAPIV1InventoryPreloadDeleteRequest

	// V1InventoryPreloadDeleteExecute executes the request
	// Deprecated
	V1InventoryPreloadDeleteExecute(r InventoryPreloadAPIV1InventoryPreloadDeleteRequest) (*http.Response, error)

	/*
	V1InventoryPreloadGet Return all Inventory Preload records 

	Returns all Inventory Preload records.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return InventoryPreloadAPIV1InventoryPreloadGetRequest

	Deprecated
	*/
	V1InventoryPreloadGet(ctx context.Context) InventoryPreloadAPIV1InventoryPreloadGetRequest

	// V1InventoryPreloadGetExecute executes the request
	//  @return InventoryPreloadRecordSearchResults
	// Deprecated
	V1InventoryPreloadGetExecute(r InventoryPreloadAPIV1InventoryPreloadGetRequest) (*InventoryPreloadRecordSearchResults, *http.Response, error)

	/*
	V1InventoryPreloadHistoryGet Get Inventory Preload history entries 

	Gets Inventory Preload history entries.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return InventoryPreloadAPIV1InventoryPreloadHistoryGetRequest

	Deprecated
	*/
	V1InventoryPreloadHistoryGet(ctx context.Context) InventoryPreloadAPIV1InventoryPreloadHistoryGetRequest

	// V1InventoryPreloadHistoryGetExecute executes the request
	//  @return HistorySearchResults
	// Deprecated
	V1InventoryPreloadHistoryGetExecute(r InventoryPreloadAPIV1InventoryPreloadHistoryGetRequest) (*HistorySearchResults, *http.Response, error)

	/*
	V1InventoryPreloadHistoryPost Add Inventory Preload history object notes 

	Adds Inventory Preload history object notes.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return InventoryPreloadAPIV1InventoryPreloadHistoryPostRequest

	Deprecated
	*/
	V1InventoryPreloadHistoryPost(ctx context.Context) InventoryPreloadAPIV1InventoryPreloadHistoryPostRequest

	// V1InventoryPreloadHistoryPostExecute executes the request
	//  @return ObjectHistory
	// Deprecated
	V1InventoryPreloadHistoryPostExecute(r InventoryPreloadAPIV1InventoryPreloadHistoryPostRequest) (*ObjectHistory, *http.Response, error)

	/*
	V1InventoryPreloadIdDelete Delete an Inventory Preload record 

	Deletes an Inventory Preload record.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Inventory Preload identifier
	@return InventoryPreloadAPIV1InventoryPreloadIdDeleteRequest

	Deprecated
	*/
	V1InventoryPreloadIdDelete(ctx context.Context, id int32) InventoryPreloadAPIV1InventoryPreloadIdDeleteRequest

	// V1InventoryPreloadIdDeleteExecute executes the request
	// Deprecated
	V1InventoryPreloadIdDeleteExecute(r InventoryPreloadAPIV1InventoryPreloadIdDeleteRequest) (*http.Response, error)

	/*
	V1InventoryPreloadIdGet Get an Inventory Preload record 

	Retrieves an Inventory Preload record.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Inventory Preload identifier
	@return InventoryPreloadAPIV1InventoryPreloadIdGetRequest

	Deprecated
	*/
	V1InventoryPreloadIdGet(ctx context.Context, id int32) InventoryPreloadAPIV1InventoryPreloadIdGetRequest

	// V1InventoryPreloadIdGetExecute executes the request
	//  @return InventoryPreloadRecord
	// Deprecated
	V1InventoryPreloadIdGetExecute(r InventoryPreloadAPIV1InventoryPreloadIdGetRequest) (*InventoryPreloadRecord, *http.Response, error)

	/*
	V1InventoryPreloadIdPut Update an Inventory Preload record 

	Updates an Inventory Preload record.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Inventory Preload identifier
	@return InventoryPreloadAPIV1InventoryPreloadIdPutRequest

	Deprecated
	*/
	V1InventoryPreloadIdPut(ctx context.Context, id int32) InventoryPreloadAPIV1InventoryPreloadIdPutRequest

	// V1InventoryPreloadIdPutExecute executes the request
	//  @return InventoryPreloadRecord
	// Deprecated
	V1InventoryPreloadIdPutExecute(r InventoryPreloadAPIV1InventoryPreloadIdPutRequest) (*InventoryPreloadRecord, *http.Response, error)

	/*
	V1InventoryPreloadPost Create a new Inventory Preload record using JSON or CSV 

	Create a new Inventory Preload record using JSON or CSV.
A CSV template can be downloaded from /api/inventory-preload/csv-template.
Serial number and device type are required. All other fields are optional.
When a matching serial number exists in the Inventory Preload data, the record will be overwritten with the CSV data.
If the CSV file contains a new username and an email address is provided, the new user is created in Jamf Pro.
If the CSV file contains an existing username, the following user-related fields are updated in Jamf Pro.
Full Name,
Email Address,
Phone Number,
Position.
This endpoint does not do full validation of each record in the CSV data.
To do full validation, use the /inventory-preload/validate-csv endpoint first.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return InventoryPreloadAPIV1InventoryPreloadPostRequest

	Deprecated
	*/
	V1InventoryPreloadPost(ctx context.Context) InventoryPreloadAPIV1InventoryPreloadPostRequest

	// V1InventoryPreloadPostExecute executes the request
	//  @return InventoryPreloadRecord
	// Deprecated
	V1InventoryPreloadPostExecute(r InventoryPreloadAPIV1InventoryPreloadPostRequest) (*InventoryPreloadRecord, *http.Response, error)

	/*
	V1InventoryPreloadValidateCsvPost Validate a given CSV file 

	Validate a given CSV file.
Serial number and device type are required. All other fields are optional.
A CSV template can be downloaded from /api/inventory-preload/csv-template.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return InventoryPreloadAPIV1InventoryPreloadValidateCsvPostRequest

	Deprecated
	*/
	V1InventoryPreloadValidateCsvPost(ctx context.Context) InventoryPreloadAPIV1InventoryPreloadValidateCsvPostRequest

	// V1InventoryPreloadValidateCsvPostExecute executes the request
	//  @return InventoryPreloadCsvValidationSuccess
	// Deprecated
	V1InventoryPreloadValidateCsvPostExecute(r InventoryPreloadAPIV1InventoryPreloadValidateCsvPostRequest) (*InventoryPreloadCsvValidationSuccess, *http.Response, error)

	/*
	V2InventoryPreloadCsvGet Download all Inventory Preload records

	Returns all Inventory Preload records as a CSV file.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return InventoryPreloadAPIV2InventoryPreloadCsvGetRequest
	*/
	V2InventoryPreloadCsvGet(ctx context.Context) InventoryPreloadAPIV2InventoryPreloadCsvGetRequest

	// V2InventoryPreloadCsvGetExecute executes the request
	//  @return string
	V2InventoryPreloadCsvGetExecute(r InventoryPreloadAPIV2InventoryPreloadCsvGetRequest) (string, *http.Response, error)

	/*
	V2InventoryPreloadCsvPost Create one or more new Inventory Preload records using CSV 

	Create one or more new Inventory Preload records using CSV.
A CSV template can be downloaded from /v2/inventory-preload/csv-template.
Serial number and device type are required. All other fields are optional.
When a matching serial number exists in the Inventory Preload data, the record will be overwritten with the CSV data.
If the CSV file contains a new username and an email address is provided, the new user is created in Jamf Pro.
If the CSV file contains an existing username, the following user-related fields are updated in Jamf Pro.
Full Name,
Email Address,
Phone Number,
Position.
This endpoint does not do full validation of each record in the CSV data.
To do full validation, use the `/v2/inventory-preload/csv-validate` endpoint first.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return InventoryPreloadAPIV2InventoryPreloadCsvPostRequest
	*/
	V2InventoryPreloadCsvPost(ctx context.Context) InventoryPreloadAPIV2InventoryPreloadCsvPostRequest

	// V2InventoryPreloadCsvPostExecute executes the request
	//  @return []HrefResponse
	V2InventoryPreloadCsvPostExecute(r InventoryPreloadAPIV2InventoryPreloadCsvPostRequest) ([]HrefResponse, *http.Response, error)

	/*
	V2InventoryPreloadCsvTemplateGet Download the Inventory Preload CSV template

	Retrieves the Inventory Preload CSV file template.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return InventoryPreloadAPIV2InventoryPreloadCsvTemplateGetRequest
	*/
	V2InventoryPreloadCsvTemplateGet(ctx context.Context) InventoryPreloadAPIV2InventoryPreloadCsvTemplateGetRequest

	// V2InventoryPreloadCsvTemplateGetExecute executes the request
	//  @return string
	V2InventoryPreloadCsvTemplateGetExecute(r InventoryPreloadAPIV2InventoryPreloadCsvTemplateGetRequest) (string, *http.Response, error)

	/*
	V2InventoryPreloadCsvValidatePost Validate a given CSV file 

	Validate a given CSV file.
Serial number and device type are required. All other fields are optional.
A CSV template can be downloaded from `/v2/inventory-preload/csv-template`.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return InventoryPreloadAPIV2InventoryPreloadCsvValidatePostRequest
	*/
	V2InventoryPreloadCsvValidatePost(ctx context.Context) InventoryPreloadAPIV2InventoryPreloadCsvValidatePostRequest

	// V2InventoryPreloadCsvValidatePostExecute executes the request
	//  @return InventoryPreloadCsvValidationSuccess
	V2InventoryPreloadCsvValidatePostExecute(r InventoryPreloadAPIV2InventoryPreloadCsvValidatePostRequest) (*InventoryPreloadCsvValidationSuccess, *http.Response, error)

	/*
	V2InventoryPreloadEaColumnsGet Retrieve a list of extension attribute columns 

	Retrieve a list of extension attribute columns currently associated
with inventory preload records


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return InventoryPreloadAPIV2InventoryPreloadEaColumnsGetRequest
	*/
	V2InventoryPreloadEaColumnsGet(ctx context.Context) InventoryPreloadAPIV2InventoryPreloadEaColumnsGetRequest

	// V2InventoryPreloadEaColumnsGetExecute executes the request
	//  @return InventoryPreloadExtensionAttributeColumnResult
	V2InventoryPreloadEaColumnsGetExecute(r InventoryPreloadAPIV2InventoryPreloadEaColumnsGetRequest) (*InventoryPreloadExtensionAttributeColumnResult, *http.Response, error)

	/*
	V2InventoryPreloadExportPost Export a collection of inventory preload records 

	Export a collection of inventory preload records


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return InventoryPreloadAPIV2InventoryPreloadExportPostRequest
	*/
	V2InventoryPreloadExportPost(ctx context.Context) InventoryPreloadAPIV2InventoryPreloadExportPostRequest

	// V2InventoryPreloadExportPostExecute executes the request
	//  @return interface{}
	V2InventoryPreloadExportPostExecute(r InventoryPreloadAPIV2InventoryPreloadExportPostRequest) (interface{}, *http.Response, error)

	/*
	V2InventoryPreloadHistoryGet Get Inventory Preload history entries 

	Gets Inventory Preload history entries.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return InventoryPreloadAPIV2InventoryPreloadHistoryGetRequest
	*/
	V2InventoryPreloadHistoryGet(ctx context.Context) InventoryPreloadAPIV2InventoryPreloadHistoryGetRequest

	// V2InventoryPreloadHistoryGetExecute executes the request
	//  @return HistorySearchResults
	V2InventoryPreloadHistoryGetExecute(r InventoryPreloadAPIV2InventoryPreloadHistoryGetRequest) (*HistorySearchResults, *http.Response, error)

	/*
	V2InventoryPreloadHistoryPost Add Inventory Preload history object notes

	Adds Inventory Preload history object notes.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return InventoryPreloadAPIV2InventoryPreloadHistoryPostRequest
	*/
	V2InventoryPreloadHistoryPost(ctx context.Context) InventoryPreloadAPIV2InventoryPreloadHistoryPostRequest

	// V2InventoryPreloadHistoryPostExecute executes the request
	//  @return HrefResponse
	V2InventoryPreloadHistoryPostExecute(r InventoryPreloadAPIV2InventoryPreloadHistoryPostRequest) (*HrefResponse, *http.Response, error)

	/*
	V2InventoryPreloadRecordsDeleteAllPost Delete all Inventory Preload records 

	Deletes all Inventory Preload records.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return InventoryPreloadAPIV2InventoryPreloadRecordsDeleteAllPostRequest
	*/
	V2InventoryPreloadRecordsDeleteAllPost(ctx context.Context) InventoryPreloadAPIV2InventoryPreloadRecordsDeleteAllPostRequest

	// V2InventoryPreloadRecordsDeleteAllPostExecute executes the request
	V2InventoryPreloadRecordsDeleteAllPostExecute(r InventoryPreloadAPIV2InventoryPreloadRecordsDeleteAllPostRequest) (*http.Response, error)

	/*
	V2InventoryPreloadRecordsGet Return all Inventory Preload records

	Returns all Inventory Preload records.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return InventoryPreloadAPIV2InventoryPreloadRecordsGetRequest
	*/
	V2InventoryPreloadRecordsGet(ctx context.Context) InventoryPreloadAPIV2InventoryPreloadRecordsGetRequest

	// V2InventoryPreloadRecordsGetExecute executes the request
	//  @return InventoryPreloadRecordSearchResultsV2
	V2InventoryPreloadRecordsGetExecute(r InventoryPreloadAPIV2InventoryPreloadRecordsGetRequest) (*InventoryPreloadRecordSearchResultsV2, *http.Response, error)

	/*
	V2InventoryPreloadRecordsIdDelete Delete an Inventory Preload record 

	Deletes an Inventory Preload record.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Inventory Preload identifier
	@return InventoryPreloadAPIV2InventoryPreloadRecordsIdDeleteRequest
	*/
	V2InventoryPreloadRecordsIdDelete(ctx context.Context, id string) InventoryPreloadAPIV2InventoryPreloadRecordsIdDeleteRequest

	// V2InventoryPreloadRecordsIdDeleteExecute executes the request
	V2InventoryPreloadRecordsIdDeleteExecute(r InventoryPreloadAPIV2InventoryPreloadRecordsIdDeleteRequest) (*http.Response, error)

	/*
	V2InventoryPreloadRecordsIdGet Get an Inventory Preload record

	Retrieves an Inventory Preload record.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Inventory Preload identifier
	@return InventoryPreloadAPIV2InventoryPreloadRecordsIdGetRequest
	*/
	V2InventoryPreloadRecordsIdGet(ctx context.Context, id string) InventoryPreloadAPIV2InventoryPreloadRecordsIdGetRequest

	// V2InventoryPreloadRecordsIdGetExecute executes the request
	//  @return InventoryPreloadRecordV2
	V2InventoryPreloadRecordsIdGetExecute(r InventoryPreloadAPIV2InventoryPreloadRecordsIdGetRequest) (*InventoryPreloadRecordV2, *http.Response, error)

	/*
	V2InventoryPreloadRecordsIdPut Update an Inventory Preload record

	Updates an Inventory Preload record.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Inventory Preload identifier
	@return InventoryPreloadAPIV2InventoryPreloadRecordsIdPutRequest
	*/
	V2InventoryPreloadRecordsIdPut(ctx context.Context, id string) InventoryPreloadAPIV2InventoryPreloadRecordsIdPutRequest

	// V2InventoryPreloadRecordsIdPutExecute executes the request
	//  @return InventoryPreloadRecordV2
	V2InventoryPreloadRecordsIdPutExecute(r InventoryPreloadAPIV2InventoryPreloadRecordsIdPutRequest) (*InventoryPreloadRecordV2, *http.Response, error)

	/*
	V2InventoryPreloadRecordsPost Create a new Inventory Preload record using JSON

	Create a new Inventory Preload record using JSON.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return InventoryPreloadAPIV2InventoryPreloadRecordsPostRequest
	*/
	V2InventoryPreloadRecordsPost(ctx context.Context) InventoryPreloadAPIV2InventoryPreloadRecordsPostRequest

	// V2InventoryPreloadRecordsPostExecute executes the request
	//  @return HrefResponse
	V2InventoryPreloadRecordsPostExecute(r InventoryPreloadAPIV2InventoryPreloadRecordsPostRequest) (*HrefResponse, *http.Response, error)
}

// InventoryPreloadAPIService InventoryPreloadAPI service
type InventoryPreloadAPIService service

type InventoryPreloadAPIInventoryPreloadCsvTemplateGetRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
}

func (r InventoryPreloadAPIInventoryPreloadCsvTemplateGetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.InventoryPreloadCsvTemplateGetExecute(r)
}

/*
InventoryPreloadCsvTemplateGet Get the Inventory Preload CSV template 

Retrieves the Inventory Preload CSV template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InventoryPreloadAPIInventoryPreloadCsvTemplateGetRequest

Deprecated
*/
func (a *InventoryPreloadAPIService) InventoryPreloadCsvTemplateGet(ctx context.Context) InventoryPreloadAPIInventoryPreloadCsvTemplateGetRequest {
	return InventoryPreloadAPIInventoryPreloadCsvTemplateGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
// Deprecated
func (a *InventoryPreloadAPIService) InventoryPreloadCsvTemplateGetExecute(r InventoryPreloadAPIInventoryPreloadCsvTemplateGetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.InventoryPreloadCsvTemplateGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory-preload/csv-template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryPreloadAPIInventoryPreloadDeleteRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
}

func (r InventoryPreloadAPIInventoryPreloadDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.InventoryPreloadDeleteExecute(r)
}

/*
InventoryPreloadDelete Delete all Inventory Preload records 

Deletes all Inventory Preload records.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InventoryPreloadAPIInventoryPreloadDeleteRequest

Deprecated
*/
func (a *InventoryPreloadAPIService) InventoryPreloadDelete(ctx context.Context) InventoryPreloadAPIInventoryPreloadDeleteRequest {
	return InventoryPreloadAPIInventoryPreloadDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
// Deprecated
func (a *InventoryPreloadAPIService) InventoryPreloadDeleteExecute(r InventoryPreloadAPIInventoryPreloadDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.InventoryPreloadDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory-preload"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type InventoryPreloadAPIInventoryPreloadGetRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
	page *int32
	pagesize *int32
	sort *string
	sortBy *string
}

func (r InventoryPreloadAPIInventoryPreloadGetRequest) Page(page int32) InventoryPreloadAPIInventoryPreloadGetRequest {
	r.page = &page
	return r
}

// Deprecated
func (r InventoryPreloadAPIInventoryPreloadGetRequest) Pagesize(pagesize int32) InventoryPreloadAPIInventoryPreloadGetRequest {
	r.pagesize = &pagesize
	return r
}

func (r InventoryPreloadAPIInventoryPreloadGetRequest) Sort(sort string) InventoryPreloadAPIInventoryPreloadGetRequest {
	r.sort = &sort
	return r
}

func (r InventoryPreloadAPIInventoryPreloadGetRequest) SortBy(sortBy string) InventoryPreloadAPIInventoryPreloadGetRequest {
	r.sortBy = &sortBy
	return r
}

func (r InventoryPreloadAPIInventoryPreloadGetRequest) Execute() ([]InventoryPreloadRecordSearchResults, *http.Response, error) {
	return r.ApiService.InventoryPreloadGetExecute(r)
}

/*
InventoryPreloadGet Return all Inventory Preload records 

Returns all Inventory Preload records.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InventoryPreloadAPIInventoryPreloadGetRequest

Deprecated
*/
func (a *InventoryPreloadAPIService) InventoryPreloadGet(ctx context.Context) InventoryPreloadAPIInventoryPreloadGetRequest {
	return InventoryPreloadAPIInventoryPreloadGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InventoryPreloadRecordSearchResults
// Deprecated
func (a *InventoryPreloadAPIService) InventoryPreloadGetExecute(r InventoryPreloadAPIInventoryPreloadGetRequest) ([]InventoryPreloadRecordSearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []InventoryPreloadRecordSearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.InventoryPreloadGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory-preload"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 0
		r.page = &defaultValue
	}
	if r.pagesize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pagesize", r.pagesize, "")
	} else {
		var defaultValue int32 = 100
		r.pagesize = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	} else {
		var defaultValue string = "ASC"
		r.sort = &defaultValue
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	} else {
		var defaultValue string = "id"
		r.sortBy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryPreloadAPIInventoryPreloadHistoryGetRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
	page *int32
	size *int32
	pagesize *int32
	pageSize *int32
	sort *string
}

func (r InventoryPreloadAPIInventoryPreloadHistoryGetRequest) Page(page int32) InventoryPreloadAPIInventoryPreloadHistoryGetRequest {
	r.page = &page
	return r
}

// Deprecated
func (r InventoryPreloadAPIInventoryPreloadHistoryGetRequest) Size(size int32) InventoryPreloadAPIInventoryPreloadHistoryGetRequest {
	r.size = &size
	return r
}

// Deprecated
func (r InventoryPreloadAPIInventoryPreloadHistoryGetRequest) Pagesize(pagesize int32) InventoryPreloadAPIInventoryPreloadHistoryGetRequest {
	r.pagesize = &pagesize
	return r
}

func (r InventoryPreloadAPIInventoryPreloadHistoryGetRequest) PageSize(pageSize int32) InventoryPreloadAPIInventoryPreloadHistoryGetRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property:asc/desc. Default sort is date:desc. Multiple sort criteria are supported and must be separated with a comma. Example: sort&#x3D;date:desc,name:asc 
func (r InventoryPreloadAPIInventoryPreloadHistoryGetRequest) Sort(sort string) InventoryPreloadAPIInventoryPreloadHistoryGetRequest {
	r.sort = &sort
	return r
}

func (r InventoryPreloadAPIInventoryPreloadHistoryGetRequest) Execute() (*HistorySearchResults, *http.Response, error) {
	return r.ApiService.InventoryPreloadHistoryGetExecute(r)
}

/*
InventoryPreloadHistoryGet Get Inventory Preload history entries 

Gets Inventory Preload history entries.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InventoryPreloadAPIInventoryPreloadHistoryGetRequest

Deprecated
*/
func (a *InventoryPreloadAPIService) InventoryPreloadHistoryGet(ctx context.Context) InventoryPreloadAPIInventoryPreloadHistoryGetRequest {
	return InventoryPreloadAPIInventoryPreloadHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HistorySearchResults
// Deprecated
func (a *InventoryPreloadAPIService) InventoryPreloadHistoryGetExecute(r InventoryPreloadAPIInventoryPreloadHistoryGetRequest) (*HistorySearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistorySearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.InventoryPreloadHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory-preload/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 0
		r.page = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	} else {
		var defaultValue int32 = 100
		r.size = &defaultValue
	}
	if r.pagesize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pagesize", r.pagesize, "")
	} else {
		var defaultValue int32 = 100
		r.pagesize = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page-size", r.pageSize, "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	} else {
		var defaultValue string = "date:desc"
		r.sort = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryPreloadAPIInventoryPreloadHistoryNotesPostRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
	objectHistoryNote *ObjectHistoryNote
}

// History notes to create
func (r InventoryPreloadAPIInventoryPreloadHistoryNotesPostRequest) ObjectHistoryNote(objectHistoryNote ObjectHistoryNote) InventoryPreloadAPIInventoryPreloadHistoryNotesPostRequest {
	r.objectHistoryNote = &objectHistoryNote
	return r
}

func (r InventoryPreloadAPIInventoryPreloadHistoryNotesPostRequest) Execute() (*ObjectHistory, *http.Response, error) {
	return r.ApiService.InventoryPreloadHistoryNotesPostExecute(r)
}

/*
InventoryPreloadHistoryNotesPost Add Inventory Preload history object notes 

Adds Inventory Preload history object notes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InventoryPreloadAPIInventoryPreloadHistoryNotesPostRequest

Deprecated
*/
func (a *InventoryPreloadAPIService) InventoryPreloadHistoryNotesPost(ctx context.Context) InventoryPreloadAPIInventoryPreloadHistoryNotesPostRequest {
	return InventoryPreloadAPIInventoryPreloadHistoryNotesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ObjectHistory
// Deprecated
func (a *InventoryPreloadAPIService) InventoryPreloadHistoryNotesPostExecute(r InventoryPreloadAPIInventoryPreloadHistoryNotesPostRequest) (*ObjectHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.InventoryPreloadHistoryNotesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory-preload/history/notes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.objectHistoryNote == nil {
		return localVarReturnValue, nil, reportError("objectHistoryNote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.objectHistoryNote
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryPreloadAPIInventoryPreloadIdDeleteRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
	id int32
}

func (r InventoryPreloadAPIInventoryPreloadIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.InventoryPreloadIdDeleteExecute(r)
}

/*
InventoryPreloadIdDelete Delete an Inventory Preload record 

Deletes an Inventory Preload record.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Inventory Preload identifier
 @return InventoryPreloadAPIInventoryPreloadIdDeleteRequest

Deprecated
*/
func (a *InventoryPreloadAPIService) InventoryPreloadIdDelete(ctx context.Context, id int32) InventoryPreloadAPIInventoryPreloadIdDeleteRequest {
	return InventoryPreloadAPIInventoryPreloadIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
// Deprecated
func (a *InventoryPreloadAPIService) InventoryPreloadIdDeleteExecute(r InventoryPreloadAPIInventoryPreloadIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.InventoryPreloadIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory-preload/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type InventoryPreloadAPIInventoryPreloadIdGetRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
	id int32
}

func (r InventoryPreloadAPIInventoryPreloadIdGetRequest) Execute() (*InventoryPreloadRecord, *http.Response, error) {
	return r.ApiService.InventoryPreloadIdGetExecute(r)
}

/*
InventoryPreloadIdGet Get an Inventory Preload record 

Retrieves an Inventory Preload record.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Inventory Preload identifier
 @return InventoryPreloadAPIInventoryPreloadIdGetRequest

Deprecated
*/
func (a *InventoryPreloadAPIService) InventoryPreloadIdGet(ctx context.Context, id int32) InventoryPreloadAPIInventoryPreloadIdGetRequest {
	return InventoryPreloadAPIInventoryPreloadIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InventoryPreloadRecord
// Deprecated
func (a *InventoryPreloadAPIService) InventoryPreloadIdGetExecute(r InventoryPreloadAPIInventoryPreloadIdGetRequest) (*InventoryPreloadRecord, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryPreloadRecord
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.InventoryPreloadIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory-preload/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryPreloadAPIInventoryPreloadIdPutRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
	id int32
	inventoryPreloadRecord *InventoryPreloadRecord
}

// Inventory Preload record to update
func (r InventoryPreloadAPIInventoryPreloadIdPutRequest) InventoryPreloadRecord(inventoryPreloadRecord InventoryPreloadRecord) InventoryPreloadAPIInventoryPreloadIdPutRequest {
	r.inventoryPreloadRecord = &inventoryPreloadRecord
	return r
}

func (r InventoryPreloadAPIInventoryPreloadIdPutRequest) Execute() (*InventoryPreloadRecord, *http.Response, error) {
	return r.ApiService.InventoryPreloadIdPutExecute(r)
}

/*
InventoryPreloadIdPut Update an Inventory Preload record 

Updates an Inventory Preload record.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Inventory Preload identifier
 @return InventoryPreloadAPIInventoryPreloadIdPutRequest

Deprecated
*/
func (a *InventoryPreloadAPIService) InventoryPreloadIdPut(ctx context.Context, id int32) InventoryPreloadAPIInventoryPreloadIdPutRequest {
	return InventoryPreloadAPIInventoryPreloadIdPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InventoryPreloadRecord
// Deprecated
func (a *InventoryPreloadAPIService) InventoryPreloadIdPutExecute(r InventoryPreloadAPIInventoryPreloadIdPutRequest) (*InventoryPreloadRecord, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryPreloadRecord
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.InventoryPreloadIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory-preload/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.inventoryPreloadRecord == nil {
		return localVarReturnValue, nil, reportError("inventoryPreloadRecord is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inventoryPreloadRecord
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryPreloadAPIInventoryPreloadPostRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
	inventoryPreloadRecord *InventoryPreloadRecord
}

// Inventory Preload record or records to be created
func (r InventoryPreloadAPIInventoryPreloadPostRequest) InventoryPreloadRecord(inventoryPreloadRecord InventoryPreloadRecord) InventoryPreloadAPIInventoryPreloadPostRequest {
	r.inventoryPreloadRecord = &inventoryPreloadRecord
	return r
}

func (r InventoryPreloadAPIInventoryPreloadPostRequest) Execute() (*InventoryPreloadRecord, *http.Response, error) {
	return r.ApiService.InventoryPreloadPostExecute(r)
}

/*
InventoryPreloadPost Create a new Inventory Preload record using JSON or CSV 

Create a new Inventory Preload record using JSON or CSV.
A CSV template can be downloaded from /api/inventory-preload/csv-template.
Serial number and device type are required. All other fields are optional.
When a matching serial number exists in the Inventory Preload data, the record will be overwritten with the CSV data.
If the CSV file contains a new username and an email address is provided, the new user is created in Jamf Pro.
If the CSV file contains an existing username, the following user-related fields are updated in Jamf Pro.
Full Name,
Email Address,
Phone Number,
Position.
This endpoint does not do full validation of each record in the CSV data.
To do full validation, use the /inventory-preload/validate-csv endpoint first.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InventoryPreloadAPIInventoryPreloadPostRequest

Deprecated
*/
func (a *InventoryPreloadAPIService) InventoryPreloadPost(ctx context.Context) InventoryPreloadAPIInventoryPreloadPostRequest {
	return InventoryPreloadAPIInventoryPreloadPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InventoryPreloadRecord
// Deprecated
func (a *InventoryPreloadAPIService) InventoryPreloadPostExecute(r InventoryPreloadAPIInventoryPreloadPostRequest) (*InventoryPreloadRecord, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryPreloadRecord
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.InventoryPreloadPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory-preload"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.inventoryPreloadRecord == nil {
		return localVarReturnValue, nil, reportError("inventoryPreloadRecord is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inventoryPreloadRecord
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryPreloadAPIInventoryPreloadValidateCsvPostRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
	body *map[string]interface{}
}

// Inventory Preload records to be validated. A CSV template can be downloaded from /api/inventory-preload/csv-template
func (r InventoryPreloadAPIInventoryPreloadValidateCsvPostRequest) Body(body map[string]interface{}) InventoryPreloadAPIInventoryPreloadValidateCsvPostRequest {
	r.body = &body
	return r
}

func (r InventoryPreloadAPIInventoryPreloadValidateCsvPostRequest) Execute() (*InventoryPreloadCsvValidationSuccess, *http.Response, error) {
	return r.ApiService.InventoryPreloadValidateCsvPostExecute(r)
}

/*
InventoryPreloadValidateCsvPost Validate a given CSV file 

Validate a given CSV file.
Serial number and device type are required. All other fields are optional.
A CSV template can be downloaded from /api/inventory-preload/csv-template.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InventoryPreloadAPIInventoryPreloadValidateCsvPostRequest

Deprecated
*/
func (a *InventoryPreloadAPIService) InventoryPreloadValidateCsvPost(ctx context.Context) InventoryPreloadAPIInventoryPreloadValidateCsvPostRequest {
	return InventoryPreloadAPIInventoryPreloadValidateCsvPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InventoryPreloadCsvValidationSuccess
// Deprecated
func (a *InventoryPreloadAPIService) InventoryPreloadValidateCsvPostExecute(r InventoryPreloadAPIInventoryPreloadValidateCsvPostRequest) (*InventoryPreloadCsvValidationSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryPreloadCsvValidationSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.InventoryPreloadValidateCsvPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory-preload/validate-csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v InventoryPreloadInvalidCsvResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryPreloadAPIV1InventoryPreloadCsvTemplateGetRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
}

func (r InventoryPreloadAPIV1InventoryPreloadCsvTemplateGetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1InventoryPreloadCsvTemplateGetExecute(r)
}

/*
V1InventoryPreloadCsvTemplateGet Retrieve the Inventory Preload CSV template 

Retrieves the Inventory Preload CSV template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InventoryPreloadAPIV1InventoryPreloadCsvTemplateGetRequest

Deprecated
*/
func (a *InventoryPreloadAPIService) V1InventoryPreloadCsvTemplateGet(ctx context.Context) InventoryPreloadAPIV1InventoryPreloadCsvTemplateGetRequest {
	return InventoryPreloadAPIV1InventoryPreloadCsvTemplateGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
// Deprecated
func (a *InventoryPreloadAPIService) V1InventoryPreloadCsvTemplateGetExecute(r InventoryPreloadAPIV1InventoryPreloadCsvTemplateGetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.V1InventoryPreloadCsvTemplateGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/inventory-preload/csv-template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryPreloadAPIV1InventoryPreloadDeleteRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
}

func (r InventoryPreloadAPIV1InventoryPreloadDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1InventoryPreloadDeleteExecute(r)
}

/*
V1InventoryPreloadDelete Delete all Inventory Preload records 

Deletes all Inventory Preload records.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InventoryPreloadAPIV1InventoryPreloadDeleteRequest

Deprecated
*/
func (a *InventoryPreloadAPIService) V1InventoryPreloadDelete(ctx context.Context) InventoryPreloadAPIV1InventoryPreloadDeleteRequest {
	return InventoryPreloadAPIV1InventoryPreloadDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
// Deprecated
func (a *InventoryPreloadAPIService) V1InventoryPreloadDeleteExecute(r InventoryPreloadAPIV1InventoryPreloadDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.V1InventoryPreloadDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/inventory-preload"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type InventoryPreloadAPIV1InventoryPreloadGetRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
	page *int32
	size *int32
	pagesize *int32
	pageSize *int32
	sort *string
}

func (r InventoryPreloadAPIV1InventoryPreloadGetRequest) Page(page int32) InventoryPreloadAPIV1InventoryPreloadGetRequest {
	r.page = &page
	return r
}

// Deprecated
func (r InventoryPreloadAPIV1InventoryPreloadGetRequest) Size(size int32) InventoryPreloadAPIV1InventoryPreloadGetRequest {
	r.size = &size
	return r
}

// Deprecated
func (r InventoryPreloadAPIV1InventoryPreloadGetRequest) Pagesize(pagesize int32) InventoryPreloadAPIV1InventoryPreloadGetRequest {
	r.pagesize = &pagesize
	return r
}

func (r InventoryPreloadAPIV1InventoryPreloadGetRequest) PageSize(pageSize int32) InventoryPreloadAPIV1InventoryPreloadGetRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property:asc/desc. Default sort is id:asc. Multiple sort criteria are supported and must be separated with a comma. Example: sort&#x3D;date:desc,name:asc 
func (r InventoryPreloadAPIV1InventoryPreloadGetRequest) Sort(sort string) InventoryPreloadAPIV1InventoryPreloadGetRequest {
	r.sort = &sort
	return r
}

func (r InventoryPreloadAPIV1InventoryPreloadGetRequest) Execute() (*InventoryPreloadRecordSearchResults, *http.Response, error) {
	return r.ApiService.V1InventoryPreloadGetExecute(r)
}

/*
V1InventoryPreloadGet Return all Inventory Preload records 

Returns all Inventory Preload records.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InventoryPreloadAPIV1InventoryPreloadGetRequest

Deprecated
*/
func (a *InventoryPreloadAPIService) V1InventoryPreloadGet(ctx context.Context) InventoryPreloadAPIV1InventoryPreloadGetRequest {
	return InventoryPreloadAPIV1InventoryPreloadGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InventoryPreloadRecordSearchResults
// Deprecated
func (a *InventoryPreloadAPIService) V1InventoryPreloadGetExecute(r InventoryPreloadAPIV1InventoryPreloadGetRequest) (*InventoryPreloadRecordSearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryPreloadRecordSearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.V1InventoryPreloadGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/inventory-preload"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 0
		r.page = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	} else {
		var defaultValue int32 = 100
		r.size = &defaultValue
	}
	if r.pagesize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pagesize", r.pagesize, "")
	} else {
		var defaultValue int32 = 100
		r.pagesize = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page-size", r.pageSize, "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	} else {
		var defaultValue string = "id:asc"
		r.sort = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryPreloadAPIV1InventoryPreloadHistoryGetRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
	page *int32
	size *int32
	pagesize *int32
	pageSize *int32
	sort *string
}

func (r InventoryPreloadAPIV1InventoryPreloadHistoryGetRequest) Page(page int32) InventoryPreloadAPIV1InventoryPreloadHistoryGetRequest {
	r.page = &page
	return r
}

// Deprecated
func (r InventoryPreloadAPIV1InventoryPreloadHistoryGetRequest) Size(size int32) InventoryPreloadAPIV1InventoryPreloadHistoryGetRequest {
	r.size = &size
	return r
}

// Deprecated
func (r InventoryPreloadAPIV1InventoryPreloadHistoryGetRequest) Pagesize(pagesize int32) InventoryPreloadAPIV1InventoryPreloadHistoryGetRequest {
	r.pagesize = &pagesize
	return r
}

func (r InventoryPreloadAPIV1InventoryPreloadHistoryGetRequest) PageSize(pageSize int32) InventoryPreloadAPIV1InventoryPreloadHistoryGetRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property:asc/desc. Default sort is date:desc. Multiple sort criteria are supported and must be separated with a comma. Example: sort&#x3D;date:desc,name:asc 
func (r InventoryPreloadAPIV1InventoryPreloadHistoryGetRequest) Sort(sort string) InventoryPreloadAPIV1InventoryPreloadHistoryGetRequest {
	r.sort = &sort
	return r
}

func (r InventoryPreloadAPIV1InventoryPreloadHistoryGetRequest) Execute() (*HistorySearchResults, *http.Response, error) {
	return r.ApiService.V1InventoryPreloadHistoryGetExecute(r)
}

/*
V1InventoryPreloadHistoryGet Get Inventory Preload history entries 

Gets Inventory Preload history entries.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InventoryPreloadAPIV1InventoryPreloadHistoryGetRequest

Deprecated
*/
func (a *InventoryPreloadAPIService) V1InventoryPreloadHistoryGet(ctx context.Context) InventoryPreloadAPIV1InventoryPreloadHistoryGetRequest {
	return InventoryPreloadAPIV1InventoryPreloadHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HistorySearchResults
// Deprecated
func (a *InventoryPreloadAPIService) V1InventoryPreloadHistoryGetExecute(r InventoryPreloadAPIV1InventoryPreloadHistoryGetRequest) (*HistorySearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistorySearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.V1InventoryPreloadHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/inventory-preload/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 0
		r.page = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	} else {
		var defaultValue int32 = 100
		r.size = &defaultValue
	}
	if r.pagesize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pagesize", r.pagesize, "")
	} else {
		var defaultValue int32 = 100
		r.pagesize = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page-size", r.pageSize, "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	} else {
		var defaultValue string = "date:desc"
		r.sort = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryPreloadAPIV1InventoryPreloadHistoryPostRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
	objectHistoryNote *ObjectHistoryNote
}

// History notes to create
func (r InventoryPreloadAPIV1InventoryPreloadHistoryPostRequest) ObjectHistoryNote(objectHistoryNote ObjectHistoryNote) InventoryPreloadAPIV1InventoryPreloadHistoryPostRequest {
	r.objectHistoryNote = &objectHistoryNote
	return r
}

func (r InventoryPreloadAPIV1InventoryPreloadHistoryPostRequest) Execute() (*ObjectHistory, *http.Response, error) {
	return r.ApiService.V1InventoryPreloadHistoryPostExecute(r)
}

/*
V1InventoryPreloadHistoryPost Add Inventory Preload history object notes 

Adds Inventory Preload history object notes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InventoryPreloadAPIV1InventoryPreloadHistoryPostRequest

Deprecated
*/
func (a *InventoryPreloadAPIService) V1InventoryPreloadHistoryPost(ctx context.Context) InventoryPreloadAPIV1InventoryPreloadHistoryPostRequest {
	return InventoryPreloadAPIV1InventoryPreloadHistoryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ObjectHistory
// Deprecated
func (a *InventoryPreloadAPIService) V1InventoryPreloadHistoryPostExecute(r InventoryPreloadAPIV1InventoryPreloadHistoryPostRequest) (*ObjectHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.V1InventoryPreloadHistoryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/inventory-preload/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.objectHistoryNote == nil {
		return localVarReturnValue, nil, reportError("objectHistoryNote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.objectHistoryNote
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryPreloadAPIV1InventoryPreloadIdDeleteRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
	id int32
}

func (r InventoryPreloadAPIV1InventoryPreloadIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1InventoryPreloadIdDeleteExecute(r)
}

/*
V1InventoryPreloadIdDelete Delete an Inventory Preload record 

Deletes an Inventory Preload record.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Inventory Preload identifier
 @return InventoryPreloadAPIV1InventoryPreloadIdDeleteRequest

Deprecated
*/
func (a *InventoryPreloadAPIService) V1InventoryPreloadIdDelete(ctx context.Context, id int32) InventoryPreloadAPIV1InventoryPreloadIdDeleteRequest {
	return InventoryPreloadAPIV1InventoryPreloadIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
// Deprecated
func (a *InventoryPreloadAPIService) V1InventoryPreloadIdDeleteExecute(r InventoryPreloadAPIV1InventoryPreloadIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.V1InventoryPreloadIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/inventory-preload/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type InventoryPreloadAPIV1InventoryPreloadIdGetRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
	id int32
}

func (r InventoryPreloadAPIV1InventoryPreloadIdGetRequest) Execute() (*InventoryPreloadRecord, *http.Response, error) {
	return r.ApiService.V1InventoryPreloadIdGetExecute(r)
}

/*
V1InventoryPreloadIdGet Get an Inventory Preload record 

Retrieves an Inventory Preload record.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Inventory Preload identifier
 @return InventoryPreloadAPIV1InventoryPreloadIdGetRequest

Deprecated
*/
func (a *InventoryPreloadAPIService) V1InventoryPreloadIdGet(ctx context.Context, id int32) InventoryPreloadAPIV1InventoryPreloadIdGetRequest {
	return InventoryPreloadAPIV1InventoryPreloadIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InventoryPreloadRecord
// Deprecated
func (a *InventoryPreloadAPIService) V1InventoryPreloadIdGetExecute(r InventoryPreloadAPIV1InventoryPreloadIdGetRequest) (*InventoryPreloadRecord, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryPreloadRecord
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.V1InventoryPreloadIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/inventory-preload/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryPreloadAPIV1InventoryPreloadIdPutRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
	id int32
	inventoryPreloadRecord *InventoryPreloadRecord
}

// Inventory Preload record to update
func (r InventoryPreloadAPIV1InventoryPreloadIdPutRequest) InventoryPreloadRecord(inventoryPreloadRecord InventoryPreloadRecord) InventoryPreloadAPIV1InventoryPreloadIdPutRequest {
	r.inventoryPreloadRecord = &inventoryPreloadRecord
	return r
}

func (r InventoryPreloadAPIV1InventoryPreloadIdPutRequest) Execute() (*InventoryPreloadRecord, *http.Response, error) {
	return r.ApiService.V1InventoryPreloadIdPutExecute(r)
}

/*
V1InventoryPreloadIdPut Update an Inventory Preload record 

Updates an Inventory Preload record.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Inventory Preload identifier
 @return InventoryPreloadAPIV1InventoryPreloadIdPutRequest

Deprecated
*/
func (a *InventoryPreloadAPIService) V1InventoryPreloadIdPut(ctx context.Context, id int32) InventoryPreloadAPIV1InventoryPreloadIdPutRequest {
	return InventoryPreloadAPIV1InventoryPreloadIdPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InventoryPreloadRecord
// Deprecated
func (a *InventoryPreloadAPIService) V1InventoryPreloadIdPutExecute(r InventoryPreloadAPIV1InventoryPreloadIdPutRequest) (*InventoryPreloadRecord, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryPreloadRecord
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.V1InventoryPreloadIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/inventory-preload/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.inventoryPreloadRecord == nil {
		return localVarReturnValue, nil, reportError("inventoryPreloadRecord is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inventoryPreloadRecord
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryPreloadAPIV1InventoryPreloadPostRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
	inventoryPreloadRecord *InventoryPreloadRecord
}

// Inventory Preload record or records to be created
func (r InventoryPreloadAPIV1InventoryPreloadPostRequest) InventoryPreloadRecord(inventoryPreloadRecord InventoryPreloadRecord) InventoryPreloadAPIV1InventoryPreloadPostRequest {
	r.inventoryPreloadRecord = &inventoryPreloadRecord
	return r
}

func (r InventoryPreloadAPIV1InventoryPreloadPostRequest) Execute() (*InventoryPreloadRecord, *http.Response, error) {
	return r.ApiService.V1InventoryPreloadPostExecute(r)
}

/*
V1InventoryPreloadPost Create a new Inventory Preload record using JSON or CSV 

Create a new Inventory Preload record using JSON or CSV.
A CSV template can be downloaded from /api/inventory-preload/csv-template.
Serial number and device type are required. All other fields are optional.
When a matching serial number exists in the Inventory Preload data, the record will be overwritten with the CSV data.
If the CSV file contains a new username and an email address is provided, the new user is created in Jamf Pro.
If the CSV file contains an existing username, the following user-related fields are updated in Jamf Pro.
Full Name,
Email Address,
Phone Number,
Position.
This endpoint does not do full validation of each record in the CSV data.
To do full validation, use the /inventory-preload/validate-csv endpoint first.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InventoryPreloadAPIV1InventoryPreloadPostRequest

Deprecated
*/
func (a *InventoryPreloadAPIService) V1InventoryPreloadPost(ctx context.Context) InventoryPreloadAPIV1InventoryPreloadPostRequest {
	return InventoryPreloadAPIV1InventoryPreloadPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InventoryPreloadRecord
// Deprecated
func (a *InventoryPreloadAPIService) V1InventoryPreloadPostExecute(r InventoryPreloadAPIV1InventoryPreloadPostRequest) (*InventoryPreloadRecord, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryPreloadRecord
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.V1InventoryPreloadPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/inventory-preload"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.inventoryPreloadRecord == nil {
		return localVarReturnValue, nil, reportError("inventoryPreloadRecord is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inventoryPreloadRecord
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryPreloadAPIV1InventoryPreloadValidateCsvPostRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
	body *map[string]interface{}
}

// Inventory Preload records to be validated. A CSV template can be downloaded from /api/inventory-preload/csv-template
func (r InventoryPreloadAPIV1InventoryPreloadValidateCsvPostRequest) Body(body map[string]interface{}) InventoryPreloadAPIV1InventoryPreloadValidateCsvPostRequest {
	r.body = &body
	return r
}

func (r InventoryPreloadAPIV1InventoryPreloadValidateCsvPostRequest) Execute() (*InventoryPreloadCsvValidationSuccess, *http.Response, error) {
	return r.ApiService.V1InventoryPreloadValidateCsvPostExecute(r)
}

/*
V1InventoryPreloadValidateCsvPost Validate a given CSV file 

Validate a given CSV file.
Serial number and device type are required. All other fields are optional.
A CSV template can be downloaded from /api/inventory-preload/csv-template.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InventoryPreloadAPIV1InventoryPreloadValidateCsvPostRequest

Deprecated
*/
func (a *InventoryPreloadAPIService) V1InventoryPreloadValidateCsvPost(ctx context.Context) InventoryPreloadAPIV1InventoryPreloadValidateCsvPostRequest {
	return InventoryPreloadAPIV1InventoryPreloadValidateCsvPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InventoryPreloadCsvValidationSuccess
// Deprecated
func (a *InventoryPreloadAPIService) V1InventoryPreloadValidateCsvPostExecute(r InventoryPreloadAPIV1InventoryPreloadValidateCsvPostRequest) (*InventoryPreloadCsvValidationSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryPreloadCsvValidationSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.V1InventoryPreloadValidateCsvPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/inventory-preload/validate-csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v InventoryPreloadInvalidCsvResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryPreloadAPIV2InventoryPreloadCsvGetRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
}

func (r InventoryPreloadAPIV2InventoryPreloadCsvGetRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.V2InventoryPreloadCsvGetExecute(r)
}

/*
V2InventoryPreloadCsvGet Download all Inventory Preload records

Returns all Inventory Preload records as a CSV file.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InventoryPreloadAPIV2InventoryPreloadCsvGetRequest
*/
func (a *InventoryPreloadAPIService) V2InventoryPreloadCsvGet(ctx context.Context) InventoryPreloadAPIV2InventoryPreloadCsvGetRequest {
	return InventoryPreloadAPIV2InventoryPreloadCsvGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *InventoryPreloadAPIService) V2InventoryPreloadCsvGetExecute(r InventoryPreloadAPIV2InventoryPreloadCsvGetRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.V2InventoryPreloadCsvGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inventory-preload/csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryPreloadAPIV2InventoryPreloadCsvPostRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
	file *string
}

// The CSV file to upload
func (r InventoryPreloadAPIV2InventoryPreloadCsvPostRequest) File(file string) InventoryPreloadAPIV2InventoryPreloadCsvPostRequest {
	r.file = &file
	return r
}

func (r InventoryPreloadAPIV2InventoryPreloadCsvPostRequest) Execute() ([]HrefResponse, *http.Response, error) {
	return r.ApiService.V2InventoryPreloadCsvPostExecute(r)
}

/*
V2InventoryPreloadCsvPost Create one or more new Inventory Preload records using CSV 

Create one or more new Inventory Preload records using CSV.
A CSV template can be downloaded from /v2/inventory-preload/csv-template.
Serial number and device type are required. All other fields are optional.
When a matching serial number exists in the Inventory Preload data, the record will be overwritten with the CSV data.
If the CSV file contains a new username and an email address is provided, the new user is created in Jamf Pro.
If the CSV file contains an existing username, the following user-related fields are updated in Jamf Pro.
Full Name,
Email Address,
Phone Number,
Position.
This endpoint does not do full validation of each record in the CSV data.
To do full validation, use the `/v2/inventory-preload/csv-validate` endpoint first.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InventoryPreloadAPIV2InventoryPreloadCsvPostRequest
*/
func (a *InventoryPreloadAPIService) V2InventoryPreloadCsvPost(ctx context.Context) InventoryPreloadAPIV2InventoryPreloadCsvPostRequest {
	return InventoryPreloadAPIV2InventoryPreloadCsvPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []HrefResponse
func (a *InventoryPreloadAPIService) V2InventoryPreloadCsvPostExecute(r InventoryPreloadAPIV2InventoryPreloadCsvPostRequest) ([]HrefResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []HrefResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.V2InventoryPreloadCsvPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inventory-preload/csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.file == nil {
		return localVarReturnValue, nil, reportError("file is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "file", r.file, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InventoryPreloadCsvValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryPreloadAPIV2InventoryPreloadCsvTemplateGetRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
}

func (r InventoryPreloadAPIV2InventoryPreloadCsvTemplateGetRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.V2InventoryPreloadCsvTemplateGetExecute(r)
}

/*
V2InventoryPreloadCsvTemplateGet Download the Inventory Preload CSV template

Retrieves the Inventory Preload CSV file template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InventoryPreloadAPIV2InventoryPreloadCsvTemplateGetRequest
*/
func (a *InventoryPreloadAPIService) V2InventoryPreloadCsvTemplateGet(ctx context.Context) InventoryPreloadAPIV2InventoryPreloadCsvTemplateGetRequest {
	return InventoryPreloadAPIV2InventoryPreloadCsvTemplateGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *InventoryPreloadAPIService) V2InventoryPreloadCsvTemplateGetExecute(r InventoryPreloadAPIV2InventoryPreloadCsvTemplateGetRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.V2InventoryPreloadCsvTemplateGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inventory-preload/csv-template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryPreloadAPIV2InventoryPreloadCsvValidatePostRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
	file *string
}

// The CSV file to upload
func (r InventoryPreloadAPIV2InventoryPreloadCsvValidatePostRequest) File(file string) InventoryPreloadAPIV2InventoryPreloadCsvValidatePostRequest {
	r.file = &file
	return r
}

func (r InventoryPreloadAPIV2InventoryPreloadCsvValidatePostRequest) Execute() (*InventoryPreloadCsvValidationSuccess, *http.Response, error) {
	return r.ApiService.V2InventoryPreloadCsvValidatePostExecute(r)
}

/*
V2InventoryPreloadCsvValidatePost Validate a given CSV file 

Validate a given CSV file.
Serial number and device type are required. All other fields are optional.
A CSV template can be downloaded from `/v2/inventory-preload/csv-template`.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InventoryPreloadAPIV2InventoryPreloadCsvValidatePostRequest
*/
func (a *InventoryPreloadAPIService) V2InventoryPreloadCsvValidatePost(ctx context.Context) InventoryPreloadAPIV2InventoryPreloadCsvValidatePostRequest {
	return InventoryPreloadAPIV2InventoryPreloadCsvValidatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InventoryPreloadCsvValidationSuccess
func (a *InventoryPreloadAPIService) V2InventoryPreloadCsvValidatePostExecute(r InventoryPreloadAPIV2InventoryPreloadCsvValidatePostRequest) (*InventoryPreloadCsvValidationSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryPreloadCsvValidationSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.V2InventoryPreloadCsvValidatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inventory-preload/csv-validate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.file == nil {
		return localVarReturnValue, nil, reportError("file is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "file", r.file, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InventoryPreloadCsvValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryPreloadAPIV2InventoryPreloadEaColumnsGetRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
}

func (r InventoryPreloadAPIV2InventoryPreloadEaColumnsGetRequest) Execute() (*InventoryPreloadExtensionAttributeColumnResult, *http.Response, error) {
	return r.ApiService.V2InventoryPreloadEaColumnsGetExecute(r)
}

/*
V2InventoryPreloadEaColumnsGet Retrieve a list of extension attribute columns 

Retrieve a list of extension attribute columns currently associated
with inventory preload records


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InventoryPreloadAPIV2InventoryPreloadEaColumnsGetRequest
*/
func (a *InventoryPreloadAPIService) V2InventoryPreloadEaColumnsGet(ctx context.Context) InventoryPreloadAPIV2InventoryPreloadEaColumnsGetRequest {
	return InventoryPreloadAPIV2InventoryPreloadEaColumnsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InventoryPreloadExtensionAttributeColumnResult
func (a *InventoryPreloadAPIService) V2InventoryPreloadEaColumnsGetExecute(r InventoryPreloadAPIV2InventoryPreloadEaColumnsGetRequest) (*InventoryPreloadExtensionAttributeColumnResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryPreloadExtensionAttributeColumnResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.V2InventoryPreloadEaColumnsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inventory-preload/ea-columns"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryPreloadAPIV2InventoryPreloadExportPostRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
	exportFields *[]string
	exportLabels *[]string
	page *int32
	pageSize *int32
	sort *[]string
	filter *string
	exportParameters *ExportParameters
}

// Export fields parameter, used to change default order or ignore some of the response properties. Default is empty array, which means that all fields of the response entity will be serialized. Example: export-fields&#x3D;id,username
func (r InventoryPreloadAPIV2InventoryPreloadExportPostRequest) ExportFields(exportFields []string) InventoryPreloadAPIV2InventoryPreloadExportPostRequest {
	r.exportFields = &exportFields
	return r
}

// Export labels parameter, used to customize fieldnames/columns in the exported file. Default is empty array, which means that response properties names will be used. Number of the provided labels must match the number of export-fields Example: export-labels&#x3D;identifier,name with matching: export-fields&#x3D;id,username
func (r InventoryPreloadAPIV2InventoryPreloadExportPostRequest) ExportLabels(exportLabels []string) InventoryPreloadAPIV2InventoryPreloadExportPostRequest {
	r.exportLabels = &exportLabels
	return r
}

func (r InventoryPreloadAPIV2InventoryPreloadExportPostRequest) Page(page int32) InventoryPreloadAPIV2InventoryPreloadExportPostRequest {
	r.page = &page
	return r
}

func (r InventoryPreloadAPIV2InventoryPreloadExportPostRequest) PageSize(pageSize int32) InventoryPreloadAPIV2InventoryPreloadExportPostRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: &#x60;property:asc/desc&#x60;. Default sort is &#x60;id:asc&#x60;. Multiple sort criteria are supported and must be separated with a comma. All inventory preload fields are supported, however fields added by extension attributes are not supported. If sorting by deviceType, use &#x60;0&#x60; for Computer and &#x60;1&#x60; for Mobile Device.  Example: &#x60;sort&#x3D;date:desc,name:asc&#x60;. 
func (r InventoryPreloadAPIV2InventoryPreloadExportPostRequest) Sort(sort []string) InventoryPreloadAPIV2InventoryPreloadExportPostRequest {
	r.sort = &sort
	return r
}

// Allowing to filter inventory preload records. Default search is empty query - returning all results for the requested page. All inventory preload fields are supported, however fields added by extension attributes are not supported. If filtering by deviceType, use &#x60;0&#x60; for Computer and &#x60;1&#x60; for Mobile Device.  Query in the RSQL format, allowing &#x60;&#x3D;&#x3D;&#x60;, &#x60;!&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;&lt;&#x60;, and &#x60;&#x3D;in&#x3D;&#x60;.  Example: &#x60;filter&#x3D;categoryName&#x3D;&#x3D;\&quot;Category\&quot;&#x60; 
func (r InventoryPreloadAPIV2InventoryPreloadExportPostRequest) Filter(filter string) InventoryPreloadAPIV2InventoryPreloadExportPostRequest {
	r.filter = &filter
	return r
}

// Optional. Override query parameters since they can make URI exceed 2,000 character limit.
func (r InventoryPreloadAPIV2InventoryPreloadExportPostRequest) ExportParameters(exportParameters ExportParameters) InventoryPreloadAPIV2InventoryPreloadExportPostRequest {
	r.exportParameters = &exportParameters
	return r
}

func (r InventoryPreloadAPIV2InventoryPreloadExportPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.V2InventoryPreloadExportPostExecute(r)
}

/*
V2InventoryPreloadExportPost Export a collection of inventory preload records 

Export a collection of inventory preload records


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InventoryPreloadAPIV2InventoryPreloadExportPostRequest
*/
func (a *InventoryPreloadAPIService) V2InventoryPreloadExportPost(ctx context.Context) InventoryPreloadAPIV2InventoryPreloadExportPostRequest {
	return InventoryPreloadAPIV2InventoryPreloadExportPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *InventoryPreloadAPIService) V2InventoryPreloadExportPostExecute(r InventoryPreloadAPIV2InventoryPreloadExportPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.V2InventoryPreloadExportPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inventory-preload/export"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.exportFields != nil {
		t := *r.exportFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "export-fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "export-fields", t, "multi")
		}
	} else {
		defaultValue := []string{}
		r.exportFields = &defaultValue
	}
	if r.exportLabels != nil {
		t := *r.exportLabels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "export-labels", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "export-labels", t, "multi")
		}
	} else {
		defaultValue := []string{}
		r.exportLabels = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 0
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page-size", r.pageSize, "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	} else {
		defaultValue := []string{"id:asc"}
		r.sort = &defaultValue
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	} else {
		var defaultValue string = ""
		r.filter = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.exportParameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryPreloadAPIV2InventoryPreloadHistoryGetRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
	page *int32
	pageSize *int32
	sort *[]string
	filter *string
}

func (r InventoryPreloadAPIV2InventoryPreloadHistoryGetRequest) Page(page int32) InventoryPreloadAPIV2InventoryPreloadHistoryGetRequest {
	r.page = &page
	return r
}

func (r InventoryPreloadAPIV2InventoryPreloadHistoryGetRequest) PageSize(pageSize int32) InventoryPreloadAPIV2InventoryPreloadHistoryGetRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: &#x60;property:asc/desc&#x60;. Default sort is &#x60;date:desc&#x60;. Multiple sort criteria are supported and must be separated with a comma.  Example: &#x60;sort&#x3D;date:desc,name:asc&#x60;. 
func (r InventoryPreloadAPIV2InventoryPreloadHistoryGetRequest) Sort(sort []string) InventoryPreloadAPIV2InventoryPreloadHistoryGetRequest {
	r.sort = &sort
	return r
}

// Allows filtering inventory preload history records. Default search is empty query - returning all results for the requested page. All inventory preload history fields are supported.  Query in the RSQL format, allowing &#x60;&#x3D;&#x3D;&#x60;, &#x60;!&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;&lt;&#x60;, and &#x60;&#x3D;in&#x3D;&#x60;.  Example: &#x60;filter&#x3D;username&#x3D;&#x3D;\&quot;admin\&quot;&#x60; 
func (r InventoryPreloadAPIV2InventoryPreloadHistoryGetRequest) Filter(filter string) InventoryPreloadAPIV2InventoryPreloadHistoryGetRequest {
	r.filter = &filter
	return r
}

func (r InventoryPreloadAPIV2InventoryPreloadHistoryGetRequest) Execute() (*HistorySearchResults, *http.Response, error) {
	return r.ApiService.V2InventoryPreloadHistoryGetExecute(r)
}

/*
V2InventoryPreloadHistoryGet Get Inventory Preload history entries 

Gets Inventory Preload history entries.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InventoryPreloadAPIV2InventoryPreloadHistoryGetRequest
*/
func (a *InventoryPreloadAPIService) V2InventoryPreloadHistoryGet(ctx context.Context) InventoryPreloadAPIV2InventoryPreloadHistoryGetRequest {
	return InventoryPreloadAPIV2InventoryPreloadHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HistorySearchResults
func (a *InventoryPreloadAPIService) V2InventoryPreloadHistoryGetExecute(r InventoryPreloadAPIV2InventoryPreloadHistoryGetRequest) (*HistorySearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistorySearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.V2InventoryPreloadHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inventory-preload/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 0
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page-size", r.pageSize, "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	} else {
		defaultValue := []string{"date:desc"}
		r.sort = &defaultValue
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	} else {
		var defaultValue string = ""
		r.filter = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryPreloadAPIV2InventoryPreloadHistoryPostRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
	objectHistoryNote *ObjectHistoryNote
}

// History notes to create
func (r InventoryPreloadAPIV2InventoryPreloadHistoryPostRequest) ObjectHistoryNote(objectHistoryNote ObjectHistoryNote) InventoryPreloadAPIV2InventoryPreloadHistoryPostRequest {
	r.objectHistoryNote = &objectHistoryNote
	return r
}

func (r InventoryPreloadAPIV2InventoryPreloadHistoryPostRequest) Execute() (*HrefResponse, *http.Response, error) {
	return r.ApiService.V2InventoryPreloadHistoryPostExecute(r)
}

/*
V2InventoryPreloadHistoryPost Add Inventory Preload history object notes

Adds Inventory Preload history object notes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InventoryPreloadAPIV2InventoryPreloadHistoryPostRequest
*/
func (a *InventoryPreloadAPIService) V2InventoryPreloadHistoryPost(ctx context.Context) InventoryPreloadAPIV2InventoryPreloadHistoryPostRequest {
	return InventoryPreloadAPIV2InventoryPreloadHistoryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HrefResponse
func (a *InventoryPreloadAPIService) V2InventoryPreloadHistoryPostExecute(r InventoryPreloadAPIV2InventoryPreloadHistoryPostRequest) (*HrefResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HrefResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.V2InventoryPreloadHistoryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inventory-preload/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.objectHistoryNote == nil {
		return localVarReturnValue, nil, reportError("objectHistoryNote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.objectHistoryNote
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryPreloadAPIV2InventoryPreloadRecordsDeleteAllPostRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
}

func (r InventoryPreloadAPIV2InventoryPreloadRecordsDeleteAllPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2InventoryPreloadRecordsDeleteAllPostExecute(r)
}

/*
V2InventoryPreloadRecordsDeleteAllPost Delete all Inventory Preload records 

Deletes all Inventory Preload records.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InventoryPreloadAPIV2InventoryPreloadRecordsDeleteAllPostRequest
*/
func (a *InventoryPreloadAPIService) V2InventoryPreloadRecordsDeleteAllPost(ctx context.Context) InventoryPreloadAPIV2InventoryPreloadRecordsDeleteAllPostRequest {
	return InventoryPreloadAPIV2InventoryPreloadRecordsDeleteAllPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *InventoryPreloadAPIService) V2InventoryPreloadRecordsDeleteAllPostExecute(r InventoryPreloadAPIV2InventoryPreloadRecordsDeleteAllPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.V2InventoryPreloadRecordsDeleteAllPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inventory-preload/records/delete-all"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type InventoryPreloadAPIV2InventoryPreloadRecordsGetRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
	page *int32
	pageSize *int32
	sort *[]string
	filter *string
}

func (r InventoryPreloadAPIV2InventoryPreloadRecordsGetRequest) Page(page int32) InventoryPreloadAPIV2InventoryPreloadRecordsGetRequest {
	r.page = &page
	return r
}

func (r InventoryPreloadAPIV2InventoryPreloadRecordsGetRequest) PageSize(pageSize int32) InventoryPreloadAPIV2InventoryPreloadRecordsGetRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: &#x60;property:asc/desc&#x60;. Default sort is &#x60;id:asc&#x60;. Multiple sort criteria are supported and must be separated with a comma. All inventory preload fields are supported, however fields added by extension attributes are not supported. If sorting by deviceType, use &#x60;0&#x60; for Computer and &#x60;1&#x60; for Mobile Device.  Example: &#x60;sort&#x3D;date:desc,name:asc&#x60;. 
func (r InventoryPreloadAPIV2InventoryPreloadRecordsGetRequest) Sort(sort []string) InventoryPreloadAPIV2InventoryPreloadRecordsGetRequest {
	r.sort = &sort
	return r
}

// Allowing to filter inventory preload records. Default search is empty query - returning all results for the requested page. All inventory preload fields are supported, however fields added by extension attributes are not supported. If filtering by deviceType, use &#x60;0&#x60; for Computer and &#x60;1&#x60; for Mobile Device.  Query in the RSQL format, allowing &#x60;&#x3D;&#x3D;&#x60;, &#x60;!&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;&lt;&#x60;, and &#x60;&#x3D;in&#x3D;&#x60;.  Example: &#x60;filter&#x3D;categoryName&#x3D;&#x3D;\&quot;Category\&quot;&#x60; 
func (r InventoryPreloadAPIV2InventoryPreloadRecordsGetRequest) Filter(filter string) InventoryPreloadAPIV2InventoryPreloadRecordsGetRequest {
	r.filter = &filter
	return r
}

func (r InventoryPreloadAPIV2InventoryPreloadRecordsGetRequest) Execute() (*InventoryPreloadRecordSearchResultsV2, *http.Response, error) {
	return r.ApiService.V2InventoryPreloadRecordsGetExecute(r)
}

/*
V2InventoryPreloadRecordsGet Return all Inventory Preload records

Returns all Inventory Preload records.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InventoryPreloadAPIV2InventoryPreloadRecordsGetRequest
*/
func (a *InventoryPreloadAPIService) V2InventoryPreloadRecordsGet(ctx context.Context) InventoryPreloadAPIV2InventoryPreloadRecordsGetRequest {
	return InventoryPreloadAPIV2InventoryPreloadRecordsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InventoryPreloadRecordSearchResultsV2
func (a *InventoryPreloadAPIService) V2InventoryPreloadRecordsGetExecute(r InventoryPreloadAPIV2InventoryPreloadRecordsGetRequest) (*InventoryPreloadRecordSearchResultsV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryPreloadRecordSearchResultsV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.V2InventoryPreloadRecordsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inventory-preload/records"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 0
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page-size", r.pageSize, "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	} else {
		defaultValue := []string{"id:asc"}
		r.sort = &defaultValue
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	} else {
		var defaultValue string = ""
		r.filter = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryPreloadAPIV2InventoryPreloadRecordsIdDeleteRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
	id string
}

func (r InventoryPreloadAPIV2InventoryPreloadRecordsIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2InventoryPreloadRecordsIdDeleteExecute(r)
}

/*
V2InventoryPreloadRecordsIdDelete Delete an Inventory Preload record 

Deletes an Inventory Preload record.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Inventory Preload identifier
 @return InventoryPreloadAPIV2InventoryPreloadRecordsIdDeleteRequest
*/
func (a *InventoryPreloadAPIService) V2InventoryPreloadRecordsIdDelete(ctx context.Context, id string) InventoryPreloadAPIV2InventoryPreloadRecordsIdDeleteRequest {
	return InventoryPreloadAPIV2InventoryPreloadRecordsIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *InventoryPreloadAPIService) V2InventoryPreloadRecordsIdDeleteExecute(r InventoryPreloadAPIV2InventoryPreloadRecordsIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.V2InventoryPreloadRecordsIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inventory-preload/records/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type InventoryPreloadAPIV2InventoryPreloadRecordsIdGetRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
	id string
}

func (r InventoryPreloadAPIV2InventoryPreloadRecordsIdGetRequest) Execute() (*InventoryPreloadRecordV2, *http.Response, error) {
	return r.ApiService.V2InventoryPreloadRecordsIdGetExecute(r)
}

/*
V2InventoryPreloadRecordsIdGet Get an Inventory Preload record

Retrieves an Inventory Preload record.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Inventory Preload identifier
 @return InventoryPreloadAPIV2InventoryPreloadRecordsIdGetRequest
*/
func (a *InventoryPreloadAPIService) V2InventoryPreloadRecordsIdGet(ctx context.Context, id string) InventoryPreloadAPIV2InventoryPreloadRecordsIdGetRequest {
	return InventoryPreloadAPIV2InventoryPreloadRecordsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InventoryPreloadRecordV2
func (a *InventoryPreloadAPIService) V2InventoryPreloadRecordsIdGetExecute(r InventoryPreloadAPIV2InventoryPreloadRecordsIdGetRequest) (*InventoryPreloadRecordV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryPreloadRecordV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.V2InventoryPreloadRecordsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inventory-preload/records/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryPreloadAPIV2InventoryPreloadRecordsIdPutRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
	id string
	inventoryPreloadRecordV2 *InventoryPreloadRecordV2
}

// Inventory Preload record to update
func (r InventoryPreloadAPIV2InventoryPreloadRecordsIdPutRequest) InventoryPreloadRecordV2(inventoryPreloadRecordV2 InventoryPreloadRecordV2) InventoryPreloadAPIV2InventoryPreloadRecordsIdPutRequest {
	r.inventoryPreloadRecordV2 = &inventoryPreloadRecordV2
	return r
}

func (r InventoryPreloadAPIV2InventoryPreloadRecordsIdPutRequest) Execute() (*InventoryPreloadRecordV2, *http.Response, error) {
	return r.ApiService.V2InventoryPreloadRecordsIdPutExecute(r)
}

/*
V2InventoryPreloadRecordsIdPut Update an Inventory Preload record

Updates an Inventory Preload record.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Inventory Preload identifier
 @return InventoryPreloadAPIV2InventoryPreloadRecordsIdPutRequest
*/
func (a *InventoryPreloadAPIService) V2InventoryPreloadRecordsIdPut(ctx context.Context, id string) InventoryPreloadAPIV2InventoryPreloadRecordsIdPutRequest {
	return InventoryPreloadAPIV2InventoryPreloadRecordsIdPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InventoryPreloadRecordV2
func (a *InventoryPreloadAPIService) V2InventoryPreloadRecordsIdPutExecute(r InventoryPreloadAPIV2InventoryPreloadRecordsIdPutRequest) (*InventoryPreloadRecordV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryPreloadRecordV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.V2InventoryPreloadRecordsIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inventory-preload/records/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.inventoryPreloadRecordV2 == nil {
		return localVarReturnValue, nil, reportError("inventoryPreloadRecordV2 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inventoryPreloadRecordV2
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryPreloadAPIV2InventoryPreloadRecordsPostRequest struct {
	ctx context.Context
	ApiService InventoryPreloadAPI
	inventoryPreloadRecordV2 *InventoryPreloadRecordV2
}

// Inventory Preload record to be created.
func (r InventoryPreloadAPIV2InventoryPreloadRecordsPostRequest) InventoryPreloadRecordV2(inventoryPreloadRecordV2 InventoryPreloadRecordV2) InventoryPreloadAPIV2InventoryPreloadRecordsPostRequest {
	r.inventoryPreloadRecordV2 = &inventoryPreloadRecordV2
	return r
}

func (r InventoryPreloadAPIV2InventoryPreloadRecordsPostRequest) Execute() (*HrefResponse, *http.Response, error) {
	return r.ApiService.V2InventoryPreloadRecordsPostExecute(r)
}

/*
V2InventoryPreloadRecordsPost Create a new Inventory Preload record using JSON

Create a new Inventory Preload record using JSON.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InventoryPreloadAPIV2InventoryPreloadRecordsPostRequest
*/
func (a *InventoryPreloadAPIService) V2InventoryPreloadRecordsPost(ctx context.Context) InventoryPreloadAPIV2InventoryPreloadRecordsPostRequest {
	return InventoryPreloadAPIV2InventoryPreloadRecordsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HrefResponse
func (a *InventoryPreloadAPIService) V2InventoryPreloadRecordsPostExecute(r InventoryPreloadAPIV2InventoryPreloadRecordsPostRequest) (*HrefResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HrefResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryPreloadAPIService.V2InventoryPreloadRecordsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inventory-preload/records"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.inventoryPreloadRecordV2 == nil {
		return localVarReturnValue, nil, reportError("inventoryPreloadRecordV2 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inventoryPreloadRecordV2
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
