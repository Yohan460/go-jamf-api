/*
Jamf Pro API

## Overview The Jamf Pro API is a RESTful API for Jamf Pro built to enable consistent and efficient programmatic access to Jamf Pro.<br/><br/> The swagger schema can be found [here](/api/schema/). 

API version: production
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


type CloudIdpAPI interface {

	/*
	V1CloudIdpExportPost Export Cloud Identity Providers collection 

	Export Cloud Identity Providers collection


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CloudIdpAPIV1CloudIdpExportPostRequest
	*/
	V1CloudIdpExportPost(ctx context.Context) CloudIdpAPIV1CloudIdpExportPostRequest

	// V1CloudIdpExportPostExecute executes the request
	//  @return interface{}
	V1CloudIdpExportPostExecute(r CloudIdpAPIV1CloudIdpExportPostRequest) (interface{}, *http.Response, error)

	/*
	V1CloudIdpGet Get information about all Cloud Identity Providers configurations.

	Returns basic informations about all configured Cloud Identity Provider.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CloudIdpAPIV1CloudIdpGetRequest
	*/
	V1CloudIdpGet(ctx context.Context) CloudIdpAPIV1CloudIdpGetRequest

	// V1CloudIdpGetExecute executes the request
	//  @return ConfigurationSearchResults
	V1CloudIdpGetExecute(r CloudIdpAPIV1CloudIdpGetRequest) (*ConfigurationSearchResults, *http.Response, error)

	/*
	V1CloudIdpIdGet Get Cloud Identity Provider configuration with given ID.

	Get Cloud Identity Provider configuration with given ID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Cloud Identity Provider identifier
	@return CloudIdpAPIV1CloudIdpIdGetRequest
	*/
	V1CloudIdpIdGet(ctx context.Context, id string) CloudIdpAPIV1CloudIdpIdGetRequest

	// V1CloudIdpIdGetExecute executes the request
	//  @return CloudIdPCommon
	V1CloudIdpIdGetExecute(r CloudIdpAPIV1CloudIdpIdGetRequest) (*CloudIdPCommon, *http.Response, error)

	/*
	V1CloudIdpIdHistoryGet Get Cloud Identity Provider history

	Gets specified Cloud Identity Provider object history

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Cloud Identity Provider identifier
	@return CloudIdpAPIV1CloudIdpIdHistoryGetRequest
	*/
	V1CloudIdpIdHistoryGet(ctx context.Context, id string) CloudIdpAPIV1CloudIdpIdHistoryGetRequest

	// V1CloudIdpIdHistoryGetExecute executes the request
	//  @return HistorySearchResults
	V1CloudIdpIdHistoryGetExecute(r CloudIdpAPIV1CloudIdpIdHistoryGetRequest) (*HistorySearchResults, *http.Response, error)

	/*
	V1CloudIdpIdHistoryPost Add Cloud Identity Provider history note

	Adds specified Cloud Identity Provider object history notes


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Cloud Identity Provider identifier
	@return CloudIdpAPIV1CloudIdpIdHistoryPostRequest
	*/
	V1CloudIdpIdHistoryPost(ctx context.Context, id string) CloudIdpAPIV1CloudIdpIdHistoryPostRequest

	// V1CloudIdpIdHistoryPostExecute executes the request
	//  @return ObjectHistory
	V1CloudIdpIdHistoryPostExecute(r CloudIdpAPIV1CloudIdpIdHistoryPostRequest) (*ObjectHistory, *http.Response, error)

	/*
	V1CloudIdpIdTestGroupPost Get group test search

	Do test search to ensure about configuration and mappings

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Cloud Identity Provider identifier
	@return CloudIdpAPIV1CloudIdpIdTestGroupPostRequest
	*/
	V1CloudIdpIdTestGroupPost(ctx context.Context, id string) CloudIdpAPIV1CloudIdpIdTestGroupPostRequest

	// V1CloudIdpIdTestGroupPostExecute executes the request
	//  @return GroupTestSearchResponse
	V1CloudIdpIdTestGroupPostExecute(r CloudIdpAPIV1CloudIdpIdTestGroupPostRequest) (*GroupTestSearchResponse, *http.Response, error)

	/*
	V1CloudIdpIdTestUserMembershipPost Get membership test search

	Do test search to ensure about configuration and mappings

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Cloud Identity Provider identifier
	@return CloudIdpAPIV1CloudIdpIdTestUserMembershipPostRequest
	*/
	V1CloudIdpIdTestUserMembershipPost(ctx context.Context, id string) CloudIdpAPIV1CloudIdpIdTestUserMembershipPostRequest

	// V1CloudIdpIdTestUserMembershipPostExecute executes the request
	//  @return MembershipTestSearchResponse
	V1CloudIdpIdTestUserMembershipPostExecute(r CloudIdpAPIV1CloudIdpIdTestUserMembershipPostRequest) (*MembershipTestSearchResponse, *http.Response, error)

	/*
	V1CloudIdpIdTestUserPost Get user test search

	Do test search to ensure about configuration and mappings

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Cloud Identity Provider identifier
	@return CloudIdpAPIV1CloudIdpIdTestUserPostRequest
	*/
	V1CloudIdpIdTestUserPost(ctx context.Context, id string) CloudIdpAPIV1CloudIdpIdTestUserPostRequest

	// V1CloudIdpIdTestUserPostExecute executes the request
	//  @return UserTestSearchResponse
	V1CloudIdpIdTestUserPostExecute(r CloudIdpAPIV1CloudIdpIdTestUserPostRequest) (*UserTestSearchResponse, *http.Response, error)
}

// CloudIdpAPIService CloudIdpAPI service
type CloudIdpAPIService service

type CloudIdpAPIV1CloudIdpExportPostRequest struct {
	ctx context.Context
	ApiService CloudIdpAPI
	exportFields *[]string
	exportLabels *[]string
	page *int32
	pageSize *int32
	sort *[]string
	filter *string
	exportParameters *ExportParameters
}

// Export fields parameter, used to change default order or ignore some of the response properties. Default is empty array, which means that all fields of the response entity will be serialized. Example: export-fields&#x3D;id,username
func (r CloudIdpAPIV1CloudIdpExportPostRequest) ExportFields(exportFields []string) CloudIdpAPIV1CloudIdpExportPostRequest {
	r.exportFields = &exportFields
	return r
}

// Export labels parameter, used to customize fieldnames/columns in the exported file. Default is empty array, which means that response properties names will be used. Number of the provided labels must match the number of export-fields Example: export-labels&#x3D;identifier,name with matching: export-fields&#x3D;id,username
func (r CloudIdpAPIV1CloudIdpExportPostRequest) ExportLabels(exportLabels []string) CloudIdpAPIV1CloudIdpExportPostRequest {
	r.exportLabels = &exportLabels
	return r
}

func (r CloudIdpAPIV1CloudIdpExportPostRequest) Page(page int32) CloudIdpAPIV1CloudIdpExportPostRequest {
	r.page = &page
	return r
}

func (r CloudIdpAPIV1CloudIdpExportPostRequest) PageSize(pageSize int32) CloudIdpAPIV1CloudIdpExportPostRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property:asc/desc. Default sort is id:desc. Multiple sort criteria are supported and must be seperated with a comma. Example: sort&#x3D;id:desc,name:asc
func (r CloudIdpAPIV1CloudIdpExportPostRequest) Sort(sort []string) CloudIdpAPIV1CloudIdpExportPostRequest {
	r.sort = &sort
	return r
}

// Query in the RSQL format, allowing to filter history notes collection. Default filter is empty query - returning all results for the requested page. Fields allowed in the query: id, name. This param can be combined with paging and sorting. Example: name&#x3D;&#x3D;\&quot;*department*\&quot;
func (r CloudIdpAPIV1CloudIdpExportPostRequest) Filter(filter string) CloudIdpAPIV1CloudIdpExportPostRequest {
	r.filter = &filter
	return r
}

// Optional. Override query parameters since they can make URI exceed 2,000 character limit.
func (r CloudIdpAPIV1CloudIdpExportPostRequest) ExportParameters(exportParameters ExportParameters) CloudIdpAPIV1CloudIdpExportPostRequest {
	r.exportParameters = &exportParameters
	return r
}

func (r CloudIdpAPIV1CloudIdpExportPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.V1CloudIdpExportPostExecute(r)
}

/*
V1CloudIdpExportPost Export Cloud Identity Providers collection 

Export Cloud Identity Providers collection


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CloudIdpAPIV1CloudIdpExportPostRequest
*/
func (a *CloudIdpAPIService) V1CloudIdpExportPost(ctx context.Context) CloudIdpAPIV1CloudIdpExportPostRequest {
	return CloudIdpAPIV1CloudIdpExportPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *CloudIdpAPIService) V1CloudIdpExportPostExecute(r CloudIdpAPIV1CloudIdpExportPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudIdpAPIService.V1CloudIdpExportPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud-idp/export"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.exportFields != nil {
		t := *r.exportFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "export-fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "export-fields", t, "multi")
		}
	} else {
		var defaultValue []string = []
		r.exportFields = &defaultValue
	}
	if r.exportLabels != nil {
		t := *r.exportLabels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "export-labels", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "export-labels", t, "multi")
		}
	} else {
		var defaultValue []string = []
		r.exportLabels = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 0
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page-size", r.pageSize, "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	} else {
		var defaultValue []string = ["id:asc"]
		r.sort = &defaultValue
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	} else {
		var defaultValue string = ""
		r.filter = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.exportParameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CloudIdpAPIV1CloudIdpGetRequest struct {
	ctx context.Context
	ApiService CloudIdpAPI
	page *int32
	pageSize *int32
	sort *[]string
}

func (r CloudIdpAPIV1CloudIdpGetRequest) Page(page int32) CloudIdpAPIV1CloudIdpGetRequest {
	r.page = &page
	return r
}

func (r CloudIdpAPIV1CloudIdpGetRequest) PageSize(pageSize int32) CloudIdpAPIV1CloudIdpGetRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property:asc/desc. Default sort is id:asc. Multiple sort criteria are supported and must be separated with a comma. Example: sort&#x3D;date:desc,name:asc 
func (r CloudIdpAPIV1CloudIdpGetRequest) Sort(sort []string) CloudIdpAPIV1CloudIdpGetRequest {
	r.sort = &sort
	return r
}

func (r CloudIdpAPIV1CloudIdpGetRequest) Execute() (*ConfigurationSearchResults, *http.Response, error) {
	return r.ApiService.V1CloudIdpGetExecute(r)
}

/*
V1CloudIdpGet Get information about all Cloud Identity Providers configurations.

Returns basic informations about all configured Cloud Identity Provider.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CloudIdpAPIV1CloudIdpGetRequest
*/
func (a *CloudIdpAPIService) V1CloudIdpGet(ctx context.Context) CloudIdpAPIV1CloudIdpGetRequest {
	return CloudIdpAPIV1CloudIdpGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConfigurationSearchResults
func (a *CloudIdpAPIService) V1CloudIdpGetExecute(r CloudIdpAPIV1CloudIdpGetRequest) (*ConfigurationSearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConfigurationSearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudIdpAPIService.V1CloudIdpGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud-idp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 0
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page-size", r.pageSize, "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	} else {
		var defaultValue []string = ["id:desc"]
		r.sort = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CloudIdpAPIV1CloudIdpIdGetRequest struct {
	ctx context.Context
	ApiService CloudIdpAPI
	id string
}

func (r CloudIdpAPIV1CloudIdpIdGetRequest) Execute() (*CloudIdPCommon, *http.Response, error) {
	return r.ApiService.V1CloudIdpIdGetExecute(r)
}

/*
V1CloudIdpIdGet Get Cloud Identity Provider configuration with given ID.

Get Cloud Identity Provider configuration with given ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Cloud Identity Provider identifier
 @return CloudIdpAPIV1CloudIdpIdGetRequest
*/
func (a *CloudIdpAPIService) V1CloudIdpIdGet(ctx context.Context, id string) CloudIdpAPIV1CloudIdpIdGetRequest {
	return CloudIdpAPIV1CloudIdpIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CloudIdPCommon
func (a *CloudIdpAPIService) V1CloudIdpIdGetExecute(r CloudIdpAPIV1CloudIdpIdGetRequest) (*CloudIdPCommon, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CloudIdPCommon
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudIdpAPIService.V1CloudIdpIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud-idp/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CloudIdpAPIV1CloudIdpIdHistoryGetRequest struct {
	ctx context.Context
	ApiService CloudIdpAPI
	id string
	page *int32
	pageSize *int32
	sort *[]string
	filter *string
}

func (r CloudIdpAPIV1CloudIdpIdHistoryGetRequest) Page(page int32) CloudIdpAPIV1CloudIdpIdHistoryGetRequest {
	r.page = &page
	return r
}

func (r CloudIdpAPIV1CloudIdpIdHistoryGetRequest) PageSize(pageSize int32) CloudIdpAPIV1CloudIdpIdHistoryGetRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property:asc/desc. Default sort is date:desc. Multiple sort criteria are supported and must be separated with a comma. Example: sort&#x3D;date:desc,name:asc 
func (r CloudIdpAPIV1CloudIdpIdHistoryGetRequest) Sort(sort []string) CloudIdpAPIV1CloudIdpIdHistoryGetRequest {
	r.sort = &sort
	return r
}

// Query in the RSQL format, allowing to filter history notes collection. Default filter is empty query - returning all results for the requested page. Fields allowed in the query: username, date, note, details. This param can be combined with paging and sorting. Example: filter&#x3D;username!&#x3D;admin and details&#x3D;&#x3D;*disabled* and date&lt;2019-12-15
func (r CloudIdpAPIV1CloudIdpIdHistoryGetRequest) Filter(filter string) CloudIdpAPIV1CloudIdpIdHistoryGetRequest {
	r.filter = &filter
	return r
}

func (r CloudIdpAPIV1CloudIdpIdHistoryGetRequest) Execute() (*HistorySearchResults, *http.Response, error) {
	return r.ApiService.V1CloudIdpIdHistoryGetExecute(r)
}

/*
V1CloudIdpIdHistoryGet Get Cloud Identity Provider history

Gets specified Cloud Identity Provider object history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Cloud Identity Provider identifier
 @return CloudIdpAPIV1CloudIdpIdHistoryGetRequest
*/
func (a *CloudIdpAPIService) V1CloudIdpIdHistoryGet(ctx context.Context, id string) CloudIdpAPIV1CloudIdpIdHistoryGetRequest {
	return CloudIdpAPIV1CloudIdpIdHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return HistorySearchResults
func (a *CloudIdpAPIService) V1CloudIdpIdHistoryGetExecute(r CloudIdpAPIV1CloudIdpIdHistoryGetRequest) (*HistorySearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistorySearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudIdpAPIService.V1CloudIdpIdHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud-idp/{id}/history"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 0
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page-size", r.pageSize, "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	} else {
		var defaultValue []string = ["date:desc"]
		r.sort = &defaultValue
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	} else {
		var defaultValue string = ""
		r.filter = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CloudIdpAPIV1CloudIdpIdHistoryPostRequest struct {
	ctx context.Context
	ApiService CloudIdpAPI
	id string
	objectHistoryNote *ObjectHistoryNote
}

// history notes to create
func (r CloudIdpAPIV1CloudIdpIdHistoryPostRequest) ObjectHistoryNote(objectHistoryNote ObjectHistoryNote) CloudIdpAPIV1CloudIdpIdHistoryPostRequest {
	r.objectHistoryNote = &objectHistoryNote
	return r
}

func (r CloudIdpAPIV1CloudIdpIdHistoryPostRequest) Execute() (*ObjectHistory, *http.Response, error) {
	return r.ApiService.V1CloudIdpIdHistoryPostExecute(r)
}

/*
V1CloudIdpIdHistoryPost Add Cloud Identity Provider history note

Adds specified Cloud Identity Provider object history notes


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Cloud Identity Provider identifier
 @return CloudIdpAPIV1CloudIdpIdHistoryPostRequest
*/
func (a *CloudIdpAPIService) V1CloudIdpIdHistoryPost(ctx context.Context, id string) CloudIdpAPIV1CloudIdpIdHistoryPostRequest {
	return CloudIdpAPIV1CloudIdpIdHistoryPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ObjectHistory
func (a *CloudIdpAPIService) V1CloudIdpIdHistoryPostExecute(r CloudIdpAPIV1CloudIdpIdHistoryPostRequest) (*ObjectHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudIdpAPIService.V1CloudIdpIdHistoryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud-idp/{id}/history"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.objectHistoryNote == nil {
		return localVarReturnValue, nil, reportError("objectHistoryNote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.objectHistoryNote
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CloudIdpAPIV1CloudIdpIdTestGroupPostRequest struct {
	ctx context.Context
	ApiService CloudIdpAPI
	id string
	groupTestSearchRequest *GroupTestSearchRequest
}

// Search request
func (r CloudIdpAPIV1CloudIdpIdTestGroupPostRequest) GroupTestSearchRequest(groupTestSearchRequest GroupTestSearchRequest) CloudIdpAPIV1CloudIdpIdTestGroupPostRequest {
	r.groupTestSearchRequest = &groupTestSearchRequest
	return r
}

func (r CloudIdpAPIV1CloudIdpIdTestGroupPostRequest) Execute() (*GroupTestSearchResponse, *http.Response, error) {
	return r.ApiService.V1CloudIdpIdTestGroupPostExecute(r)
}

/*
V1CloudIdpIdTestGroupPost Get group test search

Do test search to ensure about configuration and mappings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Cloud Identity Provider identifier
 @return CloudIdpAPIV1CloudIdpIdTestGroupPostRequest
*/
func (a *CloudIdpAPIService) V1CloudIdpIdTestGroupPost(ctx context.Context, id string) CloudIdpAPIV1CloudIdpIdTestGroupPostRequest {
	return CloudIdpAPIV1CloudIdpIdTestGroupPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GroupTestSearchResponse
func (a *CloudIdpAPIService) V1CloudIdpIdTestGroupPostExecute(r CloudIdpAPIV1CloudIdpIdTestGroupPostRequest) (*GroupTestSearchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GroupTestSearchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudIdpAPIService.V1CloudIdpIdTestGroupPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud-idp/{id}/test-group"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupTestSearchRequest == nil {
		return localVarReturnValue, nil, reportError("groupTestSearchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupTestSearchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CloudIdpAPIV1CloudIdpIdTestUserMembershipPostRequest struct {
	ctx context.Context
	ApiService CloudIdpAPI
	id string
	membershipTestSearchRequest *MembershipTestSearchRequest
}

// Search request
func (r CloudIdpAPIV1CloudIdpIdTestUserMembershipPostRequest) MembershipTestSearchRequest(membershipTestSearchRequest MembershipTestSearchRequest) CloudIdpAPIV1CloudIdpIdTestUserMembershipPostRequest {
	r.membershipTestSearchRequest = &membershipTestSearchRequest
	return r
}

func (r CloudIdpAPIV1CloudIdpIdTestUserMembershipPostRequest) Execute() (*MembershipTestSearchResponse, *http.Response, error) {
	return r.ApiService.V1CloudIdpIdTestUserMembershipPostExecute(r)
}

/*
V1CloudIdpIdTestUserMembershipPost Get membership test search

Do test search to ensure about configuration and mappings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Cloud Identity Provider identifier
 @return CloudIdpAPIV1CloudIdpIdTestUserMembershipPostRequest
*/
func (a *CloudIdpAPIService) V1CloudIdpIdTestUserMembershipPost(ctx context.Context, id string) CloudIdpAPIV1CloudIdpIdTestUserMembershipPostRequest {
	return CloudIdpAPIV1CloudIdpIdTestUserMembershipPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MembershipTestSearchResponse
func (a *CloudIdpAPIService) V1CloudIdpIdTestUserMembershipPostExecute(r CloudIdpAPIV1CloudIdpIdTestUserMembershipPostRequest) (*MembershipTestSearchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MembershipTestSearchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudIdpAPIService.V1CloudIdpIdTestUserMembershipPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud-idp/{id}/test-user-membership"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.membershipTestSearchRequest == nil {
		return localVarReturnValue, nil, reportError("membershipTestSearchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.membershipTestSearchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CloudIdpAPIV1CloudIdpIdTestUserPostRequest struct {
	ctx context.Context
	ApiService CloudIdpAPI
	id string
	userTestSearchRequest *UserTestSearchRequest
}

// Search request
func (r CloudIdpAPIV1CloudIdpIdTestUserPostRequest) UserTestSearchRequest(userTestSearchRequest UserTestSearchRequest) CloudIdpAPIV1CloudIdpIdTestUserPostRequest {
	r.userTestSearchRequest = &userTestSearchRequest
	return r
}

func (r CloudIdpAPIV1CloudIdpIdTestUserPostRequest) Execute() (*UserTestSearchResponse, *http.Response, error) {
	return r.ApiService.V1CloudIdpIdTestUserPostExecute(r)
}

/*
V1CloudIdpIdTestUserPost Get user test search

Do test search to ensure about configuration and mappings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Cloud Identity Provider identifier
 @return CloudIdpAPIV1CloudIdpIdTestUserPostRequest
*/
func (a *CloudIdpAPIService) V1CloudIdpIdTestUserPost(ctx context.Context, id string) CloudIdpAPIV1CloudIdpIdTestUserPostRequest {
	return CloudIdpAPIV1CloudIdpIdTestUserPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return UserTestSearchResponse
func (a *CloudIdpAPIService) V1CloudIdpIdTestUserPostExecute(r CloudIdpAPIV1CloudIdpIdTestUserPostRequest) (*UserTestSearchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserTestSearchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudIdpAPIService.V1CloudIdpIdTestUserPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud-idp/{id}/test-user"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userTestSearchRequest == nil {
		return localVarReturnValue, nil, reportError("userTestSearchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userTestSearchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
