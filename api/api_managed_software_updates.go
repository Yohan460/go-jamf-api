/*
Jamf Pro API

## Overview The Jamf Pro API is a RESTful API for Jamf Pro built to enable consistent and efficient programmatic access to Jamf Pro.<br/><br/> The swagger schema can be found [here](/api/schema/). 

API version: production
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


type ManagedSoftwareUpdatesAPI interface {

	/*
	V1ManagedSoftwareUpdatesAvailableUpdatesGet Retrieve available macOS and iOS Managed Software Updates

	## BETA
  
These endpoints are available for use in your workflows. It is extremely important to exercise caution when implementing these endpoints, because elements such as the URL or the response could change while this feature is in Beta. If this is the case, we will communicate that upcoming change but there will be no deprecation timeline. Any breaking changes to the API that occur *after* the Beta phase __will be__ held to the standard year-long deprecation timeline.
  
Retrieves available macOS and iOS Managed Software Updates


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesAvailableUpdatesGetRequest
	*/
	V1ManagedSoftwareUpdatesAvailableUpdatesGet(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesAvailableUpdatesGetRequest

	// V1ManagedSoftwareUpdatesAvailableUpdatesGetExecute executes the request
	//  @return AvailableOsUpdates
	V1ManagedSoftwareUpdatesAvailableUpdatesGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesAvailableUpdatesGetRequest) (*AvailableOsUpdates, *http.Response, error)

	/*
	V1ManagedSoftwareUpdatesPlansFeatureToggleGet Retrieve Status of the Feature Toggle

	## BETA
  
These endpoints are available for use in your workflows. It is extremely important to exercise caution when implementing these endpoints, because elements such as the URL or the response could change while this feature is in Beta. If this is the case, we will communicate that upcoming change but there will be no deprecation timeline. Any breaking changes to the API that occur *after* the Beta phase __will be__ held to the standard year-long deprecation timeline.
  
Retrieves Status of the Feature Toggle


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleGetRequest
	*/
	V1ManagedSoftwareUpdatesPlansFeatureToggleGet(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleGetRequest

	// V1ManagedSoftwareUpdatesPlansFeatureToggleGetExecute executes the request
	//  @return ManagedSoftwareUpdatePlanToggle
	V1ManagedSoftwareUpdatesPlansFeatureToggleGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleGetRequest) (*ManagedSoftwareUpdatePlanToggle, *http.Response, error)

	/*
	V1ManagedSoftwareUpdatesPlansFeatureTogglePut Updates Feature Toggle Value

	## BETA
  
These endpoints are available for use in your workflows. It is extremely important to exercise caution when implementing these endpoints, because elements such as the URL or the response could change while this feature is in Beta. If this is the case, we will communicate that upcoming change but there will be no deprecation timeline. Any breaking changes to the API that occur *after* the Beta phase __will be__ held to the standard year-long deprecation timeline.
  
Updates the value of the Feature Toggle


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureTogglePutRequest
	*/
	V1ManagedSoftwareUpdatesPlansFeatureTogglePut(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureTogglePutRequest

	// V1ManagedSoftwareUpdatesPlansFeatureTogglePutExecute executes the request
	//  @return ManagedSoftwareUpdatePlanToggle
	V1ManagedSoftwareUpdatesPlansFeatureTogglePutExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureTogglePutRequest) (*ManagedSoftwareUpdatePlanToggle, *http.Response, error)

	/*
	V1ManagedSoftwareUpdatesPlansGet Retrieve Managed Software Update Plans

	## BETA
  
These endpoints are available for use in your workflows. It is extremely important to exercise caution when implementing these endpoints, because elements such as the URL or the response could change while this feature is in Beta. If this is the case, we will communicate that upcoming change but there will be no deprecation timeline. Any breaking changes to the API that occur *after* the Beta phase __will be__ held to the standard year-long deprecation timeline.
  
Retrieve Managed Software Update Plans


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest
	*/
	V1ManagedSoftwareUpdatesPlansGet(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest

	// V1ManagedSoftwareUpdatesPlansGetExecute executes the request
	//  @return ManagedSoftwareUpdatePlans
	V1ManagedSoftwareUpdatesPlansGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest) (*ManagedSoftwareUpdatePlans, *http.Response, error)

	/*
	V1ManagedSoftwareUpdatesPlansGroupIdGet Retrieve Managed Software Update Plans for a Group

	## BETA
  
These endpoints are available for use in your workflows. It is extremely important to exercise caution when implementing these endpoints, because elements such as the URL or the response could change while this feature is in Beta. If this is the case, we will communicate that upcoming change but there will be no deprecation timeline. Any breaking changes to the API that occur *after* the Beta phase __will be__ held to the standard year-long deprecation timeline.
  
Retrieves Managed Software Update Plans for a Group


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Managed Software Update Group Id
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupIdGetRequest
	*/
	V1ManagedSoftwareUpdatesPlansGroupIdGet(ctx context.Context, id string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupIdGetRequest

	// V1ManagedSoftwareUpdatesPlansGroupIdGetExecute executes the request
	//  @return ManagedSoftwareUpdatePlans
	V1ManagedSoftwareUpdatesPlansGroupIdGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupIdGetRequest) (*ManagedSoftwareUpdatePlans, *http.Response, error)

	/*
	V1ManagedSoftwareUpdatesPlansGroupPost Create Managed Software Update Plans for a Group

	## BETA
  
These endpoints are available for use in your workflows. It is extremely important to exercise caution when implementing these endpoints, because elements such as the URL or the response could change while this feature is in Beta. If this is the case, we will communicate that upcoming change but there will be no deprecation timeline. Any breaking changes to the API that occur *after* the Beta phase __will be__ held to the standard year-long deprecation timeline.
  
Creates Managed Software Update Plans for a Group


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupPostRequest
	*/
	V1ManagedSoftwareUpdatesPlansGroupPost(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupPostRequest

	// V1ManagedSoftwareUpdatesPlansGroupPostExecute executes the request
	//  @return ManagedSoftwareUpdatePlanPostResponse
	V1ManagedSoftwareUpdatesPlansGroupPostExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupPostRequest) (*ManagedSoftwareUpdatePlanPostResponse, *http.Response, error)

	/*
	V1ManagedSoftwareUpdatesPlansIdGet Retrieve a Managed Software Update Plan

	## BETA
  
These endpoints are available for use in your workflows. It is extremely important to exercise caution when implementing these endpoints, because elements such as the URL or the response could change while this feature is in Beta. If this is the case, we will communicate that upcoming change but there will be no deprecation timeline. Any breaking changes to the API that occur *after* the Beta phase __will be__ held to the standard year-long deprecation timeline.
  
Retrieves a Managed Software Update Plan


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Managed Software Update Plan Uuid
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdGetRequest
	*/
	V1ManagedSoftwareUpdatesPlansIdGet(ctx context.Context, id string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdGetRequest

	// V1ManagedSoftwareUpdatesPlansIdGetExecute executes the request
	//  @return ManagedSoftwareUpdatePlan
	V1ManagedSoftwareUpdatesPlansIdGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdGetRequest) (*ManagedSoftwareUpdatePlan, *http.Response, error)

	/*
	V1ManagedSoftwareUpdatesPlansPost Create a Managed Software Update Plan

	## BETA
  
These endpoints are available for use in your workflows. It is extremely important to exercise caution when implementing these endpoints, because elements such as the URL or the response could change while this feature is in Beta. If this is the case, we will communicate that upcoming change but there will be no deprecation timeline. Any breaking changes to the API that occur *after* the Beta phase __will be__ held to the standard year-long deprecation timeline.
  
Creates a Managed Software Update Plan.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansPostRequest
	*/
	V1ManagedSoftwareUpdatesPlansPost(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansPostRequest

	// V1ManagedSoftwareUpdatesPlansPostExecute executes the request
	//  @return ManagedSoftwareUpdatePlanPostResponse
	V1ManagedSoftwareUpdatesPlansPostExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansPostRequest) (*ManagedSoftwareUpdatePlanPostResponse, *http.Response, error)

	/*
	V1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGet Retrieve Managed Software Update Statuses for Computer Groups

	## BETA
  
These endpoints are available for use in your workflows. It is extremely important to exercise caution when implementing these endpoints, because elements such as the URL or the response could change while this feature is in Beta. If this is the case, we will communicate that upcoming change but there will be no deprecation timeline. Any breaking changes to the API that occur *after* the Beta phase __will be__ held to the standard year-long deprecation timeline.
  
Retrieve Managed Software Update Statuses for Computer Groups


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Computer Group identifier
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGetRequest
	*/
	V1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGet(ctx context.Context, id string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGetRequest

	// V1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGetExecute executes the request
	//  @return ManagedSoftwareUpdateStatuses
	V1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGetRequest) (*ManagedSoftwareUpdateStatuses, *http.Response, error)

	/*
	V1ManagedSoftwareUpdatesUpdateStatusesComputersIdGet Retrieve Managed Software Update Statuses for Computers

	## BETA
  
These endpoints are available for use in your workflows. It is extremely important to exercise caution when implementing these endpoints, because elements such as the URL or the response could change while this feature is in Beta. If this is the case, we will communicate that upcoming change but there will be no deprecation timeline. Any breaking changes to the API that occur *after* the Beta phase __will be__ held to the standard year-long deprecation timeline.
  
Retrieve Managed Software Update Statuses for Computers


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Computer identifier
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputersIdGetRequest
	*/
	V1ManagedSoftwareUpdatesUpdateStatusesComputersIdGet(ctx context.Context, id string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputersIdGetRequest

	// V1ManagedSoftwareUpdatesUpdateStatusesComputersIdGetExecute executes the request
	//  @return ManagedSoftwareUpdateStatuses
	V1ManagedSoftwareUpdatesUpdateStatusesComputersIdGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputersIdGetRequest) (*ManagedSoftwareUpdateStatuses, *http.Response, error)

	/*
	V1ManagedSoftwareUpdatesUpdateStatusesGet Retrieve Managed Software Update Statuses

	## BETA
  
These endpoints are available for use in your workflows. It is extremely important to exercise caution when implementing these endpoints, because elements such as the URL or the response could change while this feature is in Beta. If this is the case, we will communicate that upcoming change but there will be no deprecation timeline. Any breaking changes to the API that occur *after* the Beta phase __will be__ held to the standard year-long deprecation timeline.
  
Retrieve Managed Software Update Statuses


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesGetRequest
	*/
	V1ManagedSoftwareUpdatesUpdateStatusesGet(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesGetRequest

	// V1ManagedSoftwareUpdatesUpdateStatusesGetExecute executes the request
	//  @return ManagedSoftwareUpdateStatuses
	V1ManagedSoftwareUpdatesUpdateStatusesGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesGetRequest) (*ManagedSoftwareUpdateStatuses, *http.Response, error)

	/*
	V1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGet Retrieve Managed Software Update Statuses for Mobile Device Groups

	## BETA
  
These endpoints are available for use in your workflows. It is extremely important to exercise caution when implementing these endpoints, because elements such as the URL or the response could change while this feature is in Beta. If this is the case, we will communicate that upcoming change but there will be no deprecation timeline. Any breaking changes to the API that occur *after* the Beta phase __will be__ held to the standard year-long deprecation timeline.
  
Retrieve Managed Software Update Statuses for Mobile Device Groups


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Mobile Device Group identifier
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGetRequest
	*/
	V1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGet(ctx context.Context, id string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGetRequest

	// V1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGetExecute executes the request
	//  @return ManagedSoftwareUpdateStatuses
	V1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGetRequest) (*ManagedSoftwareUpdateStatuses, *http.Response, error)

	/*
	V1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGet Retrieve Managed Software Update Statuses for Mobile Devices

	## BETA
  
These endpoints are available for use in your workflows. It is extremely important to exercise caution when implementing these endpoints, because elements such as the URL or the response could change while this feature is in Beta. If this is the case, we will communicate that upcoming change but there will be no deprecation timeline. Any breaking changes to the API that occur *after* the Beta phase __will be__ held to the standard year-long deprecation timeline.
  
Retrieve Managed Software Update Statuses for Mobile Devices


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Mobile Device identifier
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGetRequest
	*/
	V1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGet(ctx context.Context, id string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGetRequest

	// V1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGetExecute executes the request
	//  @return ManagedSoftwareUpdateStatuses
	V1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGetRequest) (*ManagedSoftwareUpdateStatuses, *http.Response, error)
}

// ManagedSoftwareUpdatesAPIService ManagedSoftwareUpdatesAPI service
type ManagedSoftwareUpdatesAPIService service

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesAvailableUpdatesGetRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesAvailableUpdatesGetRequest) Execute() (*AvailableOsUpdates, *http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesAvailableUpdatesGetExecute(r)
}

/*
V1ManagedSoftwareUpdatesAvailableUpdatesGet Retrieve available macOS and iOS Managed Software Updates

## BETA
  
These endpoints are available for use in your workflows. It is extremely important to exercise caution when implementing these endpoints, because elements such as the URL or the response could change while this feature is in Beta. If this is the case, we will communicate that upcoming change but there will be no deprecation timeline. Any breaking changes to the API that occur *after* the Beta phase __will be__ held to the standard year-long deprecation timeline.
  
Retrieves available macOS and iOS Managed Software Updates


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesAvailableUpdatesGetRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesAvailableUpdatesGet(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesAvailableUpdatesGetRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesAvailableUpdatesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AvailableOsUpdates
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesAvailableUpdatesGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesAvailableUpdatesGetRequest) (*AvailableOsUpdates, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AvailableOsUpdates
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesAvailableUpdatesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/available-updates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleGetRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleGetRequest) Execute() (*ManagedSoftwareUpdatePlanToggle, *http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesPlansFeatureToggleGetExecute(r)
}

/*
V1ManagedSoftwareUpdatesPlansFeatureToggleGet Retrieve Status of the Feature Toggle

## BETA
  
These endpoints are available for use in your workflows. It is extremely important to exercise caution when implementing these endpoints, because elements such as the URL or the response could change while this feature is in Beta. If this is the case, we will communicate that upcoming change but there will be no deprecation timeline. Any breaking changes to the API that occur *after* the Beta phase __will be__ held to the standard year-long deprecation timeline.
  
Retrieves Status of the Feature Toggle


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleGetRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansFeatureToggleGet(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleGetRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ManagedSoftwareUpdatePlanToggle
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansFeatureToggleGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleGetRequest) (*ManagedSoftwareUpdatePlanToggle, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagedSoftwareUpdatePlanToggle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesPlansFeatureToggleGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/plans/feature-toggle"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureTogglePutRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
	managedSoftwareUpdatePlanToggle *ManagedSoftwareUpdatePlanToggle
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureTogglePutRequest) ManagedSoftwareUpdatePlanToggle(managedSoftwareUpdatePlanToggle ManagedSoftwareUpdatePlanToggle) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureTogglePutRequest {
	r.managedSoftwareUpdatePlanToggle = &managedSoftwareUpdatePlanToggle
	return r
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureTogglePutRequest) Execute() (*ManagedSoftwareUpdatePlanToggle, *http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesPlansFeatureTogglePutExecute(r)
}

/*
V1ManagedSoftwareUpdatesPlansFeatureTogglePut Updates Feature Toggle Value

## BETA
  
These endpoints are available for use in your workflows. It is extremely important to exercise caution when implementing these endpoints, because elements such as the URL or the response could change while this feature is in Beta. If this is the case, we will communicate that upcoming change but there will be no deprecation timeline. Any breaking changes to the API that occur *after* the Beta phase __will be__ held to the standard year-long deprecation timeline.
  
Updates the value of the Feature Toggle


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureTogglePutRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansFeatureTogglePut(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureTogglePutRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureTogglePutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ManagedSoftwareUpdatePlanToggle
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansFeatureTogglePutExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureTogglePutRequest) (*ManagedSoftwareUpdatePlanToggle, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagedSoftwareUpdatePlanToggle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesPlansFeatureTogglePut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/plans/feature-toggle"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.managedSoftwareUpdatePlanToggle == nil {
		return localVarReturnValue, nil, reportError("managedSoftwareUpdatePlanToggle is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.managedSoftwareUpdatePlanToggle
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
	page *int32
	pageSize *int32
	sort *[]string
	filter *string
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest) Page(page int32) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest {
	r.page = &page
	return r
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest) PageSize(pageSize int32) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property:asc/desc. Default sort is planUuid:asc. Multiple sort criteria are supported and must be separated with a comma.
func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest) Sort(sort []string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest {
	r.sort = &sort
	return r
}

// Query in the RSQL format, allowing to filter Managed Software Updates collection. Default filter is empty query - returning all results for the requested page. Fields allowed in the query: planUuid, device.deviceId, device.objectType, updateAction, versionType, specificVersion, maxDeferrals, forceInstallLocalDateTime, state.
func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest) Filter(filter string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest {
	r.filter = &filter
	return r
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest) Execute() (*ManagedSoftwareUpdatePlans, *http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesPlansGetExecute(r)
}

/*
V1ManagedSoftwareUpdatesPlansGet Retrieve Managed Software Update Plans

## BETA
  
These endpoints are available for use in your workflows. It is extremely important to exercise caution when implementing these endpoints, because elements such as the URL or the response could change while this feature is in Beta. If this is the case, we will communicate that upcoming change but there will be no deprecation timeline. Any breaking changes to the API that occur *after* the Beta phase __will be__ held to the standard year-long deprecation timeline.
  
Retrieve Managed Software Update Plans


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansGet(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ManagedSoftwareUpdatePlans
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest) (*ManagedSoftwareUpdatePlans, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagedSoftwareUpdatePlans
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesPlansGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/plans"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 0
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page-size", r.pageSize, "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	} else {
		defaultValue := []string{"planUuid:asc"}
		r.sort = &defaultValue
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	} else {
		var defaultValue string = ""
		r.filter = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupIdGetRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
	id string
	groupType *string
}

// Managed Software Update Group Type, Available options are \&quot;COMPUTER_GROUP\&quot; or \&quot;MOBILE_DEVICE_GROUP\&quot;
func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupIdGetRequest) GroupType(groupType string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupIdGetRequest {
	r.groupType = &groupType
	return r
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupIdGetRequest) Execute() (*ManagedSoftwareUpdatePlans, *http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesPlansGroupIdGetExecute(r)
}

/*
V1ManagedSoftwareUpdatesPlansGroupIdGet Retrieve Managed Software Update Plans for a Group

## BETA
  
These endpoints are available for use in your workflows. It is extremely important to exercise caution when implementing these endpoints, because elements such as the URL or the response could change while this feature is in Beta. If this is the case, we will communicate that upcoming change but there will be no deprecation timeline. Any breaking changes to the API that occur *after* the Beta phase __will be__ held to the standard year-long deprecation timeline.
  
Retrieves Managed Software Update Plans for a Group


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Managed Software Update Group Id
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupIdGetRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansGroupIdGet(ctx context.Context, id string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupIdGetRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ManagedSoftwareUpdatePlans
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansGroupIdGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupIdGetRequest) (*ManagedSoftwareUpdatePlans, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagedSoftwareUpdatePlans
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesPlansGroupIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/plans/group/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupType == nil {
		return localVarReturnValue, nil, reportError("groupType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "group-type", r.groupType, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupPostRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
	managedSoftwareUpdatePlanGroupPost *ManagedSoftwareUpdatePlanGroupPost
}

// Managed Software Update Plan to create for Group
func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupPostRequest) ManagedSoftwareUpdatePlanGroupPost(managedSoftwareUpdatePlanGroupPost ManagedSoftwareUpdatePlanGroupPost) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupPostRequest {
	r.managedSoftwareUpdatePlanGroupPost = &managedSoftwareUpdatePlanGroupPost
	return r
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupPostRequest) Execute() (*ManagedSoftwareUpdatePlanPostResponse, *http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesPlansGroupPostExecute(r)
}

/*
V1ManagedSoftwareUpdatesPlansGroupPost Create Managed Software Update Plans for a Group

## BETA
  
These endpoints are available for use in your workflows. It is extremely important to exercise caution when implementing these endpoints, because elements such as the URL or the response could change while this feature is in Beta. If this is the case, we will communicate that upcoming change but there will be no deprecation timeline. Any breaking changes to the API that occur *after* the Beta phase __will be__ held to the standard year-long deprecation timeline.
  
Creates Managed Software Update Plans for a Group


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupPostRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansGroupPost(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupPostRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ManagedSoftwareUpdatePlanPostResponse
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansGroupPostExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupPostRequest) (*ManagedSoftwareUpdatePlanPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagedSoftwareUpdatePlanPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesPlansGroupPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/plans/group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.managedSoftwareUpdatePlanGroupPost == nil {
		return localVarReturnValue, nil, reportError("managedSoftwareUpdatePlanGroupPost is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.managedSoftwareUpdatePlanGroupPost
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdGetRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
	id string
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdGetRequest) Execute() (*ManagedSoftwareUpdatePlan, *http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesPlansIdGetExecute(r)
}

/*
V1ManagedSoftwareUpdatesPlansIdGet Retrieve a Managed Software Update Plan

## BETA
  
These endpoints are available for use in your workflows. It is extremely important to exercise caution when implementing these endpoints, because elements such as the URL or the response could change while this feature is in Beta. If this is the case, we will communicate that upcoming change but there will be no deprecation timeline. Any breaking changes to the API that occur *after* the Beta phase __will be__ held to the standard year-long deprecation timeline.
  
Retrieves a Managed Software Update Plan


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Managed Software Update Plan Uuid
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdGetRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansIdGet(ctx context.Context, id string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdGetRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ManagedSoftwareUpdatePlan
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansIdGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdGetRequest) (*ManagedSoftwareUpdatePlan, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagedSoftwareUpdatePlan
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesPlansIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/plans/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansPostRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
	managedSoftwareUpdatePlanPost *ManagedSoftwareUpdatePlanPost
}

// Managed Software Update Plan to create
func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansPostRequest) ManagedSoftwareUpdatePlanPost(managedSoftwareUpdatePlanPost ManagedSoftwareUpdatePlanPost) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansPostRequest {
	r.managedSoftwareUpdatePlanPost = &managedSoftwareUpdatePlanPost
	return r
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansPostRequest) Execute() (*ManagedSoftwareUpdatePlanPostResponse, *http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesPlansPostExecute(r)
}

/*
V1ManagedSoftwareUpdatesPlansPost Create a Managed Software Update Plan

## BETA
  
These endpoints are available for use in your workflows. It is extremely important to exercise caution when implementing these endpoints, because elements such as the URL or the response could change while this feature is in Beta. If this is the case, we will communicate that upcoming change but there will be no deprecation timeline. Any breaking changes to the API that occur *after* the Beta phase __will be__ held to the standard year-long deprecation timeline.
  
Creates a Managed Software Update Plan.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansPostRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansPost(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansPostRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ManagedSoftwareUpdatePlanPostResponse
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansPostExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansPostRequest) (*ManagedSoftwareUpdatePlanPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagedSoftwareUpdatePlanPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesPlansPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/plans"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.managedSoftwareUpdatePlanPost == nil {
		return localVarReturnValue, nil, reportError("managedSoftwareUpdatePlanPost is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.managedSoftwareUpdatePlanPost
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGetRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
	id string
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGetRequest) Execute() (*ManagedSoftwareUpdateStatuses, *http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGetExecute(r)
}

/*
V1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGet Retrieve Managed Software Update Statuses for Computer Groups

## BETA
  
These endpoints are available for use in your workflows. It is extremely important to exercise caution when implementing these endpoints, because elements such as the URL or the response could change while this feature is in Beta. If this is the case, we will communicate that upcoming change but there will be no deprecation timeline. Any breaking changes to the API that occur *after* the Beta phase __will be__ held to the standard year-long deprecation timeline.
  
Retrieve Managed Software Update Statuses for Computer Groups


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Computer Group identifier
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGetRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGet(ctx context.Context, id string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGetRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ManagedSoftwareUpdateStatuses
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGetRequest) (*ManagedSoftwareUpdateStatuses, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagedSoftwareUpdateStatuses
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/update-statuses/computer-groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputersIdGetRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
	id string
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputersIdGetRequest) Execute() (*ManagedSoftwareUpdateStatuses, *http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesUpdateStatusesComputersIdGetExecute(r)
}

/*
V1ManagedSoftwareUpdatesUpdateStatusesComputersIdGet Retrieve Managed Software Update Statuses for Computers

## BETA
  
These endpoints are available for use in your workflows. It is extremely important to exercise caution when implementing these endpoints, because elements such as the URL or the response could change while this feature is in Beta. If this is the case, we will communicate that upcoming change but there will be no deprecation timeline. Any breaking changes to the API that occur *after* the Beta phase __will be__ held to the standard year-long deprecation timeline.
  
Retrieve Managed Software Update Statuses for Computers


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Computer identifier
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputersIdGetRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesUpdateStatusesComputersIdGet(ctx context.Context, id string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputersIdGetRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputersIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ManagedSoftwareUpdateStatuses
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesUpdateStatusesComputersIdGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputersIdGetRequest) (*ManagedSoftwareUpdateStatuses, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagedSoftwareUpdateStatuses
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesUpdateStatusesComputersIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/update-statuses/computers/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesGetRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
	filter *string
}

// Query in the RSQL format, allowing to filter Managed Software Updates collection. Default filter is empty query - returning all results for the requested page. Fields allowed in the query: osUpdatesStatusId, device.deviceId, device.objectType, downloaded, downloadPercentComplete, productKey, status, deferralsRemaining, maxDeferrals, nextScheduledInstall, created and updated.
func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesGetRequest) Filter(filter string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesGetRequest {
	r.filter = &filter
	return r
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesGetRequest) Execute() (*ManagedSoftwareUpdateStatuses, *http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesUpdateStatusesGetExecute(r)
}

/*
V1ManagedSoftwareUpdatesUpdateStatusesGet Retrieve Managed Software Update Statuses

## BETA
  
These endpoints are available for use in your workflows. It is extremely important to exercise caution when implementing these endpoints, because elements such as the URL or the response could change while this feature is in Beta. If this is the case, we will communicate that upcoming change but there will be no deprecation timeline. Any breaking changes to the API that occur *after* the Beta phase __will be__ held to the standard year-long deprecation timeline.
  
Retrieve Managed Software Update Statuses


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesGetRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesUpdateStatusesGet(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesGetRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ManagedSoftwareUpdateStatuses
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesUpdateStatusesGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesGetRequest) (*ManagedSoftwareUpdateStatuses, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagedSoftwareUpdateStatuses
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesUpdateStatusesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/update-statuses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	} else {
		var defaultValue string = ""
		r.filter = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGetRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
	id string
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGetRequest) Execute() (*ManagedSoftwareUpdateStatuses, *http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGetExecute(r)
}

/*
V1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGet Retrieve Managed Software Update Statuses for Mobile Device Groups

## BETA
  
These endpoints are available for use in your workflows. It is extremely important to exercise caution when implementing these endpoints, because elements such as the URL or the response could change while this feature is in Beta. If this is the case, we will communicate that upcoming change but there will be no deprecation timeline. Any breaking changes to the API that occur *after* the Beta phase __will be__ held to the standard year-long deprecation timeline.
  
Retrieve Managed Software Update Statuses for Mobile Device Groups


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Mobile Device Group identifier
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGetRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGet(ctx context.Context, id string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGetRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ManagedSoftwareUpdateStatuses
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGetRequest) (*ManagedSoftwareUpdateStatuses, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagedSoftwareUpdateStatuses
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/update-statuses/mobile-device-groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGetRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
	id string
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGetRequest) Execute() (*ManagedSoftwareUpdateStatuses, *http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGetExecute(r)
}

/*
V1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGet Retrieve Managed Software Update Statuses for Mobile Devices

## BETA
  
These endpoints are available for use in your workflows. It is extremely important to exercise caution when implementing these endpoints, because elements such as the URL or the response could change while this feature is in Beta. If this is the case, we will communicate that upcoming change but there will be no deprecation timeline. Any breaking changes to the API that occur *after* the Beta phase __will be__ held to the standard year-long deprecation timeline.
  
Retrieve Managed Software Update Statuses for Mobile Devices


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Mobile Device identifier
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGetRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGet(ctx context.Context, id string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGetRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ManagedSoftwareUpdateStatuses
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGetRequest) (*ManagedSoftwareUpdateStatuses, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagedSoftwareUpdateStatuses
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/update-statuses/mobile-devices/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
