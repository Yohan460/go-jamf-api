/*
Jamf Pro API

## Overview The Jamf Pro API is a RESTful API for Jamf Pro built to enable consistent and efficient programmatic access to Jamf Pro.<br/><br/> The swagger schema can be found [here](/api/schema/). 

API version: production
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


type ManagedSoftwareUpdatesAPI interface {

	/*
	V1ManagedSoftwareUpdatesAvailableUpdatesGet Retrieve available macOS and iOS Managed Software Updates

	Retrieves available macOS and iOS Managed Software Updates


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesAvailableUpdatesGetRequest
	*/
	V1ManagedSoftwareUpdatesAvailableUpdatesGet(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesAvailableUpdatesGetRequest

	// V1ManagedSoftwareUpdatesAvailableUpdatesGetExecute executes the request
	//  @return AvailableOsUpdates
	V1ManagedSoftwareUpdatesAvailableUpdatesGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesAvailableUpdatesGetRequest) (*AvailableOsUpdates, *http.Response, error)

	/*
	V1ManagedSoftwareUpdatesPlansFeatureToggleAbandonPost Force stops any ongoing or stalled feature-toggle processes

	"Break Glass" endpoint, not for nominal usage.
Use this endpoint to forcefully abandon the feature-toggle background process if the status of the feature-toggle is 'stuck' or has reached an non-restartable failed state.
Usage of this endpoint under nominal conditions is undefined and unsupported.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleAbandonPostRequest
	*/
	V1ManagedSoftwareUpdatesPlansFeatureToggleAbandonPost(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleAbandonPostRequest

	// V1ManagedSoftwareUpdatesPlansFeatureToggleAbandonPostExecute executes the request
	V1ManagedSoftwareUpdatesPlansFeatureToggleAbandonPostExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleAbandonPostRequest) (*http.Response, error)

	/*
	V1ManagedSoftwareUpdatesPlansFeatureToggleGet Retrieve current value of the Feature Toggle

	Retrieves current value of the Feature Toggle


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleGetRequest
	*/
	V1ManagedSoftwareUpdatesPlansFeatureToggleGet(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleGetRequest

	// V1ManagedSoftwareUpdatesPlansFeatureToggleGetExecute executes the request
	//  @return ManagedSoftwareUpdatePlanToggle
	V1ManagedSoftwareUpdatesPlansFeatureToggleGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleGetRequest) (*ManagedSoftwareUpdatePlanToggle, *http.Response, error)

	/*
	V1ManagedSoftwareUpdatesPlansFeatureTogglePut Updates Feature Toggle Value

	Updates the value of the Feature Toggle - This endpoint is asynchronous, the provided value will not be immediately updated. Please use the following endpoint to track the status of your toggle request. /v1/managed-software-updates/plans/feature-toggle/status:


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureTogglePutRequest
	*/
	V1ManagedSoftwareUpdatesPlansFeatureTogglePut(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureTogglePutRequest

	// V1ManagedSoftwareUpdatesPlansFeatureTogglePutExecute executes the request
	//  @return ManagedSoftwareUpdatePlanToggle
	V1ManagedSoftwareUpdatesPlansFeatureTogglePutExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureTogglePutRequest) (*ManagedSoftwareUpdatePlanToggle, *http.Response, error)

	/*
	V1ManagedSoftwareUpdatesPlansFeatureToggleStatusGet Retrieves background status of the Feature Toggle

	Retrieves background status of the Feature Toggle


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleStatusGetRequest
	*/
	V1ManagedSoftwareUpdatesPlansFeatureToggleStatusGet(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleStatusGetRequest

	// V1ManagedSoftwareUpdatesPlansFeatureToggleStatusGetExecute executes the request
	//  @return ManagedSoftwareUpdatePlanToggleStatusWrapper
	V1ManagedSoftwareUpdatesPlansFeatureToggleStatusGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleStatusGetRequest) (*ManagedSoftwareUpdatePlanToggleStatusWrapper, *http.Response, error)

	/*
	V1ManagedSoftwareUpdatesPlansGet Retrieve Managed Software Update Plans

	Retrieve Managed Software Update Plans


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest
	*/
	V1ManagedSoftwareUpdatesPlansGet(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest

	// V1ManagedSoftwareUpdatesPlansGetExecute executes the request
	//  @return ManagedSoftwareUpdatePlans
	V1ManagedSoftwareUpdatesPlansGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest) (*ManagedSoftwareUpdatePlans, *http.Response, error)

	/*
	V1ManagedSoftwareUpdatesPlansGroupIdGet Retrieve Managed Software Update Plans for a Group

	Retrieves Managed Software Update Plans for a Group


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Managed Software Update Group Id
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupIdGetRequest
	*/
	V1ManagedSoftwareUpdatesPlansGroupIdGet(ctx context.Context, id string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupIdGetRequest

	// V1ManagedSoftwareUpdatesPlansGroupIdGetExecute executes the request
	//  @return ManagedSoftwareUpdatePlans
	V1ManagedSoftwareUpdatesPlansGroupIdGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupIdGetRequest) (*ManagedSoftwareUpdatePlans, *http.Response, error)

	/*
	V1ManagedSoftwareUpdatesPlansGroupPost Create Managed Software Update Plans for a Group

	Creates Managed Software Update Plans for a Group


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupPostRequest
	*/
	V1ManagedSoftwareUpdatesPlansGroupPost(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupPostRequest

	// V1ManagedSoftwareUpdatesPlansGroupPostExecute executes the request
	//  @return ManagedSoftwareUpdatePlanPostResponse
	V1ManagedSoftwareUpdatesPlansGroupPostExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupPostRequest) (*ManagedSoftwareUpdatePlanPostResponse, *http.Response, error)

	/*
	V1ManagedSoftwareUpdatesPlansIdDeclarationsGet Retrieve all Declarations associated with a Managed Software Update Plan

	Retrieves all Declarations associated with a Managed Software Update Plan


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Managed Software Update Plan Uuid
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdDeclarationsGetRequest
	*/
	V1ManagedSoftwareUpdatesPlansIdDeclarationsGet(ctx context.Context, id string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdDeclarationsGetRequest

	// V1ManagedSoftwareUpdatesPlansIdDeclarationsGetExecute executes the request
	//  @return DssDeclarations
	V1ManagedSoftwareUpdatesPlansIdDeclarationsGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdDeclarationsGetRequest) (*DssDeclarations, *http.Response, error)

	/*
	V1ManagedSoftwareUpdatesPlansIdEventsGet Retrieve a Managed Software Update Plan Event Store

	Retrieves a Managed Software Update Plan Event Store


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Managed Software Update Plan Uuid
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdEventsGetRequest
	*/
	V1ManagedSoftwareUpdatesPlansIdEventsGet(ctx context.Context, id string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdEventsGetRequest

	// V1ManagedSoftwareUpdatesPlansIdEventsGetExecute executes the request
	//  @return ManagedSoftwareUpdatePlanEventStore
	V1ManagedSoftwareUpdatesPlansIdEventsGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdEventsGetRequest) (*ManagedSoftwareUpdatePlanEventStore, *http.Response, error)

	/*
	V1ManagedSoftwareUpdatesPlansIdGet Retrieve a Managed Software Update Plan

	Retrieves a Managed Software Update Plan


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Managed Software Update Plan Uuid
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdGetRequest
	*/
	V1ManagedSoftwareUpdatesPlansIdGet(ctx context.Context, id string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdGetRequest

	// V1ManagedSoftwareUpdatesPlansIdGetExecute executes the request
	//  @return ManagedSoftwareUpdatePlan
	V1ManagedSoftwareUpdatesPlansIdGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdGetRequest) (*ManagedSoftwareUpdatePlan, *http.Response, error)

	/*
	V1ManagedSoftwareUpdatesPlansPost Create a Managed Software Update Plan

	Creates a Managed Software Update Plan.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansPostRequest
	*/
	V1ManagedSoftwareUpdatesPlansPost(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansPostRequest

	// V1ManagedSoftwareUpdatesPlansPostExecute executes the request
	//  @return ManagedSoftwareUpdatePlanPostResponse
	V1ManagedSoftwareUpdatesPlansPostExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansPostRequest) (*ManagedSoftwareUpdatePlanPostResponse, *http.Response, error)

	/*
	V1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGet Retrieve Managed Software Update Statuses for Computer Groups

	Retrieve Managed Software Update Statuses for Computer Groups


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Computer Group identifier
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGetRequest
	*/
	V1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGet(ctx context.Context, id string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGetRequest

	// V1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGetExecute executes the request
	//  @return ManagedSoftwareUpdateStatuses
	V1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGetRequest) (*ManagedSoftwareUpdateStatuses, *http.Response, error)

	/*
	V1ManagedSoftwareUpdatesUpdateStatusesComputersIdGet Retrieve Managed Software Update Statuses for Computers

	Retrieve Managed Software Update Statuses for Computers


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Computer identifier
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputersIdGetRequest
	*/
	V1ManagedSoftwareUpdatesUpdateStatusesComputersIdGet(ctx context.Context, id string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputersIdGetRequest

	// V1ManagedSoftwareUpdatesUpdateStatusesComputersIdGetExecute executes the request
	//  @return ManagedSoftwareUpdateStatuses
	V1ManagedSoftwareUpdatesUpdateStatusesComputersIdGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputersIdGetRequest) (*ManagedSoftwareUpdateStatuses, *http.Response, error)

	/*
	V1ManagedSoftwareUpdatesUpdateStatusesGet Retrieve Managed Software Update Statuses

	Retrieve Managed Software Update Statuses


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesGetRequest
	*/
	V1ManagedSoftwareUpdatesUpdateStatusesGet(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesGetRequest

	// V1ManagedSoftwareUpdatesUpdateStatusesGetExecute executes the request
	//  @return ManagedSoftwareUpdateStatuses
	V1ManagedSoftwareUpdatesUpdateStatusesGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesGetRequest) (*ManagedSoftwareUpdateStatuses, *http.Response, error)

	/*
	V1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGet Retrieve Managed Software Update Statuses for Mobile Device Groups

	Retrieve Managed Software Update Statuses for Mobile Device Groups


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Mobile Device Group identifier
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGetRequest
	*/
	V1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGet(ctx context.Context, id string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGetRequest

	// V1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGetExecute executes the request
	//  @return ManagedSoftwareUpdateStatuses
	V1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGetRequest) (*ManagedSoftwareUpdateStatuses, *http.Response, error)

	/*
	V1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGet Retrieve Managed Software Update Statuses for Mobile Devices

	Retrieve Managed Software Update Statuses for Mobile Devices


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Mobile Device identifier
	@return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGetRequest
	*/
	V1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGet(ctx context.Context, id string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGetRequest

	// V1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGetExecute executes the request
	//  @return ManagedSoftwareUpdateStatuses
	V1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGetRequest) (*ManagedSoftwareUpdateStatuses, *http.Response, error)
}

// ManagedSoftwareUpdatesAPIService ManagedSoftwareUpdatesAPI service
type ManagedSoftwareUpdatesAPIService service

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesAvailableUpdatesGetRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesAvailableUpdatesGetRequest) Execute() (*AvailableOsUpdates, *http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesAvailableUpdatesGetExecute(r)
}

/*
V1ManagedSoftwareUpdatesAvailableUpdatesGet Retrieve available macOS and iOS Managed Software Updates

Retrieves available macOS and iOS Managed Software Updates


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesAvailableUpdatesGetRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesAvailableUpdatesGet(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesAvailableUpdatesGetRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesAvailableUpdatesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AvailableOsUpdates
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesAvailableUpdatesGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesAvailableUpdatesGetRequest) (*AvailableOsUpdates, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AvailableOsUpdates
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesAvailableUpdatesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/available-updates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleAbandonPostRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleAbandonPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesPlansFeatureToggleAbandonPostExecute(r)
}

/*
V1ManagedSoftwareUpdatesPlansFeatureToggleAbandonPost Force stops any ongoing or stalled feature-toggle processes

"Break Glass" endpoint, not for nominal usage.
Use this endpoint to forcefully abandon the feature-toggle background process if the status of the feature-toggle is 'stuck' or has reached an non-restartable failed state.
Usage of this endpoint under nominal conditions is undefined and unsupported.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleAbandonPostRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansFeatureToggleAbandonPost(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleAbandonPostRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleAbandonPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansFeatureToggleAbandonPostExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleAbandonPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesPlansFeatureToggleAbandonPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/plans/feature-toggle/abandon"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleGetRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleGetRequest) Execute() (*ManagedSoftwareUpdatePlanToggle, *http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesPlansFeatureToggleGetExecute(r)
}

/*
V1ManagedSoftwareUpdatesPlansFeatureToggleGet Retrieve current value of the Feature Toggle

Retrieves current value of the Feature Toggle


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleGetRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansFeatureToggleGet(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleGetRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ManagedSoftwareUpdatePlanToggle
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansFeatureToggleGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleGetRequest) (*ManagedSoftwareUpdatePlanToggle, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagedSoftwareUpdatePlanToggle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesPlansFeatureToggleGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/plans/feature-toggle"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureTogglePutRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
	managedSoftwareUpdatePlanToggle *ManagedSoftwareUpdatePlanToggle
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureTogglePutRequest) ManagedSoftwareUpdatePlanToggle(managedSoftwareUpdatePlanToggle ManagedSoftwareUpdatePlanToggle) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureTogglePutRequest {
	r.managedSoftwareUpdatePlanToggle = &managedSoftwareUpdatePlanToggle
	return r
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureTogglePutRequest) Execute() (*ManagedSoftwareUpdatePlanToggle, *http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesPlansFeatureTogglePutExecute(r)
}

/*
V1ManagedSoftwareUpdatesPlansFeatureTogglePut Updates Feature Toggle Value

Updates the value of the Feature Toggle - This endpoint is asynchronous, the provided value will not be immediately updated. Please use the following endpoint to track the status of your toggle request. /v1/managed-software-updates/plans/feature-toggle/status:


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureTogglePutRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansFeatureTogglePut(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureTogglePutRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureTogglePutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ManagedSoftwareUpdatePlanToggle
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansFeatureTogglePutExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureTogglePutRequest) (*ManagedSoftwareUpdatePlanToggle, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagedSoftwareUpdatePlanToggle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesPlansFeatureTogglePut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/plans/feature-toggle"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.managedSoftwareUpdatePlanToggle == nil {
		return localVarReturnValue, nil, reportError("managedSoftwareUpdatePlanToggle is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.managedSoftwareUpdatePlanToggle
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleStatusGetRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleStatusGetRequest) Execute() (*ManagedSoftwareUpdatePlanToggleStatusWrapper, *http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesPlansFeatureToggleStatusGetExecute(r)
}

/*
V1ManagedSoftwareUpdatesPlansFeatureToggleStatusGet Retrieves background status of the Feature Toggle

Retrieves background status of the Feature Toggle


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleStatusGetRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansFeatureToggleStatusGet(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleStatusGetRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleStatusGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ManagedSoftwareUpdatePlanToggleStatusWrapper
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansFeatureToggleStatusGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansFeatureToggleStatusGetRequest) (*ManagedSoftwareUpdatePlanToggleStatusWrapper, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagedSoftwareUpdatePlanToggleStatusWrapper
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesPlansFeatureToggleStatusGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/plans/feature-toggle/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
	page *int64
	pageSize *int64
	sort *[]string
	filter *string
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest) Page(page int64) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest {
	r.page = &page
	return r
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest) PageSize(pageSize int64) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property:asc/desc. Default sort is planUuid:asc. Multiple sort criteria are supported and must be separated with a comma.
func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest) Sort(sort []string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest {
	r.sort = &sort
	return r
}

// Query in the RSQL format, allowing to filter Managed Software Updates collection. Default filter is empty query - returning all results for the requested page. Fields allowed in the query: planUuid, device.deviceId, device.objectType, updateAction, versionType, specificVersion, maxDeferrals, recipeId, forceInstallLocalDateTime, state.
func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest) Filter(filter string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest {
	r.filter = &filter
	return r
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest) Execute() (*ManagedSoftwareUpdatePlans, *http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesPlansGetExecute(r)
}

/*
V1ManagedSoftwareUpdatesPlansGet Retrieve Managed Software Update Plans

Retrieve Managed Software Update Plans


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansGet(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ManagedSoftwareUpdatePlans
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGetRequest) (*ManagedSoftwareUpdatePlans, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagedSoftwareUpdatePlans
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesPlansGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/plans"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int64 = 0
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page-size", r.pageSize, "")
	} else {
		var defaultValue int64 = 100
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	} else {
		defaultValue := []string{"planUuid:asc"}
		r.sort = &defaultValue
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	} else {
		var defaultValue string = ""
		r.filter = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupIdGetRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
	id string
	groupType *string
}

// Managed Software Update Group Type, Available options are \&quot;COMPUTER_GROUP\&quot; or \&quot;MOBILE_DEVICE_GROUP\&quot;
func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupIdGetRequest) GroupType(groupType string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupIdGetRequest {
	r.groupType = &groupType
	return r
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupIdGetRequest) Execute() (*ManagedSoftwareUpdatePlans, *http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesPlansGroupIdGetExecute(r)
}

/*
V1ManagedSoftwareUpdatesPlansGroupIdGet Retrieve Managed Software Update Plans for a Group

Retrieves Managed Software Update Plans for a Group


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Managed Software Update Group Id
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupIdGetRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansGroupIdGet(ctx context.Context, id string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupIdGetRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ManagedSoftwareUpdatePlans
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansGroupIdGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupIdGetRequest) (*ManagedSoftwareUpdatePlans, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagedSoftwareUpdatePlans
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesPlansGroupIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/plans/group/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupType == nil {
		return localVarReturnValue, nil, reportError("groupType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "group-type", r.groupType, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupPostRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
	managedSoftwareUpdatePlanGroupPost *ManagedSoftwareUpdatePlanGroupPost
}

// Managed Software Update Plan to create for Group
func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupPostRequest) ManagedSoftwareUpdatePlanGroupPost(managedSoftwareUpdatePlanGroupPost ManagedSoftwareUpdatePlanGroupPost) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupPostRequest {
	r.managedSoftwareUpdatePlanGroupPost = &managedSoftwareUpdatePlanGroupPost
	return r
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupPostRequest) Execute() (*ManagedSoftwareUpdatePlanPostResponse, *http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesPlansGroupPostExecute(r)
}

/*
V1ManagedSoftwareUpdatesPlansGroupPost Create Managed Software Update Plans for a Group

Creates Managed Software Update Plans for a Group


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupPostRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansGroupPost(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupPostRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ManagedSoftwareUpdatePlanPostResponse
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansGroupPostExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansGroupPostRequest) (*ManagedSoftwareUpdatePlanPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagedSoftwareUpdatePlanPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesPlansGroupPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/plans/group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.managedSoftwareUpdatePlanGroupPost == nil {
		return localVarReturnValue, nil, reportError("managedSoftwareUpdatePlanGroupPost is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.managedSoftwareUpdatePlanGroupPost
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdDeclarationsGetRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
	id string
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdDeclarationsGetRequest) Execute() (*DssDeclarations, *http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesPlansIdDeclarationsGetExecute(r)
}

/*
V1ManagedSoftwareUpdatesPlansIdDeclarationsGet Retrieve all Declarations associated with a Managed Software Update Plan

Retrieves all Declarations associated with a Managed Software Update Plan


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Managed Software Update Plan Uuid
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdDeclarationsGetRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansIdDeclarationsGet(ctx context.Context, id string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdDeclarationsGetRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdDeclarationsGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DssDeclarations
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansIdDeclarationsGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdDeclarationsGetRequest) (*DssDeclarations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DssDeclarations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesPlansIdDeclarationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/plans/{id}/declarations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdEventsGetRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
	id string
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdEventsGetRequest) Execute() (*ManagedSoftwareUpdatePlanEventStore, *http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesPlansIdEventsGetExecute(r)
}

/*
V1ManagedSoftwareUpdatesPlansIdEventsGet Retrieve a Managed Software Update Plan Event Store

Retrieves a Managed Software Update Plan Event Store


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Managed Software Update Plan Uuid
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdEventsGetRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansIdEventsGet(ctx context.Context, id string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdEventsGetRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdEventsGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ManagedSoftwareUpdatePlanEventStore
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansIdEventsGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdEventsGetRequest) (*ManagedSoftwareUpdatePlanEventStore, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagedSoftwareUpdatePlanEventStore
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesPlansIdEventsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/plans/{id}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdGetRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
	id string
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdGetRequest) Execute() (*ManagedSoftwareUpdatePlan, *http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesPlansIdGetExecute(r)
}

/*
V1ManagedSoftwareUpdatesPlansIdGet Retrieve a Managed Software Update Plan

Retrieves a Managed Software Update Plan


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Managed Software Update Plan Uuid
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdGetRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansIdGet(ctx context.Context, id string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdGetRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ManagedSoftwareUpdatePlan
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansIdGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansIdGetRequest) (*ManagedSoftwareUpdatePlan, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagedSoftwareUpdatePlan
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesPlansIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/plans/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansPostRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
	managedSoftwareUpdatePlanPost *ManagedSoftwareUpdatePlanPost
}

// Managed Software Update Plan to create
func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansPostRequest) ManagedSoftwareUpdatePlanPost(managedSoftwareUpdatePlanPost ManagedSoftwareUpdatePlanPost) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansPostRequest {
	r.managedSoftwareUpdatePlanPost = &managedSoftwareUpdatePlanPost
	return r
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansPostRequest) Execute() (*ManagedSoftwareUpdatePlanPostResponse, *http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesPlansPostExecute(r)
}

/*
V1ManagedSoftwareUpdatesPlansPost Create a Managed Software Update Plan

Creates a Managed Software Update Plan.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansPostRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansPost(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansPostRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ManagedSoftwareUpdatePlanPostResponse
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesPlansPostExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesPlansPostRequest) (*ManagedSoftwareUpdatePlanPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagedSoftwareUpdatePlanPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesPlansPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/plans"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.managedSoftwareUpdatePlanPost == nil {
		return localVarReturnValue, nil, reportError("managedSoftwareUpdatePlanPost is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.managedSoftwareUpdatePlanPost
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGetRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
	id string
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGetRequest) Execute() (*ManagedSoftwareUpdateStatuses, *http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGetExecute(r)
}

/*
V1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGet Retrieve Managed Software Update Statuses for Computer Groups

Retrieve Managed Software Update Statuses for Computer Groups


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Computer Group identifier
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGetRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGet(ctx context.Context, id string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGetRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ManagedSoftwareUpdateStatuses
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGetRequest) (*ManagedSoftwareUpdateStatuses, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagedSoftwareUpdateStatuses
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesUpdateStatusesComputerGroupsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/update-statuses/computer-groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputersIdGetRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
	id string
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputersIdGetRequest) Execute() (*ManagedSoftwareUpdateStatuses, *http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesUpdateStatusesComputersIdGetExecute(r)
}

/*
V1ManagedSoftwareUpdatesUpdateStatusesComputersIdGet Retrieve Managed Software Update Statuses for Computers

Retrieve Managed Software Update Statuses for Computers


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Computer identifier
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputersIdGetRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesUpdateStatusesComputersIdGet(ctx context.Context, id string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputersIdGetRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputersIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ManagedSoftwareUpdateStatuses
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesUpdateStatusesComputersIdGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesComputersIdGetRequest) (*ManagedSoftwareUpdateStatuses, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagedSoftwareUpdateStatuses
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesUpdateStatusesComputersIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/update-statuses/computers/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesGetRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
	filter *string
}

// Query in the RSQL format, allowing to filter Managed Software Updates collection. Default filter is empty query - returning all results for the requested page. Fields allowed in the query: osUpdatesStatusId, device.deviceId, device.objectType, downloaded, downloadPercentComplete, productKey, status, deferralsRemaining, maxDeferrals, nextScheduledInstall, created and updated.
func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesGetRequest) Filter(filter string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesGetRequest {
	r.filter = &filter
	return r
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesGetRequest) Execute() (*ManagedSoftwareUpdateStatuses, *http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesUpdateStatusesGetExecute(r)
}

/*
V1ManagedSoftwareUpdatesUpdateStatusesGet Retrieve Managed Software Update Statuses

Retrieve Managed Software Update Statuses


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesGetRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesUpdateStatusesGet(ctx context.Context) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesGetRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ManagedSoftwareUpdateStatuses
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesUpdateStatusesGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesGetRequest) (*ManagedSoftwareUpdateStatuses, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagedSoftwareUpdateStatuses
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesUpdateStatusesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/update-statuses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	} else {
		var defaultValue string = ""
		r.filter = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGetRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
	id string
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGetRequest) Execute() (*ManagedSoftwareUpdateStatuses, *http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGetExecute(r)
}

/*
V1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGet Retrieve Managed Software Update Statuses for Mobile Device Groups

Retrieve Managed Software Update Statuses for Mobile Device Groups


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Mobile Device Group identifier
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGetRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGet(ctx context.Context, id string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGetRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ManagedSoftwareUpdateStatuses
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGetRequest) (*ManagedSoftwareUpdateStatuses, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagedSoftwareUpdateStatuses
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesUpdateStatusesMobileDeviceGroupsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/update-statuses/mobile-device-groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGetRequest struct {
	ctx context.Context
	ApiService ManagedSoftwareUpdatesAPI
	id string
}

func (r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGetRequest) Execute() (*ManagedSoftwareUpdateStatuses, *http.Response, error) {
	return r.ApiService.V1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGetExecute(r)
}

/*
V1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGet Retrieve Managed Software Update Statuses for Mobile Devices

Retrieve Managed Software Update Statuses for Mobile Devices


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Mobile Device identifier
 @return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGetRequest
*/
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGet(ctx context.Context, id string) ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGetRequest {
	return ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ManagedSoftwareUpdateStatuses
func (a *ManagedSoftwareUpdatesAPIService) V1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGetExecute(r ManagedSoftwareUpdatesAPIV1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGetRequest) (*ManagedSoftwareUpdateStatuses, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagedSoftwareUpdateStatuses
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSoftwareUpdatesAPIService.V1ManagedSoftwareUpdatesUpdateStatusesMobileDevicesIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/managed-software-updates/update-statuses/mobile-devices/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
