/*
Jamf Pro API

## Overview The Jamf Pro API is a RESTful API for Jamf Pro built to enable consistent and efficient programmatic access to Jamf Pro.<br/><br/> The swagger schema can be found [here](/api/schema/). 

API version: production
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
)


type SsoCertificateAPI interface {

	/*
	V2SsoCertDelete Delete the currently configured certificate used by SSO 

	Deletes the currently configured certificate used by SSO.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SsoCertificateAPIV2SsoCertDeleteRequest
	*/
	V2SsoCertDelete(ctx context.Context) SsoCertificateAPIV2SsoCertDeleteRequest

	// V2SsoCertDeleteExecute executes the request
	V2SsoCertDeleteExecute(r SsoCertificateAPIV2SsoCertDeleteRequest) (*http.Response, error)

	/*
	V2SsoCertDownloadGet Download the certificate currently configured for use with Jamf Pro's SSO configuration 

	Downloads the certificate currently configured for use with Jamf Pro's SSO configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SsoCertificateAPIV2SsoCertDownloadGetRequest
	*/
	V2SsoCertDownloadGet(ctx context.Context) SsoCertificateAPIV2SsoCertDownloadGetRequest

	// V2SsoCertDownloadGetExecute executes the request
	//  @return *os.File
	V2SsoCertDownloadGetExecute(r SsoCertificateAPIV2SsoCertDownloadGetRequest) (*os.File, *http.Response, error)

	/*
	V2SsoCertGet Retrieve the certificate currently configured for use with SSO 

	Retrieves the certificate currently configured for use with SSO.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SsoCertificateAPIV2SsoCertGetRequest
	*/
	V2SsoCertGet(ctx context.Context) SsoCertificateAPIV2SsoCertGetRequest

	// V2SsoCertGetExecute executes the request
	//  @return SsoKeystoreResponseWithDetails
	V2SsoCertGetExecute(r SsoCertificateAPIV2SsoCertGetRequest) (*SsoKeystoreResponseWithDetails, *http.Response, error)

	/*
	V2SsoCertParsePost Parse the certificate to get details about certificate type and keys needed to upload certificate file 

	Parse the certificate to get details about certificate type and keys needed to upload certificate file.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SsoCertificateAPIV2SsoCertParsePostRequest
	*/
	V2SsoCertParsePost(ctx context.Context) SsoCertificateAPIV2SsoCertParsePostRequest

	// V2SsoCertParsePostExecute executes the request
	//  @return SsoKeystoreCertParseResponse
	V2SsoCertParsePostExecute(r SsoCertificateAPIV2SsoCertParsePostRequest) (*SsoKeystoreCertParseResponse, *http.Response, error)

	/*
	V2SsoCertPost Jamf Pro will generate a new certificate and use it to sign SSO 

	Jamf Pro will generate a new certificate and use it to sign SSO requests to the identity provider.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SsoCertificateAPIV2SsoCertPostRequest
	*/
	V2SsoCertPost(ctx context.Context) SsoCertificateAPIV2SsoCertPostRequest

	// V2SsoCertPostExecute executes the request
	//  @return SsoKeystoreResponseWithDetails
	V2SsoCertPostExecute(r SsoCertificateAPIV2SsoCertPostRequest) (*SsoKeystoreResponseWithDetails, *http.Response, error)

	/*
	V2SsoCertPut Update the certificate used by Jamf Pro to sign SSO requests to the identify provider 

	Update the certificate used by Jamf Pro to sign SSO requests to the identify provider.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SsoCertificateAPIV2SsoCertPutRequest
	*/
	V2SsoCertPut(ctx context.Context) SsoCertificateAPIV2SsoCertPutRequest

	// V2SsoCertPutExecute executes the request
	//  @return SsoKeystoreResponseWithDetails
	V2SsoCertPutExecute(r SsoCertificateAPIV2SsoCertPutRequest) (*SsoKeystoreResponseWithDetails, *http.Response, error)
}

// SsoCertificateAPIService SsoCertificateAPI service
type SsoCertificateAPIService service

type SsoCertificateAPIV2SsoCertDeleteRequest struct {
	ctx context.Context
	ApiService SsoCertificateAPI
}

func (r SsoCertificateAPIV2SsoCertDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2SsoCertDeleteExecute(r)
}

/*
V2SsoCertDelete Delete the currently configured certificate used by SSO 

Deletes the currently configured certificate used by SSO.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SsoCertificateAPIV2SsoCertDeleteRequest
*/
func (a *SsoCertificateAPIService) V2SsoCertDelete(ctx context.Context) SsoCertificateAPIV2SsoCertDeleteRequest {
	return SsoCertificateAPIV2SsoCertDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SsoCertificateAPIService) V2SsoCertDeleteExecute(r SsoCertificateAPIV2SsoCertDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SsoCertificateAPIService.V2SsoCertDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sso/cert"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SsoCertificateAPIV2SsoCertDownloadGetRequest struct {
	ctx context.Context
	ApiService SsoCertificateAPI
}

func (r SsoCertificateAPIV2SsoCertDownloadGetRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.V2SsoCertDownloadGetExecute(r)
}

/*
V2SsoCertDownloadGet Download the certificate currently configured for use with Jamf Pro's SSO configuration 

Downloads the certificate currently configured for use with Jamf Pro's SSO configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SsoCertificateAPIV2SsoCertDownloadGetRequest
*/
func (a *SsoCertificateAPIService) V2SsoCertDownloadGet(ctx context.Context) SsoCertificateAPIV2SsoCertDownloadGetRequest {
	return SsoCertificateAPIV2SsoCertDownloadGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return *os.File
func (a *SsoCertificateAPIService) V2SsoCertDownloadGetExecute(r SsoCertificateAPIV2SsoCertDownloadGetRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SsoCertificateAPIService.V2SsoCertDownloadGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sso/cert/download"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SsoCertificateAPIV2SsoCertGetRequest struct {
	ctx context.Context
	ApiService SsoCertificateAPI
}

func (r SsoCertificateAPIV2SsoCertGetRequest) Execute() (*SsoKeystoreResponseWithDetails, *http.Response, error) {
	return r.ApiService.V2SsoCertGetExecute(r)
}

/*
V2SsoCertGet Retrieve the certificate currently configured for use with SSO 

Retrieves the certificate currently configured for use with SSO.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SsoCertificateAPIV2SsoCertGetRequest
*/
func (a *SsoCertificateAPIService) V2SsoCertGet(ctx context.Context) SsoCertificateAPIV2SsoCertGetRequest {
	return SsoCertificateAPIV2SsoCertGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SsoKeystoreResponseWithDetails
func (a *SsoCertificateAPIService) V2SsoCertGetExecute(r SsoCertificateAPIV2SsoCertGetRequest) (*SsoKeystoreResponseWithDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SsoKeystoreResponseWithDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SsoCertificateAPIService.V2SsoCertGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sso/cert"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SsoCertificateAPIV2SsoCertParsePostRequest struct {
	ctx context.Context
	ApiService SsoCertificateAPI
	ssoKeystoreParse *SsoKeystoreParse
}

func (r SsoCertificateAPIV2SsoCertParsePostRequest) SsoKeystoreParse(ssoKeystoreParse SsoKeystoreParse) SsoCertificateAPIV2SsoCertParsePostRequest {
	r.ssoKeystoreParse = &ssoKeystoreParse
	return r
}

func (r SsoCertificateAPIV2SsoCertParsePostRequest) Execute() (*SsoKeystoreCertParseResponse, *http.Response, error) {
	return r.ApiService.V2SsoCertParsePostExecute(r)
}

/*
V2SsoCertParsePost Parse the certificate to get details about certificate type and keys needed to upload certificate file 

Parse the certificate to get details about certificate type and keys needed to upload certificate file.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SsoCertificateAPIV2SsoCertParsePostRequest
*/
func (a *SsoCertificateAPIService) V2SsoCertParsePost(ctx context.Context) SsoCertificateAPIV2SsoCertParsePostRequest {
	return SsoCertificateAPIV2SsoCertParsePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SsoKeystoreCertParseResponse
func (a *SsoCertificateAPIService) V2SsoCertParsePostExecute(r SsoCertificateAPIV2SsoCertParsePostRequest) (*SsoKeystoreCertParseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SsoKeystoreCertParseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SsoCertificateAPIService.V2SsoCertParsePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sso/cert/parse"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ssoKeystoreParse == nil {
		return localVarReturnValue, nil, reportError("ssoKeystoreParse is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ssoKeystoreParse
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SsoCertificateAPIV2SsoCertPostRequest struct {
	ctx context.Context
	ApiService SsoCertificateAPI
}

func (r SsoCertificateAPIV2SsoCertPostRequest) Execute() (*SsoKeystoreResponseWithDetails, *http.Response, error) {
	return r.ApiService.V2SsoCertPostExecute(r)
}

/*
V2SsoCertPost Jamf Pro will generate a new certificate and use it to sign SSO 

Jamf Pro will generate a new certificate and use it to sign SSO requests to the identity provider.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SsoCertificateAPIV2SsoCertPostRequest
*/
func (a *SsoCertificateAPIService) V2SsoCertPost(ctx context.Context) SsoCertificateAPIV2SsoCertPostRequest {
	return SsoCertificateAPIV2SsoCertPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SsoKeystoreResponseWithDetails
func (a *SsoCertificateAPIService) V2SsoCertPostExecute(r SsoCertificateAPIV2SsoCertPostRequest) (*SsoKeystoreResponseWithDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SsoKeystoreResponseWithDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SsoCertificateAPIService.V2SsoCertPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sso/cert"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SsoCertificateAPIV2SsoCertPutRequest struct {
	ctx context.Context
	ApiService SsoCertificateAPI
	ssoKeystore *SsoKeystore
}

func (r SsoCertificateAPIV2SsoCertPutRequest) SsoKeystore(ssoKeystore SsoKeystore) SsoCertificateAPIV2SsoCertPutRequest {
	r.ssoKeystore = &ssoKeystore
	return r
}

func (r SsoCertificateAPIV2SsoCertPutRequest) Execute() (*SsoKeystoreResponseWithDetails, *http.Response, error) {
	return r.ApiService.V2SsoCertPutExecute(r)
}

/*
V2SsoCertPut Update the certificate used by Jamf Pro to sign SSO requests to the identify provider 

Update the certificate used by Jamf Pro to sign SSO requests to the identify provider.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SsoCertificateAPIV2SsoCertPutRequest
*/
func (a *SsoCertificateAPIService) V2SsoCertPut(ctx context.Context) SsoCertificateAPIV2SsoCertPutRequest {
	return SsoCertificateAPIV2SsoCertPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SsoKeystoreResponseWithDetails
func (a *SsoCertificateAPIService) V2SsoCertPutExecute(r SsoCertificateAPIV2SsoCertPutRequest) (*SsoKeystoreResponseWithDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SsoKeystoreResponseWithDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SsoCertificateAPIService.V2SsoCertPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sso/cert"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ssoKeystore == nil {
		return localVarReturnValue, nil, reportError("ssoKeystore is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ssoKeystore
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
