/*
Jamf Pro API

## Overview The Jamf Pro API is a RESTful API for Jamf Pro built to enable consistent and efficient programmatic access to Jamf Pro.<br/><br/> The swagger schema can be found [here](/api/schema/). 

API version: production
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


type JamfProtectAPI interface {

	/*
	V1JamfProtectDelete Delete Jamf Protect API registration.

	Deletes an existing Jamf Protect API registration if present. Jamf Protect API integration will be disabled.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return JamfProtectAPIV1JamfProtectDeleteRequest
	*/
	V1JamfProtectDelete(ctx context.Context) JamfProtectAPIV1JamfProtectDeleteRequest

	// V1JamfProtectDeleteExecute executes the request
	V1JamfProtectDeleteExecute(r JamfProtectAPIV1JamfProtectDeleteRequest) (*http.Response, error)

	/*
	V1JamfProtectDeploymentsIdTasksGet Search for deployment tasks for a config profile linked to Jamf Protect 

	Search for config profiles linked to Jamf Protect

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the UUID of the Jamf Protect deployment
	@return JamfProtectAPIV1JamfProtectDeploymentsIdTasksGetRequest
	*/
	V1JamfProtectDeploymentsIdTasksGet(ctx context.Context, id string) JamfProtectAPIV1JamfProtectDeploymentsIdTasksGetRequest

	// V1JamfProtectDeploymentsIdTasksGetExecute executes the request
	//  @return DeploymentTaskSearchResults
	V1JamfProtectDeploymentsIdTasksGetExecute(r JamfProtectAPIV1JamfProtectDeploymentsIdTasksGetRequest) (*DeploymentTaskSearchResults, *http.Response, error)

	/*
	V1JamfProtectDeploymentsIdTasksRetryPost Request a retry of Protect install tasks 

	Request a retry of Protect install tasks


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the UUID of the deployment associated with the retry
	@return JamfProtectAPIV1JamfProtectDeploymentsIdTasksRetryPostRequest
	*/
	V1JamfProtectDeploymentsIdTasksRetryPost(ctx context.Context, id string) JamfProtectAPIV1JamfProtectDeploymentsIdTasksRetryPostRequest

	// V1JamfProtectDeploymentsIdTasksRetryPostExecute executes the request
	V1JamfProtectDeploymentsIdTasksRetryPostExecute(r JamfProtectAPIV1JamfProtectDeploymentsIdTasksRetryPostRequest) (*http.Response, error)

	/*
	V1JamfProtectGet Jamf Protect integration settings

	Jamf Protect integration settings

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return JamfProtectAPIV1JamfProtectGetRequest
	*/
	V1JamfProtectGet(ctx context.Context) JamfProtectAPIV1JamfProtectGetRequest

	// V1JamfProtectGetExecute executes the request
	//  @return ProtectSettingsResponse
	V1JamfProtectGetExecute(r JamfProtectAPIV1JamfProtectGetRequest) (*ProtectSettingsResponse, *http.Response, error)

	/*
	V1JamfProtectHistoryGet Get Jamf Protect history 

	Get Jamf Protect history


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return JamfProtectAPIV1JamfProtectHistoryGetRequest
	*/
	V1JamfProtectHistoryGet(ctx context.Context) JamfProtectAPIV1JamfProtectHistoryGetRequest

	// V1JamfProtectHistoryGetExecute executes the request
	//  @return HistorySearchResults
	V1JamfProtectHistoryGetExecute(r JamfProtectAPIV1JamfProtectHistoryGetRequest) (*HistorySearchResults, *http.Response, error)

	/*
	V1JamfProtectHistoryPost Add Jamf Protect history notes 

	Add Jamf Protect history notes


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return JamfProtectAPIV1JamfProtectHistoryPostRequest
	*/
	V1JamfProtectHistoryPost(ctx context.Context) JamfProtectAPIV1JamfProtectHistoryPostRequest

	// V1JamfProtectHistoryPostExecute executes the request
	//  @return HrefResponse
	V1JamfProtectHistoryPostExecute(r JamfProtectAPIV1JamfProtectHistoryPostRequest) (*HrefResponse, *http.Response, error)

	/*
	V1JamfProtectPlansGet Get all of the previously synced Jamf Protect Plans with information about their associated configuration profile

	Get all of the previously synced Jamf Protect Plans with information about their associated configuration profile

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return JamfProtectAPIV1JamfProtectPlansGetRequest
	*/
	V1JamfProtectPlansGet(ctx context.Context) JamfProtectAPIV1JamfProtectPlansGetRequest

	// V1JamfProtectPlansGetExecute executes the request
	//  @return PlanSearchResults
	V1JamfProtectPlansGetExecute(r JamfProtectAPIV1JamfProtectPlansGetRequest) (*PlanSearchResults, *http.Response, error)

	/*
	V1JamfProtectPlansSyncPost Sync Plans with Jamf Protect

	Sync Plans with Jamf Protect. Configuration profiles associated with new plans will be imported to Jamf Pro.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return JamfProtectAPIV1JamfProtectPlansSyncPostRequest
	*/
	V1JamfProtectPlansSyncPost(ctx context.Context) JamfProtectAPIV1JamfProtectPlansSyncPostRequest

	// V1JamfProtectPlansSyncPostExecute executes the request
	V1JamfProtectPlansSyncPostExecute(r JamfProtectAPIV1JamfProtectPlansSyncPostRequest) (*http.Response, error)

	/*
	V1JamfProtectPut Jamf Protect integration settings

	Jamf Protect integration settings

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return JamfProtectAPIV1JamfProtectPutRequest
	*/
	V1JamfProtectPut(ctx context.Context) JamfProtectAPIV1JamfProtectPutRequest

	// V1JamfProtectPutExecute executes the request
	//  @return ProtectSettingsResponse
	V1JamfProtectPutExecute(r JamfProtectAPIV1JamfProtectPutRequest) (*ProtectSettingsResponse, *http.Response, error)

	/*
	V1JamfProtectRegisterPost Register a Jamf Protect API configuration with Jamf Pro

	Register a Jamf Protect API configuration with Jamf Pro

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return JamfProtectAPIV1JamfProtectRegisterPostRequest
	*/
	V1JamfProtectRegisterPost(ctx context.Context) JamfProtectAPIV1JamfProtectRegisterPostRequest

	// V1JamfProtectRegisterPostExecute executes the request
	//  @return ProtectSettingsResponse
	V1JamfProtectRegisterPostExecute(r JamfProtectAPIV1JamfProtectRegisterPostRequest) (*ProtectSettingsResponse, *http.Response, error)
}

// JamfProtectAPIService JamfProtectAPI service
type JamfProtectAPIService service

type JamfProtectAPIV1JamfProtectDeleteRequest struct {
	ctx context.Context
	ApiService JamfProtectAPI
}

func (r JamfProtectAPIV1JamfProtectDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1JamfProtectDeleteExecute(r)
}

/*
V1JamfProtectDelete Delete Jamf Protect API registration.

Deletes an existing Jamf Protect API registration if present. Jamf Protect API integration will be disabled.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return JamfProtectAPIV1JamfProtectDeleteRequest
*/
func (a *JamfProtectAPIService) V1JamfProtectDelete(ctx context.Context) JamfProtectAPIV1JamfProtectDeleteRequest {
	return JamfProtectAPIV1JamfProtectDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *JamfProtectAPIService) V1JamfProtectDeleteExecute(r JamfProtectAPIV1JamfProtectDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JamfProtectAPIService.V1JamfProtectDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/jamf-protect"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type JamfProtectAPIV1JamfProtectDeploymentsIdTasksGetRequest struct {
	ctx context.Context
	ApiService JamfProtectAPI
	id string
	page *int32
	pageSize *int32
	sort *[]string
	filter *string
}

func (r JamfProtectAPIV1JamfProtectDeploymentsIdTasksGetRequest) Page(page int32) JamfProtectAPIV1JamfProtectDeploymentsIdTasksGetRequest {
	r.page = &page
	return r
}

func (r JamfProtectAPIV1JamfProtectDeploymentsIdTasksGetRequest) PageSize(pageSize int32) JamfProtectAPIV1JamfProtectDeploymentsIdTasksGetRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property:asc/desc. Default sort order is descending. Multiple sort criteria are supported and must be entered on separate lines in Swagger UI. In the URI the &#39;sort&#39; query param is not duplicated for each sort criterion, e.g., ...&amp;sort&#x3D;name:asc,date:desc. Fields that can be sorted: status, updated
func (r JamfProtectAPIV1JamfProtectDeploymentsIdTasksGetRequest) Sort(sort []string) JamfProtectAPIV1JamfProtectDeploymentsIdTasksGetRequest {
	r.sort = &sort
	return r
}

// Query in the RSQL format, allowing to filter results. Default filter is empty query - returning all results for the requested page. Fields allowed in the query: status, updated, version This param can be combined with paging and sorting. Example: filter&#x3D;username!&#x3D;admin and details&#x3D;&#x3D;*disabled* and date&lt;2019-12-15
func (r JamfProtectAPIV1JamfProtectDeploymentsIdTasksGetRequest) Filter(filter string) JamfProtectAPIV1JamfProtectDeploymentsIdTasksGetRequest {
	r.filter = &filter
	return r
}

func (r JamfProtectAPIV1JamfProtectDeploymentsIdTasksGetRequest) Execute() (*DeploymentTaskSearchResults, *http.Response, error) {
	return r.ApiService.V1JamfProtectDeploymentsIdTasksGetExecute(r)
}

/*
V1JamfProtectDeploymentsIdTasksGet Search for deployment tasks for a config profile linked to Jamf Protect 

Search for config profiles linked to Jamf Protect

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the UUID of the Jamf Protect deployment
 @return JamfProtectAPIV1JamfProtectDeploymentsIdTasksGetRequest
*/
func (a *JamfProtectAPIService) V1JamfProtectDeploymentsIdTasksGet(ctx context.Context, id string) JamfProtectAPIV1JamfProtectDeploymentsIdTasksGetRequest {
	return JamfProtectAPIV1JamfProtectDeploymentsIdTasksGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeploymentTaskSearchResults
func (a *JamfProtectAPIService) V1JamfProtectDeploymentsIdTasksGetExecute(r JamfProtectAPIV1JamfProtectDeploymentsIdTasksGetRequest) (*DeploymentTaskSearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeploymentTaskSearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JamfProtectAPIService.V1JamfProtectDeploymentsIdTasksGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/jamf-protect/deployments/{id}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 0
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page-size", r.pageSize, "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	} else {
		var defaultValue []string = []
		r.sort = &defaultValue
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	} else {
		var defaultValue string = ""
		r.filter = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type JamfProtectAPIV1JamfProtectDeploymentsIdTasksRetryPostRequest struct {
	ctx context.Context
	ApiService JamfProtectAPI
	id string
	ids *Ids
}

// task IDs to retry
func (r JamfProtectAPIV1JamfProtectDeploymentsIdTasksRetryPostRequest) Ids(ids Ids) JamfProtectAPIV1JamfProtectDeploymentsIdTasksRetryPostRequest {
	r.ids = &ids
	return r
}

func (r JamfProtectAPIV1JamfProtectDeploymentsIdTasksRetryPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1JamfProtectDeploymentsIdTasksRetryPostExecute(r)
}

/*
V1JamfProtectDeploymentsIdTasksRetryPost Request a retry of Protect install tasks 

Request a retry of Protect install tasks


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the UUID of the deployment associated with the retry
 @return JamfProtectAPIV1JamfProtectDeploymentsIdTasksRetryPostRequest
*/
func (a *JamfProtectAPIService) V1JamfProtectDeploymentsIdTasksRetryPost(ctx context.Context, id string) JamfProtectAPIV1JamfProtectDeploymentsIdTasksRetryPostRequest {
	return JamfProtectAPIV1JamfProtectDeploymentsIdTasksRetryPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *JamfProtectAPIService) V1JamfProtectDeploymentsIdTasksRetryPostExecute(r JamfProtectAPIV1JamfProtectDeploymentsIdTasksRetryPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JamfProtectAPIService.V1JamfProtectDeploymentsIdTasksRetryPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/jamf-protect/deployments/{id}/tasks/retry"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return nil, reportError("ids is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ids
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type JamfProtectAPIV1JamfProtectGetRequest struct {
	ctx context.Context
	ApiService JamfProtectAPI
}

func (r JamfProtectAPIV1JamfProtectGetRequest) Execute() (*ProtectSettingsResponse, *http.Response, error) {
	return r.ApiService.V1JamfProtectGetExecute(r)
}

/*
V1JamfProtectGet Jamf Protect integration settings

Jamf Protect integration settings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return JamfProtectAPIV1JamfProtectGetRequest
*/
func (a *JamfProtectAPIService) V1JamfProtectGet(ctx context.Context) JamfProtectAPIV1JamfProtectGetRequest {
	return JamfProtectAPIV1JamfProtectGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProtectSettingsResponse
func (a *JamfProtectAPIService) V1JamfProtectGetExecute(r JamfProtectAPIV1JamfProtectGetRequest) (*ProtectSettingsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProtectSettingsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JamfProtectAPIService.V1JamfProtectGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/jamf-protect"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type JamfProtectAPIV1JamfProtectHistoryGetRequest struct {
	ctx context.Context
	ApiService JamfProtectAPI
	page *int32
	pageSize *int32
	sort *[]string
	filter *string
}

func (r JamfProtectAPIV1JamfProtectHistoryGetRequest) Page(page int32) JamfProtectAPIV1JamfProtectHistoryGetRequest {
	r.page = &page
	return r
}

func (r JamfProtectAPIV1JamfProtectHistoryGetRequest) PageSize(pageSize int32) JamfProtectAPIV1JamfProtectHistoryGetRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property:asc/desc. Default sort order is descending. Multiple sort criteria are supported and must be entered on separate lines in Swagger UI. In the URI the &#39;sort&#39; query param is not duplicated for each sort criterion, e.g., ...&amp;sort&#x3D;name:asc,date:desc. Fields that can be sorted: status, updated
func (r JamfProtectAPIV1JamfProtectHistoryGetRequest) Sort(sort []string) JamfProtectAPIV1JamfProtectHistoryGetRequest {
	r.sort = &sort
	return r
}

// Query in the RSQL format, allowing to filter results. Default filter is empty query - returning all results for the requested page. Fields allowed in the query: status, updated, version This param can be combined with paging and sorting. Example: filter&#x3D;username!&#x3D;admin and details&#x3D;&#x3D;*disabled* and date&lt;2019-12-15
func (r JamfProtectAPIV1JamfProtectHistoryGetRequest) Filter(filter string) JamfProtectAPIV1JamfProtectHistoryGetRequest {
	r.filter = &filter
	return r
}

func (r JamfProtectAPIV1JamfProtectHistoryGetRequest) Execute() (*HistorySearchResults, *http.Response, error) {
	return r.ApiService.V1JamfProtectHistoryGetExecute(r)
}

/*
V1JamfProtectHistoryGet Get Jamf Protect history 

Get Jamf Protect history


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return JamfProtectAPIV1JamfProtectHistoryGetRequest
*/
func (a *JamfProtectAPIService) V1JamfProtectHistoryGet(ctx context.Context) JamfProtectAPIV1JamfProtectHistoryGetRequest {
	return JamfProtectAPIV1JamfProtectHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HistorySearchResults
func (a *JamfProtectAPIService) V1JamfProtectHistoryGetExecute(r JamfProtectAPIV1JamfProtectHistoryGetRequest) (*HistorySearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistorySearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JamfProtectAPIService.V1JamfProtectHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/jamf-protect/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 0
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page-size", r.pageSize, "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	} else {
		var defaultValue []string = []
		r.sort = &defaultValue
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	} else {
		var defaultValue string = ""
		r.filter = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type JamfProtectAPIV1JamfProtectHistoryPostRequest struct {
	ctx context.Context
	ApiService JamfProtectAPI
	objectHistoryNote *ObjectHistoryNote
}

// history notes to create
func (r JamfProtectAPIV1JamfProtectHistoryPostRequest) ObjectHistoryNote(objectHistoryNote ObjectHistoryNote) JamfProtectAPIV1JamfProtectHistoryPostRequest {
	r.objectHistoryNote = &objectHistoryNote
	return r
}

func (r JamfProtectAPIV1JamfProtectHistoryPostRequest) Execute() (*HrefResponse, *http.Response, error) {
	return r.ApiService.V1JamfProtectHistoryPostExecute(r)
}

/*
V1JamfProtectHistoryPost Add Jamf Protect history notes 

Add Jamf Protect history notes


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return JamfProtectAPIV1JamfProtectHistoryPostRequest
*/
func (a *JamfProtectAPIService) V1JamfProtectHistoryPost(ctx context.Context) JamfProtectAPIV1JamfProtectHistoryPostRequest {
	return JamfProtectAPIV1JamfProtectHistoryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HrefResponse
func (a *JamfProtectAPIService) V1JamfProtectHistoryPostExecute(r JamfProtectAPIV1JamfProtectHistoryPostRequest) (*HrefResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HrefResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JamfProtectAPIService.V1JamfProtectHistoryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/jamf-protect/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.objectHistoryNote == nil {
		return localVarReturnValue, nil, reportError("objectHistoryNote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.objectHistoryNote
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type JamfProtectAPIV1JamfProtectPlansGetRequest struct {
	ctx context.Context
	ApiService JamfProtectAPI
	page *int32
	pageSize *int32
	sort *[]string
	filter *string
}

func (r JamfProtectAPIV1JamfProtectPlansGetRequest) Page(page int32) JamfProtectAPIV1JamfProtectPlansGetRequest {
	r.page = &page
	return r
}

func (r JamfProtectAPIV1JamfProtectPlansGetRequest) PageSize(pageSize int32) JamfProtectAPIV1JamfProtectPlansGetRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property:asc/desc. Default sort order is descending. Multiple sort criteria are supported and must be entered on separate lines in Swagger UI. In the URI the &#39;sort&#39; query param is not duplicated for each sort criterion, e.g., ...&amp;sort&#x3D;name:asc,date:desc. Fields that can be sorted: status, updated
func (r JamfProtectAPIV1JamfProtectPlansGetRequest) Sort(sort []string) JamfProtectAPIV1JamfProtectPlansGetRequest {
	r.sort = &sort
	return r
}

// Query in the RSQL format, allowing to filter results. Default filter is empty query - returning all results for the requested page. Fields allowed in the query: status, updated, version This param can be combined with paging and sorting. Example: filter&#x3D;username!&#x3D;admin and details&#x3D;&#x3D;*disabled* and date&lt;2019-12-15
func (r JamfProtectAPIV1JamfProtectPlansGetRequest) Filter(filter string) JamfProtectAPIV1JamfProtectPlansGetRequest {
	r.filter = &filter
	return r
}

func (r JamfProtectAPIV1JamfProtectPlansGetRequest) Execute() (*PlanSearchResults, *http.Response, error) {
	return r.ApiService.V1JamfProtectPlansGetExecute(r)
}

/*
V1JamfProtectPlansGet Get all of the previously synced Jamf Protect Plans with information about their associated configuration profile

Get all of the previously synced Jamf Protect Plans with information about their associated configuration profile

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return JamfProtectAPIV1JamfProtectPlansGetRequest
*/
func (a *JamfProtectAPIService) V1JamfProtectPlansGet(ctx context.Context) JamfProtectAPIV1JamfProtectPlansGetRequest {
	return JamfProtectAPIV1JamfProtectPlansGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PlanSearchResults
func (a *JamfProtectAPIService) V1JamfProtectPlansGetExecute(r JamfProtectAPIV1JamfProtectPlansGetRequest) (*PlanSearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PlanSearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JamfProtectAPIService.V1JamfProtectPlansGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/jamf-protect/plans"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 0
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page-size", r.pageSize, "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	} else {
		var defaultValue []string = []
		r.sort = &defaultValue
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	} else {
		var defaultValue string = ""
		r.filter = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type JamfProtectAPIV1JamfProtectPlansSyncPostRequest struct {
	ctx context.Context
	ApiService JamfProtectAPI
}

func (r JamfProtectAPIV1JamfProtectPlansSyncPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1JamfProtectPlansSyncPostExecute(r)
}

/*
V1JamfProtectPlansSyncPost Sync Plans with Jamf Protect

Sync Plans with Jamf Protect. Configuration profiles associated with new plans will be imported to Jamf Pro.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return JamfProtectAPIV1JamfProtectPlansSyncPostRequest
*/
func (a *JamfProtectAPIService) V1JamfProtectPlansSyncPost(ctx context.Context) JamfProtectAPIV1JamfProtectPlansSyncPostRequest {
	return JamfProtectAPIV1JamfProtectPlansSyncPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *JamfProtectAPIService) V1JamfProtectPlansSyncPostExecute(r JamfProtectAPIV1JamfProtectPlansSyncPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JamfProtectAPIService.V1JamfProtectPlansSyncPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/jamf-protect/plans/sync"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type JamfProtectAPIV1JamfProtectPutRequest struct {
	ctx context.Context
	ApiService JamfProtectAPI
	protectUpdatableSettingsRequest *ProtectUpdatableSettingsRequest
}

// Updatable Jamf Protect Settings
func (r JamfProtectAPIV1JamfProtectPutRequest) ProtectUpdatableSettingsRequest(protectUpdatableSettingsRequest ProtectUpdatableSettingsRequest) JamfProtectAPIV1JamfProtectPutRequest {
	r.protectUpdatableSettingsRequest = &protectUpdatableSettingsRequest
	return r
}

func (r JamfProtectAPIV1JamfProtectPutRequest) Execute() (*ProtectSettingsResponse, *http.Response, error) {
	return r.ApiService.V1JamfProtectPutExecute(r)
}

/*
V1JamfProtectPut Jamf Protect integration settings

Jamf Protect integration settings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return JamfProtectAPIV1JamfProtectPutRequest
*/
func (a *JamfProtectAPIService) V1JamfProtectPut(ctx context.Context) JamfProtectAPIV1JamfProtectPutRequest {
	return JamfProtectAPIV1JamfProtectPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProtectSettingsResponse
func (a *JamfProtectAPIService) V1JamfProtectPutExecute(r JamfProtectAPIV1JamfProtectPutRequest) (*ProtectSettingsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProtectSettingsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JamfProtectAPIService.V1JamfProtectPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/jamf-protect"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.protectUpdatableSettingsRequest == nil {
		return localVarReturnValue, nil, reportError("protectUpdatableSettingsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.protectUpdatableSettingsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type JamfProtectAPIV1JamfProtectRegisterPostRequest struct {
	ctx context.Context
	ApiService JamfProtectAPI
	protectRegistrationRequest *ProtectRegistrationRequest
}

// Jamf Protect API connection information
func (r JamfProtectAPIV1JamfProtectRegisterPostRequest) ProtectRegistrationRequest(protectRegistrationRequest ProtectRegistrationRequest) JamfProtectAPIV1JamfProtectRegisterPostRequest {
	r.protectRegistrationRequest = &protectRegistrationRequest
	return r
}

func (r JamfProtectAPIV1JamfProtectRegisterPostRequest) Execute() (*ProtectSettingsResponse, *http.Response, error) {
	return r.ApiService.V1JamfProtectRegisterPostExecute(r)
}

/*
V1JamfProtectRegisterPost Register a Jamf Protect API configuration with Jamf Pro

Register a Jamf Protect API configuration with Jamf Pro

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return JamfProtectAPIV1JamfProtectRegisterPostRequest
*/
func (a *JamfProtectAPIService) V1JamfProtectRegisterPost(ctx context.Context) JamfProtectAPIV1JamfProtectRegisterPostRequest {
	return JamfProtectAPIV1JamfProtectRegisterPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProtectSettingsResponse
func (a *JamfProtectAPIService) V1JamfProtectRegisterPostExecute(r JamfProtectAPIV1JamfProtectRegisterPostRequest) (*ProtectSettingsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProtectSettingsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JamfProtectAPIService.V1JamfProtectRegisterPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/jamf-protect/register"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.protectRegistrationRequest == nil {
		return localVarReturnValue, nil, reportError("protectRegistrationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.protectRegistrationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
