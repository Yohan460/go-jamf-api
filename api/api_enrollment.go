/*
Jamf Pro API

## Overview The Jamf Pro API is a RESTful API for Jamf Pro built to enable consistent and efficient programmatic access to Jamf Pro.<br/><br/> The swagger schema can be found [here](/api/schema/). 

API version: production
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// EnrollmentApiService EnrollmentApi service
type EnrollmentApiService service

type ApiPreviewEnrollmentAccessGroupsGetRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	page *int32
	pageSize *int32
	sort *[]string
	allUsersOptionFirst *bool
}

func (r ApiPreviewEnrollmentAccessGroupsGetRequest) Page(page int32) ApiPreviewEnrollmentAccessGroupsGetRequest {
	r.page = &page
	return r
}

func (r ApiPreviewEnrollmentAccessGroupsGetRequest) PageSize(pageSize int32) ApiPreviewEnrollmentAccessGroupsGetRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: &#x60;property:asc/desc&#x60;. Default sort is &#x60;name:asc&#x60;. Multiple sort criteria are supported and must be separated with a comma. Example: &#x60;sort&#x3D;date:desc,name:asc&#x60;. 
func (r ApiPreviewEnrollmentAccessGroupsGetRequest) Sort(sort []string) ApiPreviewEnrollmentAccessGroupsGetRequest {
	r.sort = &sort
	return r
}

// Return \&quot;All LDAP Users\&quot; option on the first position if it is present in the current page
func (r ApiPreviewEnrollmentAccessGroupsGetRequest) AllUsersOptionFirst(allUsersOptionFirst bool) ApiPreviewEnrollmentAccessGroupsGetRequest {
	r.allUsersOptionFirst = &allUsersOptionFirst
	return r
}

func (r ApiPreviewEnrollmentAccessGroupsGetRequest) Execute() (*AccessGroupsPreviewSearchResults, *http.Response, error) {
	return r.ApiService.PreviewEnrollmentAccessGroupsGetExecute(r)
}

/*
PreviewEnrollmentAccessGroupsGet Retrieve the configured LDAP groups configured for User-Initiated Enrollment. 

Retrieves the configured LDAP groups configured for User-Initiated Enrollment.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPreviewEnrollmentAccessGroupsGetRequest
*/
func (a *EnrollmentApiService) PreviewEnrollmentAccessGroupsGet(ctx context.Context) ApiPreviewEnrollmentAccessGroupsGetRequest {
	return ApiPreviewEnrollmentAccessGroupsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccessGroupsPreviewSearchResults
func (a *EnrollmentApiService) PreviewEnrollmentAccessGroupsGetExecute(r ApiPreviewEnrollmentAccessGroupsGetRequest) (*AccessGroupsPreviewSearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccessGroupsPreviewSearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.PreviewEnrollmentAccessGroupsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/preview/enrollment/access-groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page-size", parameterToString(*r.pageSize, ""))
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sort", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sort", parameterToString(t, "multi"))
		}
	}
	if r.allUsersOptionFirst != nil {
		localVarQueryParams.Add("all-users-option-first", parameterToString(*r.allUsersOptionFirst, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPreviewEnrollmentAccessGroupsIdDeleteRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	id string
}

func (r ApiPreviewEnrollmentAccessGroupsIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.PreviewEnrollmentAccessGroupsIdDeleteExecute(r)
}

/*
PreviewEnrollmentAccessGroupsIdDelete Delete an LDAP group's access to user initiated Enrollment. 

Deletes an LDAP group's access to user initiated enrollment. The group "All LDAP Users" cannot be deleted, but it can be modified to disallow User-Initiated Enrollment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Autogenerated Access Group ID.
 @return ApiPreviewEnrollmentAccessGroupsIdDeleteRequest
*/
func (a *EnrollmentApiService) PreviewEnrollmentAccessGroupsIdDelete(ctx context.Context, id string) ApiPreviewEnrollmentAccessGroupsIdDeleteRequest {
	return ApiPreviewEnrollmentAccessGroupsIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *EnrollmentApiService) PreviewEnrollmentAccessGroupsIdDeleteExecute(r ApiPreviewEnrollmentAccessGroupsIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.PreviewEnrollmentAccessGroupsIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/preview/enrollment/access-groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPreviewEnrollmentAccessGroupsIdGetRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	id string
}

func (r ApiPreviewEnrollmentAccessGroupsIdGetRequest) Execute() (*EnrollmentAccessGroupPreview, *http.Response, error) {
	return r.ApiService.PreviewEnrollmentAccessGroupsIdGetExecute(r)
}

/*
PreviewEnrollmentAccessGroupsIdGet Retrieve the configured LDAP groups configured for User-Initiated Enrollment 

Retrieves the configured LDAP groups configured for User-Initiated Enrollment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Autogenerated Access Group ID.
 @return ApiPreviewEnrollmentAccessGroupsIdGetRequest
*/
func (a *EnrollmentApiService) PreviewEnrollmentAccessGroupsIdGet(ctx context.Context, id string) ApiPreviewEnrollmentAccessGroupsIdGetRequest {
	return ApiPreviewEnrollmentAccessGroupsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return EnrollmentAccessGroupPreview
func (a *EnrollmentApiService) PreviewEnrollmentAccessGroupsIdGetExecute(r ApiPreviewEnrollmentAccessGroupsIdGetRequest) (*EnrollmentAccessGroupPreview, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnrollmentAccessGroupPreview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.PreviewEnrollmentAccessGroupsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/preview/enrollment/access-groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPreviewEnrollmentAccessGroupsIdPutRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	id string
	enrollmentAccessGroupPreview *EnrollmentAccessGroupPreview
}

func (r ApiPreviewEnrollmentAccessGroupsIdPutRequest) EnrollmentAccessGroupPreview(enrollmentAccessGroupPreview EnrollmentAccessGroupPreview) ApiPreviewEnrollmentAccessGroupsIdPutRequest {
	r.enrollmentAccessGroupPreview = &enrollmentAccessGroupPreview
	return r
}

func (r ApiPreviewEnrollmentAccessGroupsIdPutRequest) Execute() (*EnrollmentAccessGroupPreview, *http.Response, error) {
	return r.ApiService.PreviewEnrollmentAccessGroupsIdPutExecute(r)
}

/*
PreviewEnrollmentAccessGroupsIdPut Modify the configured LDAP groups configured for User-Initiated Enrollment. Only exiting Access Groups can be updated. 

Modify the configured LDAP groups configured for User-Initiated Enrollment. Only exiting Access Groups can be updated.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Autogenerated Access Group ID.
 @return ApiPreviewEnrollmentAccessGroupsIdPutRequest
*/
func (a *EnrollmentApiService) PreviewEnrollmentAccessGroupsIdPut(ctx context.Context, id string) ApiPreviewEnrollmentAccessGroupsIdPutRequest {
	return ApiPreviewEnrollmentAccessGroupsIdPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return EnrollmentAccessGroupPreview
func (a *EnrollmentApiService) PreviewEnrollmentAccessGroupsIdPutExecute(r ApiPreviewEnrollmentAccessGroupsIdPutRequest) (*EnrollmentAccessGroupPreview, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnrollmentAccessGroupPreview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.PreviewEnrollmentAccessGroupsIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/preview/enrollment/access-groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.enrollmentAccessGroupPreview == nil {
		return localVarReturnValue, nil, reportError("enrollmentAccessGroupPreview is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.enrollmentAccessGroupPreview
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPreviewEnrollmentAccessGroupsPostRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	enrollmentAccessGroupPreview *EnrollmentAccessGroupPreview
}

// Configured LDAP group to create.
func (r ApiPreviewEnrollmentAccessGroupsPostRequest) EnrollmentAccessGroupPreview(enrollmentAccessGroupPreview EnrollmentAccessGroupPreview) ApiPreviewEnrollmentAccessGroupsPostRequest {
	r.enrollmentAccessGroupPreview = &enrollmentAccessGroupPreview
	return r
}

func (r ApiPreviewEnrollmentAccessGroupsPostRequest) Execute() (*HrefResponse, *http.Response, error) {
	return r.ApiService.PreviewEnrollmentAccessGroupsPostExecute(r)
}

/*
PreviewEnrollmentAccessGroupsPost Add the configured LDAP group for User-Initiated Enrollment. 

Add the configured LDAP group for User-Initiated Enrollment.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPreviewEnrollmentAccessGroupsPostRequest
*/
func (a *EnrollmentApiService) PreviewEnrollmentAccessGroupsPost(ctx context.Context) ApiPreviewEnrollmentAccessGroupsPostRequest {
	return ApiPreviewEnrollmentAccessGroupsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HrefResponse
func (a *EnrollmentApiService) PreviewEnrollmentAccessGroupsPostExecute(r ApiPreviewEnrollmentAccessGroupsPostRequest) (*HrefResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HrefResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.PreviewEnrollmentAccessGroupsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/preview/enrollment/access-groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.enrollmentAccessGroupPreview == nil {
		return localVarReturnValue, nil, reportError("enrollmentAccessGroupPreview is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.enrollmentAccessGroupPreview
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnrollmentAccessGroupsGetRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	page *int32
	size *int32
	pagesize *int32
	pageSize *int32
	sort *string
}

func (r ApiV1EnrollmentAccessGroupsGetRequest) Page(page int32) ApiV1EnrollmentAccessGroupsGetRequest {
	r.page = &page
	return r
}

// Deprecated
func (r ApiV1EnrollmentAccessGroupsGetRequest) Size(size int32) ApiV1EnrollmentAccessGroupsGetRequest {
	r.size = &size
	return r
}

// Deprecated
func (r ApiV1EnrollmentAccessGroupsGetRequest) Pagesize(pagesize int32) ApiV1EnrollmentAccessGroupsGetRequest {
	r.pagesize = &pagesize
	return r
}

func (r ApiV1EnrollmentAccessGroupsGetRequest) PageSize(pageSize int32) ApiV1EnrollmentAccessGroupsGetRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property:asc/desc. Default sort is name:asc. Multiple sort criteria are supported and must be separated with a comma. Example: sort&#x3D;date:desc,name:asc 
func (r ApiV1EnrollmentAccessGroupsGetRequest) Sort(sort string) ApiV1EnrollmentAccessGroupsGetRequest {
	r.sort = &sort
	return r
}

func (r ApiV1EnrollmentAccessGroupsGetRequest) Execute() (*AccessGroupsSearchResults, *http.Response, error) {
	return r.ApiService.V1EnrollmentAccessGroupsGetExecute(r)
}

/*
V1EnrollmentAccessGroupsGet Retrieve the configured LDAP groups configured for User-Initiated Enrollment 

Retrieves the configured LDAP groups configured for User-Initiated Enrollment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnrollmentAccessGroupsGetRequest

Deprecated
*/
func (a *EnrollmentApiService) V1EnrollmentAccessGroupsGet(ctx context.Context) ApiV1EnrollmentAccessGroupsGetRequest {
	return ApiV1EnrollmentAccessGroupsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccessGroupsSearchResults
// Deprecated
func (a *EnrollmentApiService) V1EnrollmentAccessGroupsGetExecute(r ApiV1EnrollmentAccessGroupsGetRequest) (*AccessGroupsSearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccessGroupsSearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V1EnrollmentAccessGroupsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enrollment/access-groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.pagesize != nil {
		localVarQueryParams.Add("pagesize", parameterToString(*r.pagesize, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page-size", parameterToString(*r.pageSize, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnrollmentAccessGroupsGroupKeyDeleteRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	groupKey string
}

func (r ApiV1EnrollmentAccessGroupsGroupKeyDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1EnrollmentAccessGroupsGroupKeyDeleteExecute(r)
}

/*
V1EnrollmentAccessGroupsGroupKeyDelete Delete an LDAP group's access to user initiated Enrollment 

Deletes an LDAP group's access to user initiated enrollment. The group "All LDAP Users" cannot be deleted, but it can be modified to disallow User-Initiated Enrollment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupKey The group key is a string composed of the LDAP server ID, underscore and the LDAP group id. Example: ``1_2``
 @return ApiV1EnrollmentAccessGroupsGroupKeyDeleteRequest

Deprecated
*/
func (a *EnrollmentApiService) V1EnrollmentAccessGroupsGroupKeyDelete(ctx context.Context, groupKey string) ApiV1EnrollmentAccessGroupsGroupKeyDeleteRequest {
	return ApiV1EnrollmentAccessGroupsGroupKeyDeleteRequest{
		ApiService: a,
		ctx: ctx,
		groupKey: groupKey,
	}
}

// Execute executes the request
// Deprecated
func (a *EnrollmentApiService) V1EnrollmentAccessGroupsGroupKeyDeleteExecute(r ApiV1EnrollmentAccessGroupsGroupKeyDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V1EnrollmentAccessGroupsGroupKeyDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enrollment/access-groups/{group-key}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-key"+"}", url.PathEscape(parameterToString(r.groupKey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1EnrollmentAccessGroupsGroupKeyGetRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	groupKey string
}

func (r ApiV1EnrollmentAccessGroupsGroupKeyGetRequest) Execute() (*EnrollmentAccessGroup, *http.Response, error) {
	return r.ApiService.V1EnrollmentAccessGroupsGroupKeyGetExecute(r)
}

/*
V1EnrollmentAccessGroupsGroupKeyGet Retrieve the configured LDAP groups configured for User-Initiated Enrollment 

Retrieves the configured LDAP groups configured for User-Initiated Enrollment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupKey The group key is a string composed of the LDAP server ID, underscore and the LDAP group id. Example: ``1_2``
 @return ApiV1EnrollmentAccessGroupsGroupKeyGetRequest

Deprecated
*/
func (a *EnrollmentApiService) V1EnrollmentAccessGroupsGroupKeyGet(ctx context.Context, groupKey string) ApiV1EnrollmentAccessGroupsGroupKeyGetRequest {
	return ApiV1EnrollmentAccessGroupsGroupKeyGetRequest{
		ApiService: a,
		ctx: ctx,
		groupKey: groupKey,
	}
}

// Execute executes the request
//  @return EnrollmentAccessGroup
// Deprecated
func (a *EnrollmentApiService) V1EnrollmentAccessGroupsGroupKeyGetExecute(r ApiV1EnrollmentAccessGroupsGroupKeyGetRequest) (*EnrollmentAccessGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnrollmentAccessGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V1EnrollmentAccessGroupsGroupKeyGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enrollment/access-groups/{group-key}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-key"+"}", url.PathEscape(parameterToString(r.groupKey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnrollmentAccessGroupsGroupKeyPutRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	groupKey string
	enrollmentAccessGroup *EnrollmentAccessGroup
}

func (r ApiV1EnrollmentAccessGroupsGroupKeyPutRequest) EnrollmentAccessGroup(enrollmentAccessGroup EnrollmentAccessGroup) ApiV1EnrollmentAccessGroupsGroupKeyPutRequest {
	r.enrollmentAccessGroup = &enrollmentAccessGroup
	return r
}

func (r ApiV1EnrollmentAccessGroupsGroupKeyPutRequest) Execute() (*EnrollmentAccessGroup, *http.Response, error) {
	return r.ApiService.V1EnrollmentAccessGroupsGroupKeyPutExecute(r)
}

/*
V1EnrollmentAccessGroupsGroupKeyPut Modify the configured LDAP groups configured for User-Initiated Enrollment 

Modifies the configured LDAP groups configured for User-Initiated Enrollment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupKey The group key is a string composed of the LDAP server ID, underscore and the LDAP group id. Example: ``1_2``
 @return ApiV1EnrollmentAccessGroupsGroupKeyPutRequest

Deprecated
*/
func (a *EnrollmentApiService) V1EnrollmentAccessGroupsGroupKeyPut(ctx context.Context, groupKey string) ApiV1EnrollmentAccessGroupsGroupKeyPutRequest {
	return ApiV1EnrollmentAccessGroupsGroupKeyPutRequest{
		ApiService: a,
		ctx: ctx,
		groupKey: groupKey,
	}
}

// Execute executes the request
//  @return EnrollmentAccessGroup
// Deprecated
func (a *EnrollmentApiService) V1EnrollmentAccessGroupsGroupKeyPutExecute(r ApiV1EnrollmentAccessGroupsGroupKeyPutRequest) (*EnrollmentAccessGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnrollmentAccessGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V1EnrollmentAccessGroupsGroupKeyPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enrollment/access-groups/{group-key}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-key"+"}", url.PathEscape(parameterToString(r.groupKey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.enrollmentAccessGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnrollmentFilteredLanguageCodesGetRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
}

func (r ApiV1EnrollmentFilteredLanguageCodesGetRequest) Execute() ([]LanguageCode, *http.Response, error) {
	return r.ApiService.V1EnrollmentFilteredLanguageCodesGetExecute(r)
}

/*
V1EnrollmentFilteredLanguageCodesGet Retrieve the list of languages and corresponding ISO 639-1 Codes but only those not already added to Enrollment 

Retrieves the list of languages and corresponding ISO 639-1 Codes, but only those not already added to Enrollment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnrollmentFilteredLanguageCodesGetRequest

Deprecated
*/
func (a *EnrollmentApiService) V1EnrollmentFilteredLanguageCodesGet(ctx context.Context) ApiV1EnrollmentFilteredLanguageCodesGetRequest {
	return ApiV1EnrollmentFilteredLanguageCodesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []LanguageCode
// Deprecated
func (a *EnrollmentApiService) V1EnrollmentFilteredLanguageCodesGetExecute(r ApiV1EnrollmentFilteredLanguageCodesGetRequest) ([]LanguageCode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LanguageCode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V1EnrollmentFilteredLanguageCodesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enrollment/filtered-language-codes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnrollmentGetRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
}

func (r ApiV1EnrollmentGetRequest) Execute() (*EnrollmentSettings, *http.Response, error) {
	return r.ApiService.V1EnrollmentGetExecute(r)
}

/*
V1EnrollmentGet Get Enrollment object and Re-enrollment settings 

Gets Enrollment object and re-enrollment settings. The settings can be altered without providing the existing management password by providing the following value for managementPassword:  \uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnrollmentGetRequest

Deprecated
*/
func (a *EnrollmentApiService) V1EnrollmentGet(ctx context.Context) ApiV1EnrollmentGetRequest {
	return ApiV1EnrollmentGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EnrollmentSettings
// Deprecated
func (a *EnrollmentApiService) V1EnrollmentGetExecute(r ApiV1EnrollmentGetRequest) (*EnrollmentSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnrollmentSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V1EnrollmentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enrollment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnrollmentHistoryGetRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	page *int32
	size *int32
	pagesize *int32
	pageSize *int32
	sort *string
}

func (r ApiV1EnrollmentHistoryGetRequest) Page(page int32) ApiV1EnrollmentHistoryGetRequest {
	r.page = &page
	return r
}

// Deprecated
func (r ApiV1EnrollmentHistoryGetRequest) Size(size int32) ApiV1EnrollmentHistoryGetRequest {
	r.size = &size
	return r
}

// Deprecated
func (r ApiV1EnrollmentHistoryGetRequest) Pagesize(pagesize int32) ApiV1EnrollmentHistoryGetRequest {
	r.pagesize = &pagesize
	return r
}

func (r ApiV1EnrollmentHistoryGetRequest) PageSize(pageSize int32) ApiV1EnrollmentHistoryGetRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property:asc/desc. Default sort is date:desc. Multiple sort criteria are supported and must be separated with a comma. Example: sort&#x3D;date:desc,name:asc 
func (r ApiV1EnrollmentHistoryGetRequest) Sort(sort string) ApiV1EnrollmentHistoryGetRequest {
	r.sort = &sort
	return r
}

func (r ApiV1EnrollmentHistoryGetRequest) Execute() (*HistorySearchResults, *http.Response, error) {
	return r.ApiService.V1EnrollmentHistoryGetExecute(r)
}

/*
V1EnrollmentHistoryGet Get sorted and paged Enrollment history object 

Gets sorted and paged Enrollment history object


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnrollmentHistoryGetRequest

Deprecated
*/
func (a *EnrollmentApiService) V1EnrollmentHistoryGet(ctx context.Context) ApiV1EnrollmentHistoryGetRequest {
	return ApiV1EnrollmentHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HistorySearchResults
// Deprecated
func (a *EnrollmentApiService) V1EnrollmentHistoryGetExecute(r ApiV1EnrollmentHistoryGetRequest) (*HistorySearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistorySearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V1EnrollmentHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enrollment/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.pagesize != nil {
		localVarQueryParams.Add("pagesize", parameterToString(*r.pagesize, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page-size", parameterToString(*r.pageSize, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnrollmentHistoryPostRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	objectHistoryNote *ObjectHistoryNote
}

// history notes to create
func (r ApiV1EnrollmentHistoryPostRequest) ObjectHistoryNote(objectHistoryNote ObjectHistoryNote) ApiV1EnrollmentHistoryPostRequest {
	r.objectHistoryNote = &objectHistoryNote
	return r
}

func (r ApiV1EnrollmentHistoryPostRequest) Execute() (*ObjectHistory, *http.Response, error) {
	return r.ApiService.V1EnrollmentHistoryPostExecute(r)
}

/*
V1EnrollmentHistoryPost Add Enrollment history object notes 

Adds Enrollment history object notes


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnrollmentHistoryPostRequest

Deprecated
*/
func (a *EnrollmentApiService) V1EnrollmentHistoryPost(ctx context.Context) ApiV1EnrollmentHistoryPostRequest {
	return ApiV1EnrollmentHistoryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ObjectHistory
// Deprecated
func (a *EnrollmentApiService) V1EnrollmentHistoryPostExecute(r ApiV1EnrollmentHistoryPostRequest) (*ObjectHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V1EnrollmentHistoryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enrollment/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.objectHistoryNote == nil {
		return localVarReturnValue, nil, reportError("objectHistoryNote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.objectHistoryNote
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnrollmentLanguageCodesGetRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
}

func (r ApiV1EnrollmentLanguageCodesGetRequest) Execute() ([]LanguageCode, *http.Response, error) {
	return r.ApiService.V1EnrollmentLanguageCodesGetExecute(r)
}

/*
V1EnrollmentLanguageCodesGet Retrieve the list of languages and corresponding ISO 639-1 Codes 

Retrieves the list of languages and corresponding ISO 639-1 Codes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnrollmentLanguageCodesGetRequest

Deprecated
*/
func (a *EnrollmentApiService) V1EnrollmentLanguageCodesGet(ctx context.Context) ApiV1EnrollmentLanguageCodesGetRequest {
	return ApiV1EnrollmentLanguageCodesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []LanguageCode
// Deprecated
func (a *EnrollmentApiService) V1EnrollmentLanguageCodesGetExecute(r ApiV1EnrollmentLanguageCodesGetRequest) ([]LanguageCode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LanguageCode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V1EnrollmentLanguageCodesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enrollment/language-codes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnrollmentLanguagesGetRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	page *int32
	size *int32
	pagesize *int32
	pageSize *int32
	sort *string
}

func (r ApiV1EnrollmentLanguagesGetRequest) Page(page int32) ApiV1EnrollmentLanguagesGetRequest {
	r.page = &page
	return r
}

// Deprecated
func (r ApiV1EnrollmentLanguagesGetRequest) Size(size int32) ApiV1EnrollmentLanguagesGetRequest {
	r.size = &size
	return r
}

// Deprecated
func (r ApiV1EnrollmentLanguagesGetRequest) Pagesize(pagesize int32) ApiV1EnrollmentLanguagesGetRequest {
	r.pagesize = &pagesize
	return r
}

func (r ApiV1EnrollmentLanguagesGetRequest) PageSize(pageSize int32) ApiV1EnrollmentLanguagesGetRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property:asc/desc. Default sort is languageCode:asc. Multiple sort criteria are supported and must be separated with a comma. Example: sort&#x3D;date:desc,name:asc 
func (r ApiV1EnrollmentLanguagesGetRequest) Sort(sort string) ApiV1EnrollmentLanguagesGetRequest {
	r.sort = &sort
	return r
}

func (r ApiV1EnrollmentLanguagesGetRequest) Execute() (*ProcessTextsSearchResults, *http.Response, error) {
	return r.ApiService.V1EnrollmentLanguagesGetExecute(r)
}

/*
V1EnrollmentLanguagesGet Get an array of the language codes that have Enrollment messaging 

Returns an array of the language codes that have enrollment messaging currently configured.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnrollmentLanguagesGetRequest

Deprecated
*/
func (a *EnrollmentApiService) V1EnrollmentLanguagesGet(ctx context.Context) ApiV1EnrollmentLanguagesGetRequest {
	return ApiV1EnrollmentLanguagesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProcessTextsSearchResults
// Deprecated
func (a *EnrollmentApiService) V1EnrollmentLanguagesGetExecute(r ApiV1EnrollmentLanguagesGetRequest) (*ProcessTextsSearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProcessTextsSearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V1EnrollmentLanguagesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enrollment/languages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.pagesize != nil {
		localVarQueryParams.Add("pagesize", parameterToString(*r.pagesize, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page-size", parameterToString(*r.pageSize, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnrollmentLanguagesLanguageDeleteRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	language string
}

func (r ApiV1EnrollmentLanguagesLanguageDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1EnrollmentLanguagesLanguageDeleteExecute(r)
}

/*
V1EnrollmentLanguagesLanguageDelete Delete the Enrollment messaging for a language 

Delete the enrollment messaging for a language.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param language Two letter ISO 639-1 Language Code
 @return ApiV1EnrollmentLanguagesLanguageDeleteRequest

Deprecated
*/
func (a *EnrollmentApiService) V1EnrollmentLanguagesLanguageDelete(ctx context.Context, language string) ApiV1EnrollmentLanguagesLanguageDeleteRequest {
	return ApiV1EnrollmentLanguagesLanguageDeleteRequest{
		ApiService: a,
		ctx: ctx,
		language: language,
	}
}

// Execute executes the request
// Deprecated
func (a *EnrollmentApiService) V1EnrollmentLanguagesLanguageDeleteExecute(r ApiV1EnrollmentLanguagesLanguageDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V1EnrollmentLanguagesLanguageDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enrollment/languages/{language}"
	localVarPath = strings.Replace(localVarPath, "{"+"language"+"}", url.PathEscape(parameterToString(r.language, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1EnrollmentLanguagesLanguageGetRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	language string
}

func (r ApiV1EnrollmentLanguagesLanguageGetRequest) Execute() (*EnrollmentProcessTextObject, *http.Response, error) {
	return r.ApiService.V1EnrollmentLanguagesLanguageGetExecute(r)
}

/*
V1EnrollmentLanguagesLanguageGet Retrieve the Enrollment messaging for a language 

Retrieves the enrollment messaging for a language.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param language Two letter ISO 639-1 Language Code
 @return ApiV1EnrollmentLanguagesLanguageGetRequest

Deprecated
*/
func (a *EnrollmentApiService) V1EnrollmentLanguagesLanguageGet(ctx context.Context, language string) ApiV1EnrollmentLanguagesLanguageGetRequest {
	return ApiV1EnrollmentLanguagesLanguageGetRequest{
		ApiService: a,
		ctx: ctx,
		language: language,
	}
}

// Execute executes the request
//  @return EnrollmentProcessTextObject
// Deprecated
func (a *EnrollmentApiService) V1EnrollmentLanguagesLanguageGetExecute(r ApiV1EnrollmentLanguagesLanguageGetRequest) (*EnrollmentProcessTextObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnrollmentProcessTextObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V1EnrollmentLanguagesLanguageGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enrollment/languages/{language}"
	localVarPath = strings.Replace(localVarPath, "{"+"language"+"}", url.PathEscape(parameterToString(r.language, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnrollmentLanguagesLanguagePutRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	language string
	enrollmentProcessTextObject *EnrollmentProcessTextObject
}

func (r ApiV1EnrollmentLanguagesLanguagePutRequest) EnrollmentProcessTextObject(enrollmentProcessTextObject EnrollmentProcessTextObject) ApiV1EnrollmentLanguagesLanguagePutRequest {
	r.enrollmentProcessTextObject = &enrollmentProcessTextObject
	return r
}

func (r ApiV1EnrollmentLanguagesLanguagePutRequest) Execute() (*EnrollmentProcessTextObject, *http.Response, error) {
	return r.ApiService.V1EnrollmentLanguagesLanguagePutExecute(r)
}

/*
V1EnrollmentLanguagesLanguagePut Edit Enrollment messaging for a language 

Edit enrollment messaging for a language.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param language Two letter ISO 639-1 Language Code
 @return ApiV1EnrollmentLanguagesLanguagePutRequest

Deprecated
*/
func (a *EnrollmentApiService) V1EnrollmentLanguagesLanguagePut(ctx context.Context, language string) ApiV1EnrollmentLanguagesLanguagePutRequest {
	return ApiV1EnrollmentLanguagesLanguagePutRequest{
		ApiService: a,
		ctx: ctx,
		language: language,
	}
}

// Execute executes the request
//  @return EnrollmentProcessTextObject
// Deprecated
func (a *EnrollmentApiService) V1EnrollmentLanguagesLanguagePutExecute(r ApiV1EnrollmentLanguagesLanguagePutRequest) (*EnrollmentProcessTextObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnrollmentProcessTextObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V1EnrollmentLanguagesLanguagePut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enrollment/languages/{language}"
	localVarPath = strings.Replace(localVarPath, "{"+"language"+"}", url.PathEscape(parameterToString(r.language, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.enrollmentProcessTextObject
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnrollmentPutRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	enrollmentSettings *EnrollmentSettings
}

// Update enrollment
func (r ApiV1EnrollmentPutRequest) EnrollmentSettings(enrollmentSettings EnrollmentSettings) ApiV1EnrollmentPutRequest {
	r.enrollmentSettings = &enrollmentSettings
	return r
}

func (r ApiV1EnrollmentPutRequest) Execute() (*EnrollmentSettings, *http.Response, error) {
	return r.ApiService.V1EnrollmentPutExecute(r)
}

/*
V1EnrollmentPut Update Enrollment object 

Update enrollment object. Regarding the `developerCertificateIdentity`,
if this object is omitted, the certificate will not be deleted from Jamf Pro.
The `identityKeystore` is the entire cert file as a base64 encoded string. The
`md5Sum` field is not required in the PUT request, but is calculated and returned
in the response.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnrollmentPutRequest

Deprecated
*/
func (a *EnrollmentApiService) V1EnrollmentPut(ctx context.Context) ApiV1EnrollmentPutRequest {
	return ApiV1EnrollmentPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EnrollmentSettings
// Deprecated
func (a *EnrollmentApiService) V1EnrollmentPutExecute(r ApiV1EnrollmentPutRequest) (*EnrollmentSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnrollmentSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V1EnrollmentPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enrollment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.enrollmentSettings == nil {
		return localVarReturnValue, nil, reportError("enrollmentSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.enrollmentSettings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2EnrollmentAccessGroupsGetRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	page *int32
	pageSize *int32
	sort *[]string
	allUsersOptionFirst *bool
}

func (r ApiV2EnrollmentAccessGroupsGetRequest) Page(page int32) ApiV2EnrollmentAccessGroupsGetRequest {
	r.page = &page
	return r
}

func (r ApiV2EnrollmentAccessGroupsGetRequest) PageSize(pageSize int32) ApiV2EnrollmentAccessGroupsGetRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: &#x60;property:asc/desc&#x60;. Default sort is &#x60;name:asc&#x60;. Multiple sort criteria are supported and must be separated with a comma. Example: &#x60;sort&#x3D;date:desc,name:asc&#x60;. 
func (r ApiV2EnrollmentAccessGroupsGetRequest) Sort(sort []string) ApiV2EnrollmentAccessGroupsGetRequest {
	r.sort = &sort
	return r
}

// Return \&quot;All LDAP Users\&quot; option on the first position if it is present in the current page
func (r ApiV2EnrollmentAccessGroupsGetRequest) AllUsersOptionFirst(allUsersOptionFirst bool) ApiV2EnrollmentAccessGroupsGetRequest {
	r.allUsersOptionFirst = &allUsersOptionFirst
	return r
}

func (r ApiV2EnrollmentAccessGroupsGetRequest) Execute() (*AccessGroupsV2SearchResults, *http.Response, error) {
	return r.ApiService.V2EnrollmentAccessGroupsGetExecute(r)
}

/*
V2EnrollmentAccessGroupsGet Retrieve the configured LDAP groups configured for User-Initiated Enrollment 

Retrieves the configured LDAP groups configured for User-Initiated Enrollment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2EnrollmentAccessGroupsGetRequest
*/
func (a *EnrollmentApiService) V2EnrollmentAccessGroupsGet(ctx context.Context) ApiV2EnrollmentAccessGroupsGetRequest {
	return ApiV2EnrollmentAccessGroupsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccessGroupsV2SearchResults
func (a *EnrollmentApiService) V2EnrollmentAccessGroupsGetExecute(r ApiV2EnrollmentAccessGroupsGetRequest) (*AccessGroupsV2SearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccessGroupsV2SearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V2EnrollmentAccessGroupsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/enrollment/access-groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page-size", parameterToString(*r.pageSize, ""))
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sort", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sort", parameterToString(t, "multi"))
		}
	}
	if r.allUsersOptionFirst != nil {
		localVarQueryParams.Add("all-users-option-first", parameterToString(*r.allUsersOptionFirst, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2EnrollmentAccessGroupsPostRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	enrollmentAccessGroupV2 *EnrollmentAccessGroupV2
}

// Configured LDAP group to create.
func (r ApiV2EnrollmentAccessGroupsPostRequest) EnrollmentAccessGroupV2(enrollmentAccessGroupV2 EnrollmentAccessGroupV2) ApiV2EnrollmentAccessGroupsPostRequest {
	r.enrollmentAccessGroupV2 = &enrollmentAccessGroupV2
	return r
}

func (r ApiV2EnrollmentAccessGroupsPostRequest) Execute() (*HrefResponse, *http.Response, error) {
	return r.ApiService.V2EnrollmentAccessGroupsPostExecute(r)
}

/*
V2EnrollmentAccessGroupsPost Add the configured LDAP group for User-Initiated Enrollment. 

Add the configured LDAP group for User-Initiated Enrollment.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2EnrollmentAccessGroupsPostRequest
*/
func (a *EnrollmentApiService) V2EnrollmentAccessGroupsPost(ctx context.Context) ApiV2EnrollmentAccessGroupsPostRequest {
	return ApiV2EnrollmentAccessGroupsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HrefResponse
func (a *EnrollmentApiService) V2EnrollmentAccessGroupsPostExecute(r ApiV2EnrollmentAccessGroupsPostRequest) (*HrefResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HrefResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V2EnrollmentAccessGroupsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/enrollment/access-groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.enrollmentAccessGroupV2 == nil {
		return localVarReturnValue, nil, reportError("enrollmentAccessGroupV2 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.enrollmentAccessGroupV2
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2EnrollmentAccessGroupsServerIdGroupIdDeleteRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	serverId string
	groupId string
}

func (r ApiV2EnrollmentAccessGroupsServerIdGroupIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2EnrollmentAccessGroupsServerIdGroupIdDeleteExecute(r)
}

/*
V2EnrollmentAccessGroupsServerIdGroupIdDelete Delete an LDAP group's access to user initiated Enrollment 

Deletes an LDAP group's access to user initiated enrollment. The group "All LDAP Users" cannot be deleted, but it can be modified to disallow User-Initiated Enrollment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverId LDAP server id
 @param groupId LDAP group id.
 @return ApiV2EnrollmentAccessGroupsServerIdGroupIdDeleteRequest
*/
func (a *EnrollmentApiService) V2EnrollmentAccessGroupsServerIdGroupIdDelete(ctx context.Context, serverId string, groupId string) ApiV2EnrollmentAccessGroupsServerIdGroupIdDeleteRequest {
	return ApiV2EnrollmentAccessGroupsServerIdGroupIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		serverId: serverId,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *EnrollmentApiService) V2EnrollmentAccessGroupsServerIdGroupIdDeleteExecute(r ApiV2EnrollmentAccessGroupsServerIdGroupIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V2EnrollmentAccessGroupsServerIdGroupIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/enrollment/access-groups/{serverId}/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(parameterToString(r.serverId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2EnrollmentAccessGroupsServerIdGroupIdGetRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	serverId string
	groupId string
}

func (r ApiV2EnrollmentAccessGroupsServerIdGroupIdGetRequest) Execute() (*EnrollmentAccessGroupV2, *http.Response, error) {
	return r.ApiService.V2EnrollmentAccessGroupsServerIdGroupIdGetExecute(r)
}

/*
V2EnrollmentAccessGroupsServerIdGroupIdGet Retrieve the configured LDAP groups configured for User-Initiated Enrollment 

Retrieves the configured LDAP groups configured for User-Initiated Enrollment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverId LDAP server id.
 @param groupId LDAP group id.
 @return ApiV2EnrollmentAccessGroupsServerIdGroupIdGetRequest
*/
func (a *EnrollmentApiService) V2EnrollmentAccessGroupsServerIdGroupIdGet(ctx context.Context, serverId string, groupId string) ApiV2EnrollmentAccessGroupsServerIdGroupIdGetRequest {
	return ApiV2EnrollmentAccessGroupsServerIdGroupIdGetRequest{
		ApiService: a,
		ctx: ctx,
		serverId: serverId,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return EnrollmentAccessGroupV2
func (a *EnrollmentApiService) V2EnrollmentAccessGroupsServerIdGroupIdGetExecute(r ApiV2EnrollmentAccessGroupsServerIdGroupIdGetRequest) (*EnrollmentAccessGroupV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnrollmentAccessGroupV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V2EnrollmentAccessGroupsServerIdGroupIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/enrollment/access-groups/{serverId}/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(parameterToString(r.serverId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2EnrollmentAccessGroupsServerIdGroupIdPutRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	serverId string
	groupId string
	enrollmentAccessGroupV2 *EnrollmentAccessGroupV2
}

func (r ApiV2EnrollmentAccessGroupsServerIdGroupIdPutRequest) EnrollmentAccessGroupV2(enrollmentAccessGroupV2 EnrollmentAccessGroupV2) ApiV2EnrollmentAccessGroupsServerIdGroupIdPutRequest {
	r.enrollmentAccessGroupV2 = &enrollmentAccessGroupV2
	return r
}

func (r ApiV2EnrollmentAccessGroupsServerIdGroupIdPutRequest) Execute() (*EnrollmentAccessGroupV2, *http.Response, error) {
	return r.ApiService.V2EnrollmentAccessGroupsServerIdGroupIdPutExecute(r)
}

/*
V2EnrollmentAccessGroupsServerIdGroupIdPut Modify the configured LDAP groups configured for User-Initiated Enrollment 

Modifies the configured LDAP groups configured for User-Initiated Enrollment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverId LDAP server id.
 @param groupId LDAP group id.
 @return ApiV2EnrollmentAccessGroupsServerIdGroupIdPutRequest
*/
func (a *EnrollmentApiService) V2EnrollmentAccessGroupsServerIdGroupIdPut(ctx context.Context, serverId string, groupId string) ApiV2EnrollmentAccessGroupsServerIdGroupIdPutRequest {
	return ApiV2EnrollmentAccessGroupsServerIdGroupIdPutRequest{
		ApiService: a,
		ctx: ctx,
		serverId: serverId,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return EnrollmentAccessGroupV2
func (a *EnrollmentApiService) V2EnrollmentAccessGroupsServerIdGroupIdPutExecute(r ApiV2EnrollmentAccessGroupsServerIdGroupIdPutRequest) (*EnrollmentAccessGroupV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnrollmentAccessGroupV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V2EnrollmentAccessGroupsServerIdGroupIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/enrollment/access-groups/{serverId}/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(parameterToString(r.serverId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.enrollmentAccessGroupV2
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2EnrollmentFilteredLanguageCodesGetRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
}

func (r ApiV2EnrollmentFilteredLanguageCodesGetRequest) Execute() ([]LanguageCode, *http.Response, error) {
	return r.ApiService.V2EnrollmentFilteredLanguageCodesGetExecute(r)
}

/*
V2EnrollmentFilteredLanguageCodesGet Retrieve the list of languages and corresponding ISO 639-1 Codes but only those not already added to Enrollment 

Retrieves the list of languages and corresponding ISO 639-1 Codes, but only those not already added to Enrollment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2EnrollmentFilteredLanguageCodesGetRequest
*/
func (a *EnrollmentApiService) V2EnrollmentFilteredLanguageCodesGet(ctx context.Context) ApiV2EnrollmentFilteredLanguageCodesGetRequest {
	return ApiV2EnrollmentFilteredLanguageCodesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []LanguageCode
func (a *EnrollmentApiService) V2EnrollmentFilteredLanguageCodesGetExecute(r ApiV2EnrollmentFilteredLanguageCodesGetRequest) ([]LanguageCode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LanguageCode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V2EnrollmentFilteredLanguageCodesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/enrollment/filtered-language-codes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2EnrollmentGetRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
}

func (r ApiV2EnrollmentGetRequest) Execute() (*EnrollmentSettingsV2, *http.Response, error) {
	return r.ApiService.V2EnrollmentGetExecute(r)
}

/*
V2EnrollmentGet Get Enrollment object and Re-enrollment settings 

Gets Enrollment object and re-enrollment settings. The settings can be altered without providing the existing management password by providing the following value for `managementPassword`:
`\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff`.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2EnrollmentGetRequest
*/
func (a *EnrollmentApiService) V2EnrollmentGet(ctx context.Context) ApiV2EnrollmentGetRequest {
	return ApiV2EnrollmentGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EnrollmentSettingsV2
func (a *EnrollmentApiService) V2EnrollmentGetExecute(r ApiV2EnrollmentGetRequest) (*EnrollmentSettingsV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnrollmentSettingsV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V2EnrollmentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/enrollment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2EnrollmentHistoryExportPostRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	exportFields *[]string
	exportLabels *[]string
	page *int32
	pageSize *int32
	sort *[]string
	filter *string
	exportParameters *ExportParameters
}

// Export fields parameter, used to change default order or ignore some of the response properties. Default is empty array, which means that all fields of the response entity will be serialized. Example: export-fields&#x3D;id,username
func (r ApiV2EnrollmentHistoryExportPostRequest) ExportFields(exportFields []string) ApiV2EnrollmentHistoryExportPostRequest {
	r.exportFields = &exportFields
	return r
}

// Export labels parameter, used to customize fieldnames/columns in the exported file. Default is empty array, which means that response properties names will be used. Number of the provided labels must match the number of export-fields Example: export-labels&#x3D;identifier,name with matching: export-fields&#x3D;id,username
func (r ApiV2EnrollmentHistoryExportPostRequest) ExportLabels(exportLabels []string) ApiV2EnrollmentHistoryExportPostRequest {
	r.exportLabels = &exportLabels
	return r
}

func (r ApiV2EnrollmentHistoryExportPostRequest) Page(page int32) ApiV2EnrollmentHistoryExportPostRequest {
	r.page = &page
	return r
}

func (r ApiV2EnrollmentHistoryExportPostRequest) PageSize(pageSize int32) ApiV2EnrollmentHistoryExportPostRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property:asc/desc. Default sort is id:desc. Multiple sort criteria are supported and must be separated with a comma. Example: sort&#x3D;id:desc,name:asc 
func (r ApiV2EnrollmentHistoryExportPostRequest) Sort(sort []string) ApiV2EnrollmentHistoryExportPostRequest {
	r.sort = &sort
	return r
}

// Query in the RSQL format, allowing to filter history notes collection. Default filter is empty query - returning all results for the requested page. Fields allowed in the query: id, name. This param can be combined with paging and sorting. Example: name&#x3D;&#x3D;\&quot;*script*\&quot;
func (r ApiV2EnrollmentHistoryExportPostRequest) Filter(filter string) ApiV2EnrollmentHistoryExportPostRequest {
	r.filter = &filter
	return r
}

// Optional. Override query parameters since they can make URI exceed 2,000 character limit.
func (r ApiV2EnrollmentHistoryExportPostRequest) ExportParameters(exportParameters ExportParameters) ApiV2EnrollmentHistoryExportPostRequest {
	r.exportParameters = &exportParameters
	return r
}

func (r ApiV2EnrollmentHistoryExportPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.V2EnrollmentHistoryExportPostExecute(r)
}

/*
V2EnrollmentHistoryExportPost Export enrollment history collection 

Export enrollment history collection


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2EnrollmentHistoryExportPostRequest
*/
func (a *EnrollmentApiService) V2EnrollmentHistoryExportPost(ctx context.Context) ApiV2EnrollmentHistoryExportPostRequest {
	return ApiV2EnrollmentHistoryExportPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *EnrollmentApiService) V2EnrollmentHistoryExportPostExecute(r ApiV2EnrollmentHistoryExportPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V2EnrollmentHistoryExportPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/enrollment/history/export"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.exportFields != nil {
		t := *r.exportFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("export-fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("export-fields", parameterToString(t, "multi"))
		}
	}
	if r.exportLabels != nil {
		t := *r.exportLabels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("export-labels", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("export-labels", parameterToString(t, "multi"))
		}
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page-size", parameterToString(*r.pageSize, ""))
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sort", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sort", parameterToString(t, "multi"))
		}
	}
	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv,application/json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.exportParameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2EnrollmentHistoryGetRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	page *int32
	pageSize *int32
	sort *[]string
}

func (r ApiV2EnrollmentHistoryGetRequest) Page(page int32) ApiV2EnrollmentHistoryGetRequest {
	r.page = &page
	return r
}

func (r ApiV2EnrollmentHistoryGetRequest) PageSize(pageSize int32) ApiV2EnrollmentHistoryGetRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: &#x60;property:asc/desc&#x60;. Default sort is &#x60;date:desc&#x60;. Multiple sort criteria are supported and must be separated with a comma. Example: &#x60;sort&#x3D;date:desc,name:asc&#x60;. 
func (r ApiV2EnrollmentHistoryGetRequest) Sort(sort []string) ApiV2EnrollmentHistoryGetRequest {
	r.sort = &sort
	return r
}

func (r ApiV2EnrollmentHistoryGetRequest) Execute() (*HistorySearchResults, *http.Response, error) {
	return r.ApiService.V2EnrollmentHistoryGetExecute(r)
}

/*
V2EnrollmentHistoryGet Get sorted and paged Enrollment history object 

Gets sorted and paged Enrollment history object


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2EnrollmentHistoryGetRequest
*/
func (a *EnrollmentApiService) V2EnrollmentHistoryGet(ctx context.Context) ApiV2EnrollmentHistoryGetRequest {
	return ApiV2EnrollmentHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HistorySearchResults
func (a *EnrollmentApiService) V2EnrollmentHistoryGetExecute(r ApiV2EnrollmentHistoryGetRequest) (*HistorySearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistorySearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V2EnrollmentHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/enrollment/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page-size", parameterToString(*r.pageSize, ""))
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sort", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sort", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2EnrollmentHistoryPostRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	objectHistoryNote *ObjectHistoryNote
}

// history notes to create
func (r ApiV2EnrollmentHistoryPostRequest) ObjectHistoryNote(objectHistoryNote ObjectHistoryNote) ApiV2EnrollmentHistoryPostRequest {
	r.objectHistoryNote = &objectHistoryNote
	return r
}

func (r ApiV2EnrollmentHistoryPostRequest) Execute() (*HrefResponse, *http.Response, error) {
	return r.ApiService.V2EnrollmentHistoryPostExecute(r)
}

/*
V2EnrollmentHistoryPost Add Enrollment history object notes 

Adds Enrollment history object notes


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2EnrollmentHistoryPostRequest
*/
func (a *EnrollmentApiService) V2EnrollmentHistoryPost(ctx context.Context) ApiV2EnrollmentHistoryPostRequest {
	return ApiV2EnrollmentHistoryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HrefResponse
func (a *EnrollmentApiService) V2EnrollmentHistoryPostExecute(r ApiV2EnrollmentHistoryPostRequest) (*HrefResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HrefResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V2EnrollmentHistoryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/enrollment/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.objectHistoryNote == nil {
		return localVarReturnValue, nil, reportError("objectHistoryNote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.objectHistoryNote
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2EnrollmentLanguageCodesGetRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
}

func (r ApiV2EnrollmentLanguageCodesGetRequest) Execute() ([]LanguageCode, *http.Response, error) {
	return r.ApiService.V2EnrollmentLanguageCodesGetExecute(r)
}

/*
V2EnrollmentLanguageCodesGet Retrieve the list of languages and corresponding ISO 639-1 Codes 

Retrieves the list of languages and corresponding ISO 639-1 Codes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2EnrollmentLanguageCodesGetRequest
*/
func (a *EnrollmentApiService) V2EnrollmentLanguageCodesGet(ctx context.Context) ApiV2EnrollmentLanguageCodesGetRequest {
	return ApiV2EnrollmentLanguageCodesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []LanguageCode
func (a *EnrollmentApiService) V2EnrollmentLanguageCodesGetExecute(r ApiV2EnrollmentLanguageCodesGetRequest) ([]LanguageCode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LanguageCode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V2EnrollmentLanguageCodesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/enrollment/language-codes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2EnrollmentLanguagesGetRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	page *int32
	pageSize *int32
	sort *[]string
}

func (r ApiV2EnrollmentLanguagesGetRequest) Page(page int32) ApiV2EnrollmentLanguagesGetRequest {
	r.page = &page
	return r
}

func (r ApiV2EnrollmentLanguagesGetRequest) PageSize(pageSize int32) ApiV2EnrollmentLanguagesGetRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property:asc/desc. Default sort is &#x60;languageCode:asc&#x60;. Multiple sort criteria are supported and must be separated with a comma. Example: &#x60;sort&#x3D;date:desc,name:asc&#x60;. 
func (r ApiV2EnrollmentLanguagesGetRequest) Sort(sort []string) ApiV2EnrollmentLanguagesGetRequest {
	r.sort = &sort
	return r
}

func (r ApiV2EnrollmentLanguagesGetRequest) Execute() (*ProcessTextsSearchResults, *http.Response, error) {
	return r.ApiService.V2EnrollmentLanguagesGetExecute(r)
}

/*
V2EnrollmentLanguagesGet Get an array of the language codes that have Enrollment messaging 

Returns an array of the language codes that have enrollment messaging currently configured.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2EnrollmentLanguagesGetRequest
*/
func (a *EnrollmentApiService) V2EnrollmentLanguagesGet(ctx context.Context) ApiV2EnrollmentLanguagesGetRequest {
	return ApiV2EnrollmentLanguagesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProcessTextsSearchResults
func (a *EnrollmentApiService) V2EnrollmentLanguagesGetExecute(r ApiV2EnrollmentLanguagesGetRequest) (*ProcessTextsSearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProcessTextsSearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V2EnrollmentLanguagesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/enrollment/languages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page-size", parameterToString(*r.pageSize, ""))
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sort", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sort", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2EnrollmentLanguagesLanguageIdDeleteRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	languageId string
}

func (r ApiV2EnrollmentLanguagesLanguageIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2EnrollmentLanguagesLanguageIdDeleteExecute(r)
}

/*
V2EnrollmentLanguagesLanguageIdDelete Delete the Enrollment messaging for a language 

Delete the enrollment messaging for a language.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param languageId Two letter ISO 639-1 Language Code
 @return ApiV2EnrollmentLanguagesLanguageIdDeleteRequest
*/
func (a *EnrollmentApiService) V2EnrollmentLanguagesLanguageIdDelete(ctx context.Context, languageId string) ApiV2EnrollmentLanguagesLanguageIdDeleteRequest {
	return ApiV2EnrollmentLanguagesLanguageIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		languageId: languageId,
	}
}

// Execute executes the request
func (a *EnrollmentApiService) V2EnrollmentLanguagesLanguageIdDeleteExecute(r ApiV2EnrollmentLanguagesLanguageIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V2EnrollmentLanguagesLanguageIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/enrollment/languages/{languageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"languageId"+"}", url.PathEscape(parameterToString(r.languageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2EnrollmentLanguagesLanguageIdGetRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	languageId string
}

func (r ApiV2EnrollmentLanguagesLanguageIdGetRequest) Execute() (*EnrollmentProcessTextObject, *http.Response, error) {
	return r.ApiService.V2EnrollmentLanguagesLanguageIdGetExecute(r)
}

/*
V2EnrollmentLanguagesLanguageIdGet Retrieve the Enrollment messaging for a language 

Retrieves the enrollment messaging for a language.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param languageId Two letter ISO 639-1 Language Code
 @return ApiV2EnrollmentLanguagesLanguageIdGetRequest
*/
func (a *EnrollmentApiService) V2EnrollmentLanguagesLanguageIdGet(ctx context.Context, languageId string) ApiV2EnrollmentLanguagesLanguageIdGetRequest {
	return ApiV2EnrollmentLanguagesLanguageIdGetRequest{
		ApiService: a,
		ctx: ctx,
		languageId: languageId,
	}
}

// Execute executes the request
//  @return EnrollmentProcessTextObject
func (a *EnrollmentApiService) V2EnrollmentLanguagesLanguageIdGetExecute(r ApiV2EnrollmentLanguagesLanguageIdGetRequest) (*EnrollmentProcessTextObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnrollmentProcessTextObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V2EnrollmentLanguagesLanguageIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/enrollment/languages/{languageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"languageId"+"}", url.PathEscape(parameterToString(r.languageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2EnrollmentLanguagesLanguageIdPutRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	languageId string
	enrollmentProcessTextObject *EnrollmentProcessTextObject
}

func (r ApiV2EnrollmentLanguagesLanguageIdPutRequest) EnrollmentProcessTextObject(enrollmentProcessTextObject EnrollmentProcessTextObject) ApiV2EnrollmentLanguagesLanguageIdPutRequest {
	r.enrollmentProcessTextObject = &enrollmentProcessTextObject
	return r
}

func (r ApiV2EnrollmentLanguagesLanguageIdPutRequest) Execute() (*EnrollmentProcessTextObject, *http.Response, error) {
	return r.ApiService.V2EnrollmentLanguagesLanguageIdPutExecute(r)
}

/*
V2EnrollmentLanguagesLanguageIdPut Edit Enrollment messaging for a language 

Edit enrollment messaging for a language.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param languageId Two letter ISO 639-1 Language Code
 @return ApiV2EnrollmentLanguagesLanguageIdPutRequest
*/
func (a *EnrollmentApiService) V2EnrollmentLanguagesLanguageIdPut(ctx context.Context, languageId string) ApiV2EnrollmentLanguagesLanguageIdPutRequest {
	return ApiV2EnrollmentLanguagesLanguageIdPutRequest{
		ApiService: a,
		ctx: ctx,
		languageId: languageId,
	}
}

// Execute executes the request
//  @return EnrollmentProcessTextObject
func (a *EnrollmentApiService) V2EnrollmentLanguagesLanguageIdPutExecute(r ApiV2EnrollmentLanguagesLanguageIdPutRequest) (*EnrollmentProcessTextObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnrollmentProcessTextObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V2EnrollmentLanguagesLanguageIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/enrollment/languages/{languageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"languageId"+"}", url.PathEscape(parameterToString(r.languageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.enrollmentProcessTextObject
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2EnrollmentPutRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	enrollmentSettingsV2 *EnrollmentSettingsV2
}

// Update enrollment
func (r ApiV2EnrollmentPutRequest) EnrollmentSettingsV2(enrollmentSettingsV2 EnrollmentSettingsV2) ApiV2EnrollmentPutRequest {
	r.enrollmentSettingsV2 = &enrollmentSettingsV2
	return r
}

func (r ApiV2EnrollmentPutRequest) Execute() (*EnrollmentSettingsV2, *http.Response, error) {
	return r.ApiService.V2EnrollmentPutExecute(r)
}

/*
V2EnrollmentPut Update Enrollment object 

Update enrollment object. Regarding the `developerCertificateIdentity`,
if this object is omitted, the certificate will not be deleted from Jamf Pro.
The `identityKeystore` is the entire cert file as a base64 encoded string. The
`md5Sum` field is not required in the PUT request, but is calculated and returned
in the response.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2EnrollmentPutRequest
*/
func (a *EnrollmentApiService) V2EnrollmentPut(ctx context.Context) ApiV2EnrollmentPutRequest {
	return ApiV2EnrollmentPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EnrollmentSettingsV2
func (a *EnrollmentApiService) V2EnrollmentPutExecute(r ApiV2EnrollmentPutRequest) (*EnrollmentSettingsV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnrollmentSettingsV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.V2EnrollmentPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/enrollment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.enrollmentSettingsV2 == nil {
		return localVarReturnValue, nil, reportError("enrollmentSettingsV2 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.enrollmentSettingsV2
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
