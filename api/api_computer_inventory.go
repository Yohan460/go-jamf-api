/*
Jamf Pro API

## Overview The Jamf Pro API is a RESTful API for Jamf Pro built to enable consistent and efficient programmatic access to Jamf Pro.<br/><br/> The swagger schema can be found [here](/api/schema/). 

API version: production
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"os"
)


type ComputerInventoryAPI interface {

	/*
	V1ComputersInventoryDetailIdGet Return all sections of a computer

	Return all sections of a computer

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id instance id of computer record
	@return ComputerInventoryAPIV1ComputersInventoryDetailIdGetRequest
	*/
	V1ComputersInventoryDetailIdGet(ctx context.Context, id string) ComputerInventoryAPIV1ComputersInventoryDetailIdGetRequest

	// V1ComputersInventoryDetailIdGetExecute executes the request
	//  @return ComputerInventory
	V1ComputersInventoryDetailIdGetExecute(r ComputerInventoryAPIV1ComputersInventoryDetailIdGetRequest) (*ComputerInventory, *http.Response, error)

	/*
	V1ComputersInventoryDetailIdPatch Update specific fields on a computer

	Update specific fields on a computer, then return the updated computer object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id instance id of computer record
	@return ComputerInventoryAPIV1ComputersInventoryDetailIdPatchRequest
	*/
	V1ComputersInventoryDetailIdPatch(ctx context.Context, id string) ComputerInventoryAPIV1ComputersInventoryDetailIdPatchRequest

	// V1ComputersInventoryDetailIdPatchExecute executes the request
	//  @return ComputerInventory
	V1ComputersInventoryDetailIdPatchExecute(r ComputerInventoryAPIV1ComputersInventoryDetailIdPatchRequest) (*ComputerInventory, *http.Response, error)

	/*
	V1ComputersInventoryFilevaultGet Return paginated FileVault information for all computers

	Return paginated FileVault information for all computers

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ComputerInventoryAPIV1ComputersInventoryFilevaultGetRequest
	*/
	V1ComputersInventoryFilevaultGet(ctx context.Context) ComputerInventoryAPIV1ComputersInventoryFilevaultGetRequest

	// V1ComputersInventoryFilevaultGetExecute executes the request
	//  @return ComputerInventoryFileVaultSearchResults
	V1ComputersInventoryFilevaultGetExecute(r ComputerInventoryAPIV1ComputersInventoryFilevaultGetRequest) (*ComputerInventoryFileVaultSearchResults, *http.Response, error)

	/*
	V1ComputersInventoryGet Return paginated Computer Inventory records

	Return paginated Computer Inventory records

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ComputerInventoryAPIV1ComputersInventoryGetRequest
	*/
	V1ComputersInventoryGet(ctx context.Context) ComputerInventoryAPIV1ComputersInventoryGetRequest

	// V1ComputersInventoryGetExecute executes the request
	//  @return ComputerInventorySearchResults
	V1ComputersInventoryGetExecute(r ComputerInventoryAPIV1ComputersInventoryGetRequest) (*ComputerInventorySearchResults, *http.Response, error)

	/*
	V1ComputersInventoryIdAttachmentsAttachmentIdDelete Remove attachment

	Remove attachment

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id instance id of computer record
	@param attachmentId instance id of attachment object
	@return ComputerInventoryAPIV1ComputersInventoryIdAttachmentsAttachmentIdDeleteRequest
	*/
	V1ComputersInventoryIdAttachmentsAttachmentIdDelete(ctx context.Context, id string, attachmentId string) ComputerInventoryAPIV1ComputersInventoryIdAttachmentsAttachmentIdDeleteRequest

	// V1ComputersInventoryIdAttachmentsAttachmentIdDeleteExecute executes the request
	V1ComputersInventoryIdAttachmentsAttachmentIdDeleteExecute(r ComputerInventoryAPIV1ComputersInventoryIdAttachmentsAttachmentIdDeleteRequest) (*http.Response, error)

	/*
	V1ComputersInventoryIdAttachmentsAttachmentIdGet Download attachment file

	Download attachment file

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id instance id of computer record
	@param attachmentId instance id of attachment object
	@return ComputerInventoryAPIV1ComputersInventoryIdAttachmentsAttachmentIdGetRequest
	*/
	V1ComputersInventoryIdAttachmentsAttachmentIdGet(ctx context.Context, id string, attachmentId string) ComputerInventoryAPIV1ComputersInventoryIdAttachmentsAttachmentIdGetRequest

	// V1ComputersInventoryIdAttachmentsAttachmentIdGetExecute executes the request
	//  @return *os.File
	V1ComputersInventoryIdAttachmentsAttachmentIdGetExecute(r ComputerInventoryAPIV1ComputersInventoryIdAttachmentsAttachmentIdGetRequest) (*os.File, *http.Response, error)

	/*
	V1ComputersInventoryIdAttachmentsPost Upload attachment and assign to computer

	Upload attachment and assign to computer

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id instance id of computer record
	@return ComputerInventoryAPIV1ComputersInventoryIdAttachmentsPostRequest
	*/
	V1ComputersInventoryIdAttachmentsPost(ctx context.Context, id string) ComputerInventoryAPIV1ComputersInventoryIdAttachmentsPostRequest

	// V1ComputersInventoryIdAttachmentsPostExecute executes the request
	//  @return HrefResponse
	V1ComputersInventoryIdAttachmentsPostExecute(r ComputerInventoryAPIV1ComputersInventoryIdAttachmentsPostRequest) (*HrefResponse, *http.Response, error)

	/*
	V1ComputersInventoryIdDelete Remove specified Computer record

	Remove specified Computer record

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id instance id of computer record
	@return ComputerInventoryAPIV1ComputersInventoryIdDeleteRequest
	*/
	V1ComputersInventoryIdDelete(ctx context.Context, id string) ComputerInventoryAPIV1ComputersInventoryIdDeleteRequest

	// V1ComputersInventoryIdDeleteExecute executes the request
	V1ComputersInventoryIdDeleteExecute(r ComputerInventoryAPIV1ComputersInventoryIdDeleteRequest) (*http.Response, error)

	/*
	V1ComputersInventoryIdFilevaultGet Return FileVault information for a specific computer

	Return FileVault information for a specific computer

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id instance id of computer record
	@return ComputerInventoryAPIV1ComputersInventoryIdFilevaultGetRequest
	*/
	V1ComputersInventoryIdFilevaultGet(ctx context.Context, id string) ComputerInventoryAPIV1ComputersInventoryIdFilevaultGetRequest

	// V1ComputersInventoryIdFilevaultGetExecute executes the request
	//  @return ComputerInventoryFileVault
	V1ComputersInventoryIdFilevaultGetExecute(r ComputerInventoryAPIV1ComputersInventoryIdFilevaultGetRequest) (*ComputerInventoryFileVault, *http.Response, error)

	/*
	V1ComputersInventoryIdGet Return General section of a Computer

	Return General section of a Computer

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id instance id of computer record
	@return ComputerInventoryAPIV1ComputersInventoryIdGetRequest
	*/
	V1ComputersInventoryIdGet(ctx context.Context, id string) ComputerInventoryAPIV1ComputersInventoryIdGetRequest

	// V1ComputersInventoryIdGetExecute executes the request
	//  @return ComputerInventory
	V1ComputersInventoryIdGetExecute(r ComputerInventoryAPIV1ComputersInventoryIdGetRequest) (*ComputerInventory, *http.Response, error)

	/*
	V1ComputersInventoryIdViewRecoveryLockPasswordGet Return a Computers Recovery Lock Password

	Return a Computers Recovery Lock Password

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id instance id of computer record
	@return ComputerInventoryAPIV1ComputersInventoryIdViewRecoveryLockPasswordGetRequest
	*/
	V1ComputersInventoryIdViewRecoveryLockPasswordGet(ctx context.Context, id string) ComputerInventoryAPIV1ComputersInventoryIdViewRecoveryLockPasswordGetRequest

	// V1ComputersInventoryIdViewRecoveryLockPasswordGetExecute executes the request
	//  @return ComputerInventoryRecoveryLockPasswordResponse
	V1ComputersInventoryIdViewRecoveryLockPasswordGetExecute(r ComputerInventoryAPIV1ComputersInventoryIdViewRecoveryLockPasswordGetRequest) (*ComputerInventoryRecoveryLockPasswordResponse, *http.Response, error)
}

// ComputerInventoryAPIService ComputerInventoryAPI service
type ComputerInventoryAPIService service

type ComputerInventoryAPIV1ComputersInventoryDetailIdGetRequest struct {
	ctx context.Context
	ApiService ComputerInventoryAPI
	id string
}

func (r ComputerInventoryAPIV1ComputersInventoryDetailIdGetRequest) Execute() (*ComputerInventory, *http.Response, error) {
	return r.ApiService.V1ComputersInventoryDetailIdGetExecute(r)
}

/*
V1ComputersInventoryDetailIdGet Return all sections of a computer

Return all sections of a computer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id instance id of computer record
 @return ComputerInventoryAPIV1ComputersInventoryDetailIdGetRequest
*/
func (a *ComputerInventoryAPIService) V1ComputersInventoryDetailIdGet(ctx context.Context, id string) ComputerInventoryAPIV1ComputersInventoryDetailIdGetRequest {
	return ComputerInventoryAPIV1ComputersInventoryDetailIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ComputerInventory
func (a *ComputerInventoryAPIService) V1ComputersInventoryDetailIdGetExecute(r ComputerInventoryAPIV1ComputersInventoryDetailIdGetRequest) (*ComputerInventory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComputerInventory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerInventoryAPIService.V1ComputersInventoryDetailIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/computers-inventory-detail/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerInventoryAPIV1ComputersInventoryDetailIdPatchRequest struct {
	ctx context.Context
	ApiService ComputerInventoryAPI
	id string
	computerInventoryUpdateRequest *ComputerInventoryUpdateRequest
}

func (r ComputerInventoryAPIV1ComputersInventoryDetailIdPatchRequest) ComputerInventoryUpdateRequest(computerInventoryUpdateRequest ComputerInventoryUpdateRequest) ComputerInventoryAPIV1ComputersInventoryDetailIdPatchRequest {
	r.computerInventoryUpdateRequest = &computerInventoryUpdateRequest
	return r
}

func (r ComputerInventoryAPIV1ComputersInventoryDetailIdPatchRequest) Execute() (*ComputerInventory, *http.Response, error) {
	return r.ApiService.V1ComputersInventoryDetailIdPatchExecute(r)
}

/*
V1ComputersInventoryDetailIdPatch Update specific fields on a computer

Update specific fields on a computer, then return the updated computer object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id instance id of computer record
 @return ComputerInventoryAPIV1ComputersInventoryDetailIdPatchRequest
*/
func (a *ComputerInventoryAPIService) V1ComputersInventoryDetailIdPatch(ctx context.Context, id string) ComputerInventoryAPIV1ComputersInventoryDetailIdPatchRequest {
	return ComputerInventoryAPIV1ComputersInventoryDetailIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ComputerInventory
func (a *ComputerInventoryAPIService) V1ComputersInventoryDetailIdPatchExecute(r ComputerInventoryAPIV1ComputersInventoryDetailIdPatchRequest) (*ComputerInventory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComputerInventory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerInventoryAPIService.V1ComputersInventoryDetailIdPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/computers-inventory-detail/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.computerInventoryUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("computerInventoryUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.computerInventoryUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerInventoryAPIV1ComputersInventoryFilevaultGetRequest struct {
	ctx context.Context
	ApiService ComputerInventoryAPI
	page *int64
	pageSize *int64
}

func (r ComputerInventoryAPIV1ComputersInventoryFilevaultGetRequest) Page(page int64) ComputerInventoryAPIV1ComputersInventoryFilevaultGetRequest {
	r.page = &page
	return r
}

func (r ComputerInventoryAPIV1ComputersInventoryFilevaultGetRequest) PageSize(pageSize int64) ComputerInventoryAPIV1ComputersInventoryFilevaultGetRequest {
	r.pageSize = &pageSize
	return r
}

func (r ComputerInventoryAPIV1ComputersInventoryFilevaultGetRequest) Execute() (*ComputerInventoryFileVaultSearchResults, *http.Response, error) {
	return r.ApiService.V1ComputersInventoryFilevaultGetExecute(r)
}

/*
V1ComputersInventoryFilevaultGet Return paginated FileVault information for all computers

Return paginated FileVault information for all computers

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ComputerInventoryAPIV1ComputersInventoryFilevaultGetRequest
*/
func (a *ComputerInventoryAPIService) V1ComputersInventoryFilevaultGet(ctx context.Context) ComputerInventoryAPIV1ComputersInventoryFilevaultGetRequest {
	return ComputerInventoryAPIV1ComputersInventoryFilevaultGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComputerInventoryFileVaultSearchResults
func (a *ComputerInventoryAPIService) V1ComputersInventoryFilevaultGetExecute(r ComputerInventoryAPIV1ComputersInventoryFilevaultGetRequest) (*ComputerInventoryFileVaultSearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComputerInventoryFileVaultSearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerInventoryAPIService.V1ComputersInventoryFilevaultGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/computers-inventory/filevault"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int64 = 0
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page-size", r.pageSize, "")
	} else {
		var defaultValue int64 = 100
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerInventoryAPIV1ComputersInventoryGetRequest struct {
	ctx context.Context
	ApiService ComputerInventoryAPI
	section *[]ComputerSection
	page *int64
	pageSize *int64
	sort *[]string
	filter *string
}

// section of computer details, if not specified, General section data is returned. Multiple section parameters are supported, e.g. section&#x3D;GENERAL&amp;section&#x3D;HARDWARE
func (r ComputerInventoryAPIV1ComputersInventoryGetRequest) Section(section []ComputerSection) ComputerInventoryAPIV1ComputersInventoryGetRequest {
	r.section = &section
	return r
}

func (r ComputerInventoryAPIV1ComputersInventoryGetRequest) Page(page int64) ComputerInventoryAPIV1ComputersInventoryGetRequest {
	r.page = &page
	return r
}

func (r ComputerInventoryAPIV1ComputersInventoryGetRequest) PageSize(pageSize int64) ComputerInventoryAPIV1ComputersInventoryGetRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: &#x60;property:asc/desc&#x60;. Default sort is &#x60;general.name:asc&#x60;. Multiple sort criteria are supported and must be separated with a comma.  Fields allowed in the sort: &#x60;general.name&#x60;, &#x60;udid&#x60;, &#x60;id&#x60;, &#x60;general.assetTag&#x60;, &#x60;general.jamfBinaryVersion&#x60;, &#x60;general.lastContactTime&#x60;, &#x60;general.lastEnrolledDate&#x60;, &#x60;general.lastCloudBackupDate&#x60;, &#x60;general.reportDate&#x60;, &#x60;general.remoteManagement.managementUsername&#x60;, &#x60;general.mdmCertificateExpiration&#x60;, &#x60;general.platform&#x60;, &#x60;hardware.make&#x60;, &#x60;hardware.model&#x60;, &#x60;operatingSystem.build&#x60;, &#x60;operatingSystem.supplementalBuildVersion&#x60;, &#x60;operatingSystem.rapidSecurityResponse&#x60;, &#x60;operatingSystem.name&#x60;, &#x60;operatingSystem.version&#x60;, &#x60;userAndLocation.realname&#x60;, &#x60;purchasing.lifeExpectancy&#x60;, &#x60;purchasing.warrantyDate&#x60;  Example: &#x60;sort&#x3D;udid:desc,general.name:asc&#x60;. 
func (r ComputerInventoryAPIV1ComputersInventoryGetRequest) Sort(sort []string) ComputerInventoryAPIV1ComputersInventoryGetRequest {
	r.sort = &sort
	return r
}

// Query in the RSQL format, allowing to filter computer inventory collection. Default filter is empty query - returning all results for the requested page.  Fields allowed in the query: &#x60;general.name&#x60;, &#x60;udid&#x60;, &#x60;id&#x60;, &#x60;general.assetTag&#x60;, &#x60;general.barcode1&#x60;, &#x60;general.barcode2&#x60;, &#x60;general.enrolledViaAutomatedDeviceEnrollment&#x60;, &#x60;general.lastIpAddress&#x60;, &#x60;general.itunesStoreAccountActive&#x60;, &#x60;general.jamfBinaryVersion&#x60;, &#x60;general.lastContactTime&#x60;, &#x60;general.lastEnrolledDate&#x60;, &#x60;general.lastCloudBackupDate&#x60;, &#x60;general.reportDate&#x60;, &#x60;general.lastReportedIp&#x60;, &#x60;general.remoteManagement.managed&#x60;, &#x60;general.remoteManagement.managementUsername&#x60;, &#x60;general.mdmCapable.capable&#x60;, &#x60;general.mdmCertificateExpiration&#x60;, &#x60;general.platform&#x60;, &#x60;general.supervised&#x60;, &#x60;general.userApprovedMdm&#x60;, &#x60;general.declarativeDeviceManagementEnabled&#x60;,  &#x60;hardware.bleCapable&#x60;, &#x60;hardware.macAddress&#x60;, &#x60;hardware.make&#x60;, &#x60;hardware.model&#x60;, &#x60;hardware.modelIdentifier&#x60;, &#x60;hardware.serialNumber&#x60;, &#x60;hardware.supportsIosAppInstalls&#x60;,&#x60;hardware.appleSilicon&#x60;, &#x60;operatingSystem.activeDirectoryStatus&#x60;, &#x60;operatingSystem.fileVault2Status&#x60;, &#x60;operatingSystem.build&#x60;, &#x60;operatingSystem.supplementalBuildVersion&#x60;, &#x60;operatingSystem.rapidSecurityResponse&#x60;, &#x60;operatingSystem.name&#x60;, &#x60;operatingSystem.version&#x60;, &#x60;security.activationLockEnabled&#x60;, &#x60;security.recoveryLockEnabled&#x60;,&#x60;security.firewallEnabled&#x60;,&#x60;userAndLocation.buildingId&#x60;, &#x60;userAndLocation.departmentId&#x60;, &#x60;userAndLocation.email&#x60;, &#x60;userAndLocation.realname&#x60;, &#x60;userAndLocation.phone&#x60;, &#x60;userAndLocation.position&#x60;,&#x60;userAndLocation.room&#x60;, &#x60;userAndLocation.username&#x60;, &#x60;purchasing.appleCareId&#x60;, &#x60;purchasing.lifeExpectancy&#x60;, &#x60;purchasing.purchased&#x60;, &#x60;purchasing.leased&#x60;, &#x60;purchasing.vendor&#x60;, &#x60;purchasing.warrantyDate&#x60;,  This param can be combined with paging and sorting. Example: &#x60;filter&#x3D;general.name&#x3D;&#x3D;\&quot;Orchard\&quot;&#x60; 
func (r ComputerInventoryAPIV1ComputersInventoryGetRequest) Filter(filter string) ComputerInventoryAPIV1ComputersInventoryGetRequest {
	r.filter = &filter
	return r
}

func (r ComputerInventoryAPIV1ComputersInventoryGetRequest) Execute() (*ComputerInventorySearchResults, *http.Response, error) {
	return r.ApiService.V1ComputersInventoryGetExecute(r)
}

/*
V1ComputersInventoryGet Return paginated Computer Inventory records

Return paginated Computer Inventory records

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ComputerInventoryAPIV1ComputersInventoryGetRequest
*/
func (a *ComputerInventoryAPIService) V1ComputersInventoryGet(ctx context.Context) ComputerInventoryAPIV1ComputersInventoryGetRequest {
	return ComputerInventoryAPIV1ComputersInventoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComputerInventorySearchResults
func (a *ComputerInventoryAPIService) V1ComputersInventoryGetExecute(r ComputerInventoryAPIV1ComputersInventoryGetRequest) (*ComputerInventorySearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComputerInventorySearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerInventoryAPIService.V1ComputersInventoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/computers-inventory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.section != nil {
		t := *r.section
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "section", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "section", t, "multi")
		}
	} else {
		defaultValue := []ComputerSection{"GENERAL"}
		r.section = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int64 = 0
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page-size", r.pageSize, "")
	} else {
		var defaultValue int64 = 100
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	} else {
		defaultValue := []string{"general.name:asc"}
		r.sort = &defaultValue
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	} else {
		var defaultValue string = ""
		r.filter = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerInventoryAPIV1ComputersInventoryIdAttachmentsAttachmentIdDeleteRequest struct {
	ctx context.Context
	ApiService ComputerInventoryAPI
	id string
	attachmentId string
}

func (r ComputerInventoryAPIV1ComputersInventoryIdAttachmentsAttachmentIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1ComputersInventoryIdAttachmentsAttachmentIdDeleteExecute(r)
}

/*
V1ComputersInventoryIdAttachmentsAttachmentIdDelete Remove attachment

Remove attachment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id instance id of computer record
 @param attachmentId instance id of attachment object
 @return ComputerInventoryAPIV1ComputersInventoryIdAttachmentsAttachmentIdDeleteRequest
*/
func (a *ComputerInventoryAPIService) V1ComputersInventoryIdAttachmentsAttachmentIdDelete(ctx context.Context, id string, attachmentId string) ComputerInventoryAPIV1ComputersInventoryIdAttachmentsAttachmentIdDeleteRequest {
	return ComputerInventoryAPIV1ComputersInventoryIdAttachmentsAttachmentIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *ComputerInventoryAPIService) V1ComputersInventoryIdAttachmentsAttachmentIdDeleteExecute(r ComputerInventoryAPIV1ComputersInventoryIdAttachmentsAttachmentIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerInventoryAPIService.V1ComputersInventoryIdAttachmentsAttachmentIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/computers-inventory/{id}/attachments/{attachmentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachmentId"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ComputerInventoryAPIV1ComputersInventoryIdAttachmentsAttachmentIdGetRequest struct {
	ctx context.Context
	ApiService ComputerInventoryAPI
	id string
	attachmentId string
}

func (r ComputerInventoryAPIV1ComputersInventoryIdAttachmentsAttachmentIdGetRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.V1ComputersInventoryIdAttachmentsAttachmentIdGetExecute(r)
}

/*
V1ComputersInventoryIdAttachmentsAttachmentIdGet Download attachment file

Download attachment file

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id instance id of computer record
 @param attachmentId instance id of attachment object
 @return ComputerInventoryAPIV1ComputersInventoryIdAttachmentsAttachmentIdGetRequest
*/
func (a *ComputerInventoryAPIService) V1ComputersInventoryIdAttachmentsAttachmentIdGet(ctx context.Context, id string, attachmentId string) ComputerInventoryAPIV1ComputersInventoryIdAttachmentsAttachmentIdGetRequest {
	return ComputerInventoryAPIV1ComputersInventoryIdAttachmentsAttachmentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ComputerInventoryAPIService) V1ComputersInventoryIdAttachmentsAttachmentIdGetExecute(r ComputerInventoryAPIV1ComputersInventoryIdAttachmentsAttachmentIdGetRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerInventoryAPIService.V1ComputersInventoryIdAttachmentsAttachmentIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/computers-inventory/{id}/attachments/{attachmentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachmentId"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerInventoryAPIV1ComputersInventoryIdAttachmentsPostRequest struct {
	ctx context.Context
	ApiService ComputerInventoryAPI
	id string
	file *os.File
}

// The file to upload
func (r ComputerInventoryAPIV1ComputersInventoryIdAttachmentsPostRequest) File(file *os.File) ComputerInventoryAPIV1ComputersInventoryIdAttachmentsPostRequest {
	r.file = file
	return r
}

func (r ComputerInventoryAPIV1ComputersInventoryIdAttachmentsPostRequest) Execute() (*HrefResponse, *http.Response, error) {
	return r.ApiService.V1ComputersInventoryIdAttachmentsPostExecute(r)
}

/*
V1ComputersInventoryIdAttachmentsPost Upload attachment and assign to computer

Upload attachment and assign to computer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id instance id of computer record
 @return ComputerInventoryAPIV1ComputersInventoryIdAttachmentsPostRequest
*/
func (a *ComputerInventoryAPIService) V1ComputersInventoryIdAttachmentsPost(ctx context.Context, id string) ComputerInventoryAPIV1ComputersInventoryIdAttachmentsPostRequest {
	return ComputerInventoryAPIV1ComputersInventoryIdAttachmentsPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return HrefResponse
func (a *ComputerInventoryAPIService) V1ComputersInventoryIdAttachmentsPostExecute(r ComputerInventoryAPIV1ComputersInventoryIdAttachmentsPostRequest) (*HrefResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HrefResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerInventoryAPIService.V1ComputersInventoryIdAttachmentsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/computers-inventory/{id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.file == nil {
		return localVarReturnValue, nil, reportError("file is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerInventoryAPIV1ComputersInventoryIdDeleteRequest struct {
	ctx context.Context
	ApiService ComputerInventoryAPI
	id string
}

func (r ComputerInventoryAPIV1ComputersInventoryIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1ComputersInventoryIdDeleteExecute(r)
}

/*
V1ComputersInventoryIdDelete Remove specified Computer record

Remove specified Computer record

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id instance id of computer record
 @return ComputerInventoryAPIV1ComputersInventoryIdDeleteRequest
*/
func (a *ComputerInventoryAPIService) V1ComputersInventoryIdDelete(ctx context.Context, id string) ComputerInventoryAPIV1ComputersInventoryIdDeleteRequest {
	return ComputerInventoryAPIV1ComputersInventoryIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ComputerInventoryAPIService) V1ComputersInventoryIdDeleteExecute(r ComputerInventoryAPIV1ComputersInventoryIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerInventoryAPIService.V1ComputersInventoryIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/computers-inventory/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ComputerInventoryAPIV1ComputersInventoryIdFilevaultGetRequest struct {
	ctx context.Context
	ApiService ComputerInventoryAPI
	id string
}

func (r ComputerInventoryAPIV1ComputersInventoryIdFilevaultGetRequest) Execute() (*ComputerInventoryFileVault, *http.Response, error) {
	return r.ApiService.V1ComputersInventoryIdFilevaultGetExecute(r)
}

/*
V1ComputersInventoryIdFilevaultGet Return FileVault information for a specific computer

Return FileVault information for a specific computer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id instance id of computer record
 @return ComputerInventoryAPIV1ComputersInventoryIdFilevaultGetRequest
*/
func (a *ComputerInventoryAPIService) V1ComputersInventoryIdFilevaultGet(ctx context.Context, id string) ComputerInventoryAPIV1ComputersInventoryIdFilevaultGetRequest {
	return ComputerInventoryAPIV1ComputersInventoryIdFilevaultGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ComputerInventoryFileVault
func (a *ComputerInventoryAPIService) V1ComputersInventoryIdFilevaultGetExecute(r ComputerInventoryAPIV1ComputersInventoryIdFilevaultGetRequest) (*ComputerInventoryFileVault, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComputerInventoryFileVault
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerInventoryAPIService.V1ComputersInventoryIdFilevaultGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/computers-inventory/{id}/filevault"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerInventoryAPIV1ComputersInventoryIdGetRequest struct {
	ctx context.Context
	ApiService ComputerInventoryAPI
	id string
	section *[]ComputerSection
}

// section of computer details, if not specified, General section data is returned. Multiple section parameters are supported, e.g. section&#x3D;general&amp;section&#x3D;hardware
func (r ComputerInventoryAPIV1ComputersInventoryIdGetRequest) Section(section []ComputerSection) ComputerInventoryAPIV1ComputersInventoryIdGetRequest {
	r.section = &section
	return r
}

func (r ComputerInventoryAPIV1ComputersInventoryIdGetRequest) Execute() (*ComputerInventory, *http.Response, error) {
	return r.ApiService.V1ComputersInventoryIdGetExecute(r)
}

/*
V1ComputersInventoryIdGet Return General section of a Computer

Return General section of a Computer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id instance id of computer record
 @return ComputerInventoryAPIV1ComputersInventoryIdGetRequest
*/
func (a *ComputerInventoryAPIService) V1ComputersInventoryIdGet(ctx context.Context, id string) ComputerInventoryAPIV1ComputersInventoryIdGetRequest {
	return ComputerInventoryAPIV1ComputersInventoryIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ComputerInventory
func (a *ComputerInventoryAPIService) V1ComputersInventoryIdGetExecute(r ComputerInventoryAPIV1ComputersInventoryIdGetRequest) (*ComputerInventory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComputerInventory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerInventoryAPIService.V1ComputersInventoryIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/computers-inventory/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.section != nil {
		t := *r.section
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "section", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "section", t, "multi")
		}
	} else {
		defaultValue := []ComputerSection{"GENERAL"}
		r.section = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ComputerInventoryAPIV1ComputersInventoryIdViewRecoveryLockPasswordGetRequest struct {
	ctx context.Context
	ApiService ComputerInventoryAPI
	id string
}

func (r ComputerInventoryAPIV1ComputersInventoryIdViewRecoveryLockPasswordGetRequest) Execute() (*ComputerInventoryRecoveryLockPasswordResponse, *http.Response, error) {
	return r.ApiService.V1ComputersInventoryIdViewRecoveryLockPasswordGetExecute(r)
}

/*
V1ComputersInventoryIdViewRecoveryLockPasswordGet Return a Computers Recovery Lock Password

Return a Computers Recovery Lock Password

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id instance id of computer record
 @return ComputerInventoryAPIV1ComputersInventoryIdViewRecoveryLockPasswordGetRequest
*/
func (a *ComputerInventoryAPIService) V1ComputersInventoryIdViewRecoveryLockPasswordGet(ctx context.Context, id string) ComputerInventoryAPIV1ComputersInventoryIdViewRecoveryLockPasswordGetRequest {
	return ComputerInventoryAPIV1ComputersInventoryIdViewRecoveryLockPasswordGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ComputerInventoryRecoveryLockPasswordResponse
func (a *ComputerInventoryAPIService) V1ComputersInventoryIdViewRecoveryLockPasswordGetExecute(r ComputerInventoryAPIV1ComputersInventoryIdViewRecoveryLockPasswordGetRequest) (*ComputerInventoryRecoveryLockPasswordResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComputerInventoryRecoveryLockPasswordResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerInventoryAPIService.V1ComputersInventoryIdViewRecoveryLockPasswordGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/computers-inventory/{id}/view-recovery-lock-password"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
