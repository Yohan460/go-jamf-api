/*
Jamf Pro API

## Overview The Jamf Pro API is a RESTful API for Jamf Pro built to enable consistent and efficient programmatic access to Jamf Pro.<br/><br/> The swagger schema can be found [here](/api/schema/). 

API version: production
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"os"
)


type ComputerInventoryApi interface {

	/*
	V1ComputersInventoryDetailIdGet Return a Computer details with all sections 

	Return a Computer details with all sections

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id instance id of computer record
	@return ApiV1ComputersInventoryDetailIdGetRequest
	*/
	V1ComputersInventoryDetailIdGet(ctx context.Context, id string) ApiV1ComputersInventoryDetailIdGetRequest

	// V1ComputersInventoryDetailIdGetExecute executes the request
	//  @return ComputerInventoryResponse
	V1ComputersInventoryDetailIdGetExecute(r ApiV1ComputersInventoryDetailIdGetRequest) (*ComputerInventoryResponse, *http.Response, error)

	/*
	V1ComputersInventoryDetailIdPatch Return a updated computer instance 

	Return a updated computer instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id instance id of computer record
	@return ApiV1ComputersInventoryDetailIdPatchRequest
	*/
	V1ComputersInventoryDetailIdPatch(ctx context.Context, id string) ApiV1ComputersInventoryDetailIdPatchRequest

	// V1ComputersInventoryDetailIdPatchExecute executes the request
	//  @return ComputerInventoryResponse
	V1ComputersInventoryDetailIdPatchExecute(r ApiV1ComputersInventoryDetailIdPatchRequest) (*ComputerInventoryResponse, *http.Response, error)

	/*
	V1ComputersInventoryGet Return a Computer Inventory for paginated list of computers 

	Return a Computer Inventory for paginated list of computers

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV1ComputersInventoryGetRequest
	*/
	V1ComputersInventoryGet(ctx context.Context) ApiV1ComputersInventoryGetRequest

	// V1ComputersInventoryGetExecute executes the request
	//  @return ComputerInventorySearchResults
	V1ComputersInventoryGetExecute(r ApiV1ComputersInventoryGetRequest) (*ComputerInventorySearchResults, *http.Response, error)

	/*
	V1ComputersInventoryIdAttachmentsAttachmentIdDelete Remove attachment 

	Remove attachment

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id instance id of computer record
	@param attachmentId instance id of attachment object
	@return ApiV1ComputersInventoryIdAttachmentsAttachmentIdDeleteRequest
	*/
	V1ComputersInventoryIdAttachmentsAttachmentIdDelete(ctx context.Context, id string, attachmentId string) ApiV1ComputersInventoryIdAttachmentsAttachmentIdDeleteRequest

	// V1ComputersInventoryIdAttachmentsAttachmentIdDeleteExecute executes the request
	V1ComputersInventoryIdAttachmentsAttachmentIdDeleteExecute(r ApiV1ComputersInventoryIdAttachmentsAttachmentIdDeleteRequest) (*http.Response, error)

	/*
	V1ComputersInventoryIdAttachmentsAttachmentIdGet Download attachment file 

	Download attachment file

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id instance id of computer record
	@param attachmentId instance id of attachment object
	@return ApiV1ComputersInventoryIdAttachmentsAttachmentIdGetRequest
	*/
	V1ComputersInventoryIdAttachmentsAttachmentIdGet(ctx context.Context, id string, attachmentId string) ApiV1ComputersInventoryIdAttachmentsAttachmentIdGetRequest

	// V1ComputersInventoryIdAttachmentsAttachmentIdGetExecute executes the request
	//  @return *os.File
	V1ComputersInventoryIdAttachmentsAttachmentIdGetExecute(r ApiV1ComputersInventoryIdAttachmentsAttachmentIdGetRequest) (**os.File, *http.Response, error)

	/*
	V1ComputersInventoryIdAttachmentsPost Upload attachment and assign to computer 

	Upload attachment and assign to computer

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id instance id of computer record
	@return ApiV1ComputersInventoryIdAttachmentsPostRequest
	*/
	V1ComputersInventoryIdAttachmentsPost(ctx context.Context, id string) ApiV1ComputersInventoryIdAttachmentsPostRequest

	// V1ComputersInventoryIdAttachmentsPostExecute executes the request
	//  @return HrefResponse
	V1ComputersInventoryIdAttachmentsPostExecute(r ApiV1ComputersInventoryIdAttachmentsPostRequest) (*HrefResponse, *http.Response, error)

	/*
	V1ComputersInventoryIdDelete Remove specified Computer record 

	Remove specified Computer record

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id instance id of computer record
	@return ApiV1ComputersInventoryIdDeleteRequest
	*/
	V1ComputersInventoryIdDelete(ctx context.Context, id string) ApiV1ComputersInventoryIdDeleteRequest

	// V1ComputersInventoryIdDeleteExecute executes the request
	V1ComputersInventoryIdDeleteExecute(r ApiV1ComputersInventoryIdDeleteRequest) (*http.Response, error)

	/*
	V1ComputersInventoryIdGet Return a Computer General details 

	Return a Computer General details

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id instance id of computer record
	@return ApiV1ComputersInventoryIdGetRequest
	*/
	V1ComputersInventoryIdGet(ctx context.Context, id string) ApiV1ComputersInventoryIdGetRequest

	// V1ComputersInventoryIdGetExecute executes the request
	//  @return ComputerInventoryResponse
	V1ComputersInventoryIdGetExecute(r ApiV1ComputersInventoryIdGetRequest) (*ComputerInventoryResponse, *http.Response, error)

	/*
	V1ComputersInventoryIdViewRecoveryLockPasswordGet Return a Computers Recovery Lock Password 

	Return a Computers Recovery Lock Password

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id instance id of computer record
	@return ApiV1ComputersInventoryIdViewRecoveryLockPasswordGetRequest
	*/
	V1ComputersInventoryIdViewRecoveryLockPasswordGet(ctx context.Context, id string) ApiV1ComputersInventoryIdViewRecoveryLockPasswordGetRequest

	// V1ComputersInventoryIdViewRecoveryLockPasswordGetExecute executes the request
	//  @return ComputerInventoryRecoveryLockPasswordResponse
	V1ComputersInventoryIdViewRecoveryLockPasswordGetExecute(r ApiV1ComputersInventoryIdViewRecoveryLockPasswordGetRequest) (*ComputerInventoryRecoveryLockPasswordResponse, *http.Response, error)
}

// ComputerInventoryApiService ComputerInventoryApi service
type ComputerInventoryApiService service

type ApiV1ComputersInventoryDetailIdGetRequest struct {
	ctx context.Context
	ApiService ComputerInventoryApi
	id string
}

func (r ApiV1ComputersInventoryDetailIdGetRequest) Execute() (*ComputerInventoryResponse, *http.Response, error) {
	return r.ApiService.V1ComputersInventoryDetailIdGetExecute(r)
}

/*
V1ComputersInventoryDetailIdGet Return a Computer details with all sections 

Return a Computer details with all sections

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id instance id of computer record
 @return ApiV1ComputersInventoryDetailIdGetRequest
*/
func (a *ComputerInventoryApiService) V1ComputersInventoryDetailIdGet(ctx context.Context, id string) ApiV1ComputersInventoryDetailIdGetRequest {
	return ApiV1ComputersInventoryDetailIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ComputerInventoryResponse
func (a *ComputerInventoryApiService) V1ComputersInventoryDetailIdGetExecute(r ApiV1ComputersInventoryDetailIdGetRequest) (*ComputerInventoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComputerInventoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerInventoryApiService.V1ComputersInventoryDetailIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/computers-inventory-detail/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ComputersInventoryDetailIdPatchRequest struct {
	ctx context.Context
	ApiService ComputerInventoryApi
	id string
	computerInventoryUpdateRequest *ComputerInventoryUpdateRequest
}

func (r ApiV1ComputersInventoryDetailIdPatchRequest) ComputerInventoryUpdateRequest(computerInventoryUpdateRequest ComputerInventoryUpdateRequest) ApiV1ComputersInventoryDetailIdPatchRequest {
	r.computerInventoryUpdateRequest = &computerInventoryUpdateRequest
	return r
}

func (r ApiV1ComputersInventoryDetailIdPatchRequest) Execute() (*ComputerInventoryResponse, *http.Response, error) {
	return r.ApiService.V1ComputersInventoryDetailIdPatchExecute(r)
}

/*
V1ComputersInventoryDetailIdPatch Return a updated computer instance 

Return a updated computer instance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id instance id of computer record
 @return ApiV1ComputersInventoryDetailIdPatchRequest
*/
func (a *ComputerInventoryApiService) V1ComputersInventoryDetailIdPatch(ctx context.Context, id string) ApiV1ComputersInventoryDetailIdPatchRequest {
	return ApiV1ComputersInventoryDetailIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ComputerInventoryResponse
func (a *ComputerInventoryApiService) V1ComputersInventoryDetailIdPatchExecute(r ApiV1ComputersInventoryDetailIdPatchRequest) (*ComputerInventoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComputerInventoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerInventoryApiService.V1ComputersInventoryDetailIdPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/computers-inventory-detail/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.computerInventoryUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("computerInventoryUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.computerInventoryUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ComputersInventoryGetRequest struct {
	ctx context.Context
	ApiService ComputerInventoryApi
	section *[]ComputerSection
	page *int32
	pageSize *int32
	sort *[]string
	filter *string
}

// section of computer details, if not specified, General section data is returned. Multiple section parameters are supported, e.g. section&#x3D;GENERAL&amp;section&#x3D;HARDWARE
func (r ApiV1ComputersInventoryGetRequest) Section(section []ComputerSection) ApiV1ComputersInventoryGetRequest {
	r.section = &section
	return r
}

func (r ApiV1ComputersInventoryGetRequest) Page(page int32) ApiV1ComputersInventoryGetRequest {
	r.page = &page
	return r
}

func (r ApiV1ComputersInventoryGetRequest) PageSize(pageSize int32) ApiV1ComputersInventoryGetRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: &#x60;property:asc/desc&#x60;. Default sort is &#x60;general.name:asc&#x60;. Multiple sort criteria are supported and must be separated with a comma.  Fields allowed in the sort: &#x60;general.name&#x60;, &#x60;udid&#x60;, &#x60;id&#x60;, &#x60;general.assetTag&#x60;, &#x60;general.jamfBinaryVersion&#x60;, &#x60;general.lastContactTime&#x60;, &#x60;general.lastEnrolledDate&#x60;, &#x60;general.lastCloudBackupDate&#x60;, &#x60;general.reportDate&#x60;, &#x60;general.remoteManagement.managementUsername&#x60;, &#x60;general.mdmCertificateExpiration&#x60;, &#x60;general.platform&#x60;, &#x60;hardware.make&#x60;, &#x60;hardware.model&#x60;, &#x60;operatingSystem.build&#x60;, &#x60;operatingSystem.name&#x60;, &#x60;operatingSystem.version&#x60;, &#x60;userAndLocation.realname&#x60;, &#x60;purchasing.lifeExpectancy&#x60;, &#x60;purchasing.warrantyDate&#x60;  Example: &#x60;sort&#x3D;udid:desc,general.name:asc&#x60;. 
func (r ApiV1ComputersInventoryGetRequest) Sort(sort []string) ApiV1ComputersInventoryGetRequest {
	r.sort = &sort
	return r
}

// Query in the RSQL format, allowing to filter computer inventory collection. Default filter is empty query - returning all results for the requested page.  Fields allowed in the query: &#x60;general.name&#x60;, &#x60;udid&#x60;, &#x60;id&#x60;, &#x60;general.assetTag&#x60;, &#x60;general.barcode1&#x60;, &#x60;general.barcode2&#x60;, &#x60;general.enrolledViaAutomatedDeviceEnrollment&#x60;, &#x60;general.lastIpAddress&#x60;, &#x60;general.itunesStoreAccountActive&#x60;, &#x60;general.jamfBinaryVersion&#x60;, &#x60;general.lastContactTime&#x60;, &#x60;general.lastEnrolledDate&#x60;, &#x60;general.lastCloudBackupDate&#x60;, &#x60;general.reportDate&#x60;, &#x60;general.lastReportedIp&#x60;, &#x60;general.remoteManagement.managed&#x60;, &#x60;general.remoteManagement.managementUsername&#x60;, &#x60;general.mdmCapable.capable&#x60;, &#x60;general.mdmCertificateExpiration&#x60;, &#x60;general.platform&#x60;, &#x60;general.supervised&#x60;, &#x60;general.userApprovedMdm&#x60;, &#x60;hardware.bleCapable&#x60;, &#x60;hardware.macAddress&#x60;, &#x60;hardware.make&#x60;, &#x60;hardware.model&#x60;, &#x60;hardware.modelIdentifier&#x60;, &#x60;hardware.serialNumber&#x60;, &#x60;hardware.supportsIosAppInstalls&#x60;,&#x60;hardware.isAppleSilicon&#x60;, &#x60;operatingSystem.activeDirectoryStatus&#x60;, &#x60;operatingSystem.fileVault2Status&#x60;, &#x60;operatingSystem.build&#x60;, &#x60;operatingSystem.name&#x60;, &#x60;operatingSystem.version&#x60;, &#x60;operatingSystem.softwareUpdateDeviceId&#x60;, &#x60;security.activationLockEnabled&#x60;, &#x60;security.recoveryLockEnabled&#x60;,&#x60;security.firewallEnabled&#x60;,&#x60;userAndLocation.buildingId&#x60;, &#x60;userAndLocation.departmentId&#x60;, &#x60;userAndLocation.email&#x60;, &#x60;userAndLocation.realname&#x60;, &#x60;userAndLocation.phone&#x60;, &#x60;userAndLocation.position&#x60;,&#x60;userAndLocation.room&#x60;, &#x60;userAndLocation.username&#x60;, &#x60;purchasing.appleCareId&#x60;, &#x60;purchasing.lifeExpectancy&#x60;, &#x60;purchasing.purchased&#x60;, &#x60;purchasing.leased&#x60;, &#x60;purchasing.vendor&#x60;, &#x60;purchasing.warrantyDate&#x60;,  This param can be combined with paging and sorting. Example: &#x60;filter&#x3D;general.name&#x3D;&#x3D;\&quot;Orchard\&quot;&#x60; 
func (r ApiV1ComputersInventoryGetRequest) Filter(filter string) ApiV1ComputersInventoryGetRequest {
	r.filter = &filter
	return r
}

func (r ApiV1ComputersInventoryGetRequest) Execute() (*ComputerInventorySearchResults, *http.Response, error) {
	return r.ApiService.V1ComputersInventoryGetExecute(r)
}

/*
V1ComputersInventoryGet Return a Computer Inventory for paginated list of computers 

Return a Computer Inventory for paginated list of computers

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ComputersInventoryGetRequest
*/
func (a *ComputerInventoryApiService) V1ComputersInventoryGet(ctx context.Context) ApiV1ComputersInventoryGetRequest {
	return ApiV1ComputersInventoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComputerInventorySearchResults
func (a *ComputerInventoryApiService) V1ComputersInventoryGetExecute(r ApiV1ComputersInventoryGetRequest) (*ComputerInventorySearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComputerInventorySearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerInventoryApiService.V1ComputersInventoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/computers-inventory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.section != nil {
		t := *r.section
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("section", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("section", parameterToString(t, "multi"))
		}
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page-size", parameterToString(*r.pageSize, ""))
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sort", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sort", parameterToString(t, "multi"))
		}
	}
	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ComputersInventoryIdAttachmentsAttachmentIdDeleteRequest struct {
	ctx context.Context
	ApiService ComputerInventoryApi
	id string
	attachmentId string
}

func (r ApiV1ComputersInventoryIdAttachmentsAttachmentIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1ComputersInventoryIdAttachmentsAttachmentIdDeleteExecute(r)
}

/*
V1ComputersInventoryIdAttachmentsAttachmentIdDelete Remove attachment 

Remove attachment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id instance id of computer record
 @param attachmentId instance id of attachment object
 @return ApiV1ComputersInventoryIdAttachmentsAttachmentIdDeleteRequest
*/
func (a *ComputerInventoryApiService) V1ComputersInventoryIdAttachmentsAttachmentIdDelete(ctx context.Context, id string, attachmentId string) ApiV1ComputersInventoryIdAttachmentsAttachmentIdDeleteRequest {
	return ApiV1ComputersInventoryIdAttachmentsAttachmentIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *ComputerInventoryApiService) V1ComputersInventoryIdAttachmentsAttachmentIdDeleteExecute(r ApiV1ComputersInventoryIdAttachmentsAttachmentIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerInventoryApiService.V1ComputersInventoryIdAttachmentsAttachmentIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/computers-inventory/{id}/attachments/{attachmentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachmentId"+"}", url.PathEscape(parameterToString(r.attachmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1ComputersInventoryIdAttachmentsAttachmentIdGetRequest struct {
	ctx context.Context
	ApiService ComputerInventoryApi
	id string
	attachmentId string
}

func (r ApiV1ComputersInventoryIdAttachmentsAttachmentIdGetRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.V1ComputersInventoryIdAttachmentsAttachmentIdGetExecute(r)
}

/*
V1ComputersInventoryIdAttachmentsAttachmentIdGet Download attachment file 

Download attachment file

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id instance id of computer record
 @param attachmentId instance id of attachment object
 @return ApiV1ComputersInventoryIdAttachmentsAttachmentIdGetRequest
*/
func (a *ComputerInventoryApiService) V1ComputersInventoryIdAttachmentsAttachmentIdGet(ctx context.Context, id string, attachmentId string) ApiV1ComputersInventoryIdAttachmentsAttachmentIdGetRequest {
	return ApiV1ComputersInventoryIdAttachmentsAttachmentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ComputerInventoryApiService) V1ComputersInventoryIdAttachmentsAttachmentIdGetExecute(r ApiV1ComputersInventoryIdAttachmentsAttachmentIdGetRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerInventoryApiService.V1ComputersInventoryIdAttachmentsAttachmentIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/computers-inventory/{id}/attachments/{attachmentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachmentId"+"}", url.PathEscape(parameterToString(r.attachmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ComputersInventoryIdAttachmentsPostRequest struct {
	ctx context.Context
	ApiService ComputerInventoryApi
	id string
	file **os.File
}

// The file to upload
func (r ApiV1ComputersInventoryIdAttachmentsPostRequest) File(file *os.File) ApiV1ComputersInventoryIdAttachmentsPostRequest {
	r.file = &file
	return r
}

func (r ApiV1ComputersInventoryIdAttachmentsPostRequest) Execute() (*HrefResponse, *http.Response, error) {
	return r.ApiService.V1ComputersInventoryIdAttachmentsPostExecute(r)
}

/*
V1ComputersInventoryIdAttachmentsPost Upload attachment and assign to computer 

Upload attachment and assign to computer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id instance id of computer record
 @return ApiV1ComputersInventoryIdAttachmentsPostRequest
*/
func (a *ComputerInventoryApiService) V1ComputersInventoryIdAttachmentsPost(ctx context.Context, id string) ApiV1ComputersInventoryIdAttachmentsPostRequest {
	return ApiV1ComputersInventoryIdAttachmentsPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return HrefResponse
func (a *ComputerInventoryApiService) V1ComputersInventoryIdAttachmentsPostExecute(r ApiV1ComputersInventoryIdAttachmentsPostRequest) (*HrefResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HrefResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerInventoryApiService.V1ComputersInventoryIdAttachmentsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/computers-inventory/{id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.file == nil {
		return localVarReturnValue, nil, reportError("file is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "file"

	fileLocalVarFile := *r.file
	if fileLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(fileLocalVarFile)
		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ComputersInventoryIdDeleteRequest struct {
	ctx context.Context
	ApiService ComputerInventoryApi
	id string
}

func (r ApiV1ComputersInventoryIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1ComputersInventoryIdDeleteExecute(r)
}

/*
V1ComputersInventoryIdDelete Remove specified Computer record 

Remove specified Computer record

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id instance id of computer record
 @return ApiV1ComputersInventoryIdDeleteRequest
*/
func (a *ComputerInventoryApiService) V1ComputersInventoryIdDelete(ctx context.Context, id string) ApiV1ComputersInventoryIdDeleteRequest {
	return ApiV1ComputersInventoryIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ComputerInventoryApiService) V1ComputersInventoryIdDeleteExecute(r ApiV1ComputersInventoryIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerInventoryApiService.V1ComputersInventoryIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/computers-inventory/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1ComputersInventoryIdGetRequest struct {
	ctx context.Context
	ApiService ComputerInventoryApi
	id string
	section *[]ComputerSection
}

// section of computer details, if not specified, General section data is returned. Multiple section parameters are supported, e.g. section&#x3D;general&amp;section&#x3D;hardware
func (r ApiV1ComputersInventoryIdGetRequest) Section(section []ComputerSection) ApiV1ComputersInventoryIdGetRequest {
	r.section = &section
	return r
}

func (r ApiV1ComputersInventoryIdGetRequest) Execute() (*ComputerInventoryResponse, *http.Response, error) {
	return r.ApiService.V1ComputersInventoryIdGetExecute(r)
}

/*
V1ComputersInventoryIdGet Return a Computer General details 

Return a Computer General details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id instance id of computer record
 @return ApiV1ComputersInventoryIdGetRequest
*/
func (a *ComputerInventoryApiService) V1ComputersInventoryIdGet(ctx context.Context, id string) ApiV1ComputersInventoryIdGetRequest {
	return ApiV1ComputersInventoryIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ComputerInventoryResponse
func (a *ComputerInventoryApiService) V1ComputersInventoryIdGetExecute(r ApiV1ComputersInventoryIdGetRequest) (*ComputerInventoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComputerInventoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerInventoryApiService.V1ComputersInventoryIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/computers-inventory/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.section != nil {
		t := *r.section
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("section", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("section", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ComputersInventoryIdViewRecoveryLockPasswordGetRequest struct {
	ctx context.Context
	ApiService ComputerInventoryApi
	id string
}

func (r ApiV1ComputersInventoryIdViewRecoveryLockPasswordGetRequest) Execute() (*ComputerInventoryRecoveryLockPasswordResponse, *http.Response, error) {
	return r.ApiService.V1ComputersInventoryIdViewRecoveryLockPasswordGetExecute(r)
}

/*
V1ComputersInventoryIdViewRecoveryLockPasswordGet Return a Computers Recovery Lock Password 

Return a Computers Recovery Lock Password

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id instance id of computer record
 @return ApiV1ComputersInventoryIdViewRecoveryLockPasswordGetRequest
*/
func (a *ComputerInventoryApiService) V1ComputersInventoryIdViewRecoveryLockPasswordGet(ctx context.Context, id string) ApiV1ComputersInventoryIdViewRecoveryLockPasswordGetRequest {
	return ApiV1ComputersInventoryIdViewRecoveryLockPasswordGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ComputerInventoryRecoveryLockPasswordResponse
func (a *ComputerInventoryApiService) V1ComputersInventoryIdViewRecoveryLockPasswordGetExecute(r ApiV1ComputersInventoryIdViewRecoveryLockPasswordGetRequest) (*ComputerInventoryRecoveryLockPasswordResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComputerInventoryRecoveryLockPasswordResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputerInventoryApiService.V1ComputersInventoryIdViewRecoveryLockPasswordGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/computers-inventory/{id}/view-recovery-lock-password"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
