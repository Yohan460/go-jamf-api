/*
Jamf Pro API

## Overview The Jamf Pro API is a RESTful API for Jamf Pro built to enable consistent and efficient programmatic access to Jamf Pro.<br/><br/> The swagger schema can be found [here](/api/schema/). 

API version: production
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


type PatchesPreviewApi interface {

	/*
	PatchDisclaimerAgreePost Accept Patch reporting disclaimer 

	Accept Patch reporting disclaimer

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPatchDisclaimerAgreePostRequest
	*/
	PatchDisclaimerAgreePost(ctx context.Context) ApiPatchDisclaimerAgreePostRequest

	// PatchDisclaimerAgreePostExecute executes the request
	PatchDisclaimerAgreePostExecute(r ApiPatchDisclaimerAgreePostRequest) (*http.Response, error)

	/*
	PatchObjIdGet Return Active Patch Summary 

	Returns active patch summary.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id patch id
	@return ApiPatchObjIdGetRequest
	*/
	PatchObjIdGet(ctx context.Context, id int32) ApiPatchObjIdGetRequest

	// PatchObjIdGetExecute executes the request
	//  @return ActivePatchSummary
	PatchObjIdGetExecute(r ApiPatchObjIdGetRequest) (*ActivePatchSummary, *http.Response, error)

	/*
	PatchObjIdPut Update patch report 

	Updates patch report.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id patch id
	@return ApiPatchObjIdPutRequest
	*/
	PatchObjIdPut(ctx context.Context, id int32) ApiPatchObjIdPutRequest

	// PatchObjIdPutExecute executes the request
	//  @return ActivePatchSummary
	PatchObjIdPutExecute(r ApiPatchObjIdPutRequest) (*ActivePatchSummary, *http.Response, error)

	/*
	PatchObjIdVersionsGet Return patch versions 

	Returns patch versions.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id patch id
	@return ApiPatchObjIdVersionsGetRequest
	*/
	PatchObjIdVersionsGet(ctx context.Context, id int32) ApiPatchObjIdVersionsGetRequest

	// PatchObjIdVersionsGetExecute executes the request
	//  @return []PatchVersion
	PatchObjIdVersionsGetExecute(r ApiPatchObjIdVersionsGetRequest) ([]PatchVersion, *http.Response, error)

	/*
	PatchObjPolicyIdLogsEligibleRetryCountGet Return the count of the Patch Policy Logs for the policy is that are eligible for a retry attempt 

	return the count of the patch policy logs for the policy ID that are eligible for a retry attempt

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id policy id
	@return ApiPatchObjPolicyIdLogsEligibleRetryCountGetRequest
	*/
	PatchObjPolicyIdLogsEligibleRetryCountGet(ctx context.Context, id int32) ApiPatchObjPolicyIdLogsEligibleRetryCountGetRequest

	// PatchObjPolicyIdLogsEligibleRetryCountGetExecute executes the request
	//  @return int32
	PatchObjPolicyIdLogsEligibleRetryCountGetExecute(r ApiPatchObjPolicyIdLogsEligibleRetryCountGetRequest) (int32, *http.Response, error)

	/*
	PatchObjPolicyIdSoftwareTitleConfigurationIdGet Return the Software Title Configuration Id for the given patch 

	Return the Software Title Configuration Id for the given patch policy.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id policy id
	@return ApiPatchObjPolicyIdSoftwareTitleConfigurationIdGetRequest
	*/
	PatchObjPolicyIdSoftwareTitleConfigurationIdGet(ctx context.Context, id int32) ApiPatchObjPolicyIdSoftwareTitleConfigurationIdGetRequest

	// PatchObjPolicyIdSoftwareTitleConfigurationIdGetExecute executes the request
	//  @return int32
	PatchObjPolicyIdSoftwareTitleConfigurationIdGetExecute(r ApiPatchObjPolicyIdSoftwareTitleConfigurationIdGetRequest) (int32, *http.Response, error)

	/*
	PatchObjSoftwareTitleConfigurationIdGet Return the Software Title Configuration 

	Returns the software title configuration.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id software title configuration id
	@return ApiPatchObjSoftwareTitleConfigurationIdGetRequest
	*/
	PatchObjSoftwareTitleConfigurationIdGet(ctx context.Context, id int32) ApiPatchObjSoftwareTitleConfigurationIdGetRequest

	// PatchObjSoftwareTitleConfigurationIdGetExecute executes the request
	//  @return SoftwareTitleConfiguration
	PatchObjSoftwareTitleConfigurationIdGetExecute(r ApiPatchObjSoftwareTitleConfigurationIdGetRequest) (*SoftwareTitleConfiguration, *http.Response, error)

	/*
	PatchObjSoftwareTitleIdPoliciesGet Return the Summaries of the Patch Policies for the software title 

	Returns the summaries of the patch policies for the software title.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id software title id
	@return ApiPatchObjSoftwareTitleIdPoliciesGetRequest
	*/
	PatchObjSoftwareTitleIdPoliciesGet(ctx context.Context, id int32) ApiPatchObjSoftwareTitleIdPoliciesGetRequest

	// PatchObjSoftwareTitleIdPoliciesGetExecute executes the request
	//  @return SoftwareTitlePatchPolicySummaries
	PatchObjSoftwareTitleIdPoliciesGetExecute(r ApiPatchObjSoftwareTitleIdPoliciesGetRequest) (*SoftwareTitlePatchPolicySummaries, *http.Response, error)

	/*
	PatchObjsPolicyIdGet Return Patch Policy Summary 

	Returns patch policy summary.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id patch policy id
	@return ApiPatchObjsPolicyIdGetRequest
	*/
	PatchObjsPolicyIdGet(ctx context.Context, id int32) ApiPatchObjsPolicyIdGetRequest

	// PatchObjsPolicyIdGetExecute executes the request
	//  @return PatchPolicySummary
	PatchObjsPolicyIdGetExecute(r ApiPatchObjsPolicyIdGetRequest) (*PatchPolicySummary, *http.Response, error)

	/*
	PatchOnDashboardGet Return list of Patch ids on dashboard 

	Returns list of patch ids on dashboard.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPatchOnDashboardGetRequest
	*/
	PatchOnDashboardGet(ctx context.Context) ApiPatchOnDashboardGetRequest

	// PatchOnDashboardGetExecute executes the request
	//  @return []int32
	PatchOnDashboardGetExecute(r ApiPatchOnDashboardGetRequest) ([]int32, *http.Response, error)

	/*
	PatchRetryPolicyPost Retry policy 

	Retry policy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPatchRetryPolicyPostRequest
	*/
	PatchRetryPolicyPost(ctx context.Context) ApiPatchRetryPolicyPostRequest

	// PatchRetryPolicyPostExecute executes the request
	PatchRetryPolicyPostExecute(r ApiPatchRetryPolicyPostRequest) (*http.Response, error)

	/*
	PatchSearchActivePatchHistoryPost Search the history for a Specific Active Patch 

	Searches the history for a specific active patch.  This is used to get detailed information about the computers/devices that a specific patch has been applied to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPatchSearchActivePatchHistoryPostRequest
	*/
	PatchSearchActivePatchHistoryPost(ctx context.Context) ApiPatchSearchActivePatchHistoryPostRequest

	// PatchSearchActivePatchHistoryPostExecute executes the request
	//  @return ActivePatchHistorySearchResults
	PatchSearchActivePatchHistoryPostExecute(r ApiPatchSearchActivePatchHistoryPostRequest) (*ActivePatchHistorySearchResults, *http.Response, error)

	/*
	PatchSearchPatchPolicyLogsPost Return Patch Policy Logs 

	Return patch policy logs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPatchSearchPatchPolicyLogsPostRequest
	*/
	PatchSearchPatchPolicyLogsPost(ctx context.Context) ApiPatchSearchPatchPolicyLogsPostRequest

	// PatchSearchPatchPolicyLogsPostExecute executes the request
	//  @return PatchPolicyLogSearchResults
	PatchSearchPatchPolicyLogsPostExecute(r ApiPatchSearchPatchPolicyLogsPostRequest) (*PatchPolicyLogSearchResults, *http.Response, error)

	/*
	PatchSvcRetryPolicyPost Retry policy 

	Retry policy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPatchSvcRetryPolicyPostRequest
	*/
	PatchSvcRetryPolicyPost(ctx context.Context) ApiPatchSvcRetryPolicyPostRequest

	// PatchSvcRetryPolicyPostExecute executes the request
	PatchSvcRetryPolicyPostExecute(r ApiPatchSvcRetryPolicyPostRequest) (*http.Response, error)
}

// PatchesPreviewApiService PatchesPreviewApi service
type PatchesPreviewApiService service

type ApiPatchDisclaimerAgreePostRequest struct {
	ctx context.Context
	ApiService PatchesPreviewApi
}

func (r ApiPatchDisclaimerAgreePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.PatchDisclaimerAgreePostExecute(r)
}

/*
PatchDisclaimerAgreePost Accept Patch reporting disclaimer 

Accept Patch reporting disclaimer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPatchDisclaimerAgreePostRequest
*/
func (a *PatchesPreviewApiService) PatchDisclaimerAgreePost(ctx context.Context) ApiPatchDisclaimerAgreePostRequest {
	return ApiPatchDisclaimerAgreePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PatchesPreviewApiService) PatchDisclaimerAgreePostExecute(r ApiPatchDisclaimerAgreePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PatchesPreviewApiService.PatchDisclaimerAgreePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/patch/disclaimerAgree"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPatchObjIdGetRequest struct {
	ctx context.Context
	ApiService PatchesPreviewApi
	id int32
}

func (r ApiPatchObjIdGetRequest) Execute() (*ActivePatchSummary, *http.Response, error) {
	return r.ApiService.PatchObjIdGetExecute(r)
}

/*
PatchObjIdGet Return Active Patch Summary 

Returns active patch summary.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id patch id
 @return ApiPatchObjIdGetRequest
*/
func (a *PatchesPreviewApiService) PatchObjIdGet(ctx context.Context, id int32) ApiPatchObjIdGetRequest {
	return ApiPatchObjIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ActivePatchSummary
func (a *PatchesPreviewApiService) PatchObjIdGetExecute(r ApiPatchObjIdGetRequest) (*ActivePatchSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActivePatchSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PatchesPreviewApiService.PatchObjIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/patch/obj/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchObjIdPutRequest struct {
	ctx context.Context
	ApiService PatchesPreviewApi
	id int32
	activePatchSummary *ActivePatchSummary
}

// Active patch summary.
func (r ApiPatchObjIdPutRequest) ActivePatchSummary(activePatchSummary ActivePatchSummary) ApiPatchObjIdPutRequest {
	r.activePatchSummary = &activePatchSummary
	return r
}

func (r ApiPatchObjIdPutRequest) Execute() (*ActivePatchSummary, *http.Response, error) {
	return r.ApiService.PatchObjIdPutExecute(r)
}

/*
PatchObjIdPut Update patch report 

Updates patch report.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id patch id
 @return ApiPatchObjIdPutRequest
*/
func (a *PatchesPreviewApiService) PatchObjIdPut(ctx context.Context, id int32) ApiPatchObjIdPutRequest {
	return ApiPatchObjIdPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ActivePatchSummary
func (a *PatchesPreviewApiService) PatchObjIdPutExecute(r ApiPatchObjIdPutRequest) (*ActivePatchSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActivePatchSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PatchesPreviewApiService.PatchObjIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/patch/obj/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.activePatchSummary == nil {
		return localVarReturnValue, nil, reportError("activePatchSummary is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.activePatchSummary
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchObjIdVersionsGetRequest struct {
	ctx context.Context
	ApiService PatchesPreviewApi
	id int32
}

func (r ApiPatchObjIdVersionsGetRequest) Execute() ([]PatchVersion, *http.Response, error) {
	return r.ApiService.PatchObjIdVersionsGetExecute(r)
}

/*
PatchObjIdVersionsGet Return patch versions 

Returns patch versions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id patch id
 @return ApiPatchObjIdVersionsGetRequest
*/
func (a *PatchesPreviewApiService) PatchObjIdVersionsGet(ctx context.Context, id int32) ApiPatchObjIdVersionsGetRequest {
	return ApiPatchObjIdVersionsGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []PatchVersion
func (a *PatchesPreviewApiService) PatchObjIdVersionsGetExecute(r ApiPatchObjIdVersionsGetRequest) ([]PatchVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PatchVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PatchesPreviewApiService.PatchObjIdVersionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/patch/obj/{id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchObjPolicyIdLogsEligibleRetryCountGetRequest struct {
	ctx context.Context
	ApiService PatchesPreviewApi
	id int32
}

func (r ApiPatchObjPolicyIdLogsEligibleRetryCountGetRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.PatchObjPolicyIdLogsEligibleRetryCountGetExecute(r)
}

/*
PatchObjPolicyIdLogsEligibleRetryCountGet Return the count of the Patch Policy Logs for the policy is that are eligible for a retry attempt 

return the count of the patch policy logs for the policy ID that are eligible for a retry attempt

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id policy id
 @return ApiPatchObjPolicyIdLogsEligibleRetryCountGetRequest
*/
func (a *PatchesPreviewApiService) PatchObjPolicyIdLogsEligibleRetryCountGet(ctx context.Context, id int32) ApiPatchObjPolicyIdLogsEligibleRetryCountGetRequest {
	return ApiPatchObjPolicyIdLogsEligibleRetryCountGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return int32
func (a *PatchesPreviewApiService) PatchObjPolicyIdLogsEligibleRetryCountGetExecute(r ApiPatchObjPolicyIdLogsEligibleRetryCountGetRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PatchesPreviewApiService.PatchObjPolicyIdLogsEligibleRetryCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/patch/obj/policy/{id}/logs/eligibleRetryCount"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchObjPolicyIdSoftwareTitleConfigurationIdGetRequest struct {
	ctx context.Context
	ApiService PatchesPreviewApi
	id int32
}

func (r ApiPatchObjPolicyIdSoftwareTitleConfigurationIdGetRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.PatchObjPolicyIdSoftwareTitleConfigurationIdGetExecute(r)
}

/*
PatchObjPolicyIdSoftwareTitleConfigurationIdGet Return the Software Title Configuration Id for the given patch 

Return the Software Title Configuration Id for the given patch policy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id policy id
 @return ApiPatchObjPolicyIdSoftwareTitleConfigurationIdGetRequest
*/
func (a *PatchesPreviewApiService) PatchObjPolicyIdSoftwareTitleConfigurationIdGet(ctx context.Context, id int32) ApiPatchObjPolicyIdSoftwareTitleConfigurationIdGetRequest {
	return ApiPatchObjPolicyIdSoftwareTitleConfigurationIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return int32
func (a *PatchesPreviewApiService) PatchObjPolicyIdSoftwareTitleConfigurationIdGetExecute(r ApiPatchObjPolicyIdSoftwareTitleConfigurationIdGetRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PatchesPreviewApiService.PatchObjPolicyIdSoftwareTitleConfigurationIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/patch/obj/policy/{id}/softwareTitleConfigurationId"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchObjSoftwareTitleConfigurationIdGetRequest struct {
	ctx context.Context
	ApiService PatchesPreviewApi
	id int32
}

func (r ApiPatchObjSoftwareTitleConfigurationIdGetRequest) Execute() (*SoftwareTitleConfiguration, *http.Response, error) {
	return r.ApiService.PatchObjSoftwareTitleConfigurationIdGetExecute(r)
}

/*
PatchObjSoftwareTitleConfigurationIdGet Return the Software Title Configuration 

Returns the software title configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id software title configuration id
 @return ApiPatchObjSoftwareTitleConfigurationIdGetRequest
*/
func (a *PatchesPreviewApiService) PatchObjSoftwareTitleConfigurationIdGet(ctx context.Context, id int32) ApiPatchObjSoftwareTitleConfigurationIdGetRequest {
	return ApiPatchObjSoftwareTitleConfigurationIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SoftwareTitleConfiguration
func (a *PatchesPreviewApiService) PatchObjSoftwareTitleConfigurationIdGetExecute(r ApiPatchObjSoftwareTitleConfigurationIdGetRequest) (*SoftwareTitleConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SoftwareTitleConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PatchesPreviewApiService.PatchObjSoftwareTitleConfigurationIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/patch/obj/softwareTitleConfiguration/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchObjSoftwareTitleIdPoliciesGetRequest struct {
	ctx context.Context
	ApiService PatchesPreviewApi
	id int32
}

func (r ApiPatchObjSoftwareTitleIdPoliciesGetRequest) Execute() (*SoftwareTitlePatchPolicySummaries, *http.Response, error) {
	return r.ApiService.PatchObjSoftwareTitleIdPoliciesGetExecute(r)
}

/*
PatchObjSoftwareTitleIdPoliciesGet Return the Summaries of the Patch Policies for the software title 

Returns the summaries of the patch policies for the software title.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id software title id
 @return ApiPatchObjSoftwareTitleIdPoliciesGetRequest
*/
func (a *PatchesPreviewApiService) PatchObjSoftwareTitleIdPoliciesGet(ctx context.Context, id int32) ApiPatchObjSoftwareTitleIdPoliciesGetRequest {
	return ApiPatchObjSoftwareTitleIdPoliciesGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SoftwareTitlePatchPolicySummaries
func (a *PatchesPreviewApiService) PatchObjSoftwareTitleIdPoliciesGetExecute(r ApiPatchObjSoftwareTitleIdPoliciesGetRequest) (*SoftwareTitlePatchPolicySummaries, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SoftwareTitlePatchPolicySummaries
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PatchesPreviewApiService.PatchObjSoftwareTitleIdPoliciesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/patch/obj/softwareTitle/{id}/policies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchObjsPolicyIdGetRequest struct {
	ctx context.Context
	ApiService PatchesPreviewApi
	id int32
}

func (r ApiPatchObjsPolicyIdGetRequest) Execute() (*PatchPolicySummary, *http.Response, error) {
	return r.ApiService.PatchObjsPolicyIdGetExecute(r)
}

/*
PatchObjsPolicyIdGet Return Patch Policy Summary 

Returns patch policy summary.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id patch policy id
 @return ApiPatchObjsPolicyIdGetRequest
*/
func (a *PatchesPreviewApiService) PatchObjsPolicyIdGet(ctx context.Context, id int32) ApiPatchObjsPolicyIdGetRequest {
	return ApiPatchObjsPolicyIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PatchPolicySummary
func (a *PatchesPreviewApiService) PatchObjsPolicyIdGetExecute(r ApiPatchObjsPolicyIdGetRequest) (*PatchPolicySummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PatchPolicySummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PatchesPreviewApiService.PatchObjsPolicyIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/patch/objs/policy/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchOnDashboardGetRequest struct {
	ctx context.Context
	ApiService PatchesPreviewApi
}

func (r ApiPatchOnDashboardGetRequest) Execute() ([]int32, *http.Response, error) {
	return r.ApiService.PatchOnDashboardGetExecute(r)
}

/*
PatchOnDashboardGet Return list of Patch ids on dashboard 

Returns list of patch ids on dashboard.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPatchOnDashboardGetRequest
*/
func (a *PatchesPreviewApiService) PatchOnDashboardGet(ctx context.Context) ApiPatchOnDashboardGetRequest {
	return ApiPatchOnDashboardGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []int32
func (a *PatchesPreviewApiService) PatchOnDashboardGetExecute(r ApiPatchOnDashboardGetRequest) ([]int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PatchesPreviewApiService.PatchOnDashboardGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/patch/onDashboard"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchRetryPolicyPostRequest struct {
	ctx context.Context
	ApiService PatchesPreviewApi
	retryPatchPolicyParams *RetryPatchPolicyParams
}

func (r ApiPatchRetryPolicyPostRequest) RetryPatchPolicyParams(retryPatchPolicyParams RetryPatchPolicyParams) ApiPatchRetryPolicyPostRequest {
	r.retryPatchPolicyParams = &retryPatchPolicyParams
	return r
}

func (r ApiPatchRetryPolicyPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.PatchRetryPolicyPostExecute(r)
}

/*
PatchRetryPolicyPost Retry policy 

Retry policy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPatchRetryPolicyPostRequest
*/
func (a *PatchesPreviewApiService) PatchRetryPolicyPost(ctx context.Context) ApiPatchRetryPolicyPostRequest {
	return ApiPatchRetryPolicyPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PatchesPreviewApiService) PatchRetryPolicyPostExecute(r ApiPatchRetryPolicyPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PatchesPreviewApiService.PatchRetryPolicyPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/patch/retryPolicy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.retryPatchPolicyParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPatchSearchActivePatchHistoryPostRequest struct {
	ctx context.Context
	ApiService PatchesPreviewApi
	searchActivePatchHistoryParams *SearchActivePatchHistoryParams
}

// Parameters for search
func (r ApiPatchSearchActivePatchHistoryPostRequest) SearchActivePatchHistoryParams(searchActivePatchHistoryParams SearchActivePatchHistoryParams) ApiPatchSearchActivePatchHistoryPostRequest {
	r.searchActivePatchHistoryParams = &searchActivePatchHistoryParams
	return r
}

func (r ApiPatchSearchActivePatchHistoryPostRequest) Execute() (*ActivePatchHistorySearchResults, *http.Response, error) {
	return r.ApiService.PatchSearchActivePatchHistoryPostExecute(r)
}

/*
PatchSearchActivePatchHistoryPost Search the history for a Specific Active Patch 

Searches the history for a specific active patch.  This is used to get detailed information about the computers/devices that a specific patch has been applied to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPatchSearchActivePatchHistoryPostRequest
*/
func (a *PatchesPreviewApiService) PatchSearchActivePatchHistoryPost(ctx context.Context) ApiPatchSearchActivePatchHistoryPostRequest {
	return ApiPatchSearchActivePatchHistoryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ActivePatchHistorySearchResults
func (a *PatchesPreviewApiService) PatchSearchActivePatchHistoryPostExecute(r ApiPatchSearchActivePatchHistoryPostRequest) (*ActivePatchHistorySearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActivePatchHistorySearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PatchesPreviewApiService.PatchSearchActivePatchHistoryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/patch/searchActivePatchHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.searchActivePatchHistoryParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchSearchPatchPolicyLogsPostRequest struct {
	ctx context.Context
	ApiService PatchesPreviewApi
	searchPatchPolicyLogParams *SearchPatchPolicyLogParams
}

func (r ApiPatchSearchPatchPolicyLogsPostRequest) SearchPatchPolicyLogParams(searchPatchPolicyLogParams SearchPatchPolicyLogParams) ApiPatchSearchPatchPolicyLogsPostRequest {
	r.searchPatchPolicyLogParams = &searchPatchPolicyLogParams
	return r
}

func (r ApiPatchSearchPatchPolicyLogsPostRequest) Execute() (*PatchPolicyLogSearchResults, *http.Response, error) {
	return r.ApiService.PatchSearchPatchPolicyLogsPostExecute(r)
}

/*
PatchSearchPatchPolicyLogsPost Return Patch Policy Logs 

Return patch policy logs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPatchSearchPatchPolicyLogsPostRequest
*/
func (a *PatchesPreviewApiService) PatchSearchPatchPolicyLogsPost(ctx context.Context) ApiPatchSearchPatchPolicyLogsPostRequest {
	return ApiPatchSearchPatchPolicyLogsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PatchPolicyLogSearchResults
func (a *PatchesPreviewApiService) PatchSearchPatchPolicyLogsPostExecute(r ApiPatchSearchPatchPolicyLogsPostRequest) (*PatchPolicyLogSearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PatchPolicyLogSearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PatchesPreviewApiService.PatchSearchPatchPolicyLogsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/patch/searchPatchPolicyLogs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.searchPatchPolicyLogParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchSvcRetryPolicyPostRequest struct {
	ctx context.Context
	ApiService PatchesPreviewApi
	retryPatchPolicyParams *RetryPatchPolicyParams
}

func (r ApiPatchSvcRetryPolicyPostRequest) RetryPatchPolicyParams(retryPatchPolicyParams RetryPatchPolicyParams) ApiPatchSvcRetryPolicyPostRequest {
	r.retryPatchPolicyParams = &retryPatchPolicyParams
	return r
}

func (r ApiPatchSvcRetryPolicyPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.PatchSvcRetryPolicyPostExecute(r)
}

/*
PatchSvcRetryPolicyPost Retry policy 

Retry policy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPatchSvcRetryPolicyPostRequest
*/
func (a *PatchesPreviewApiService) PatchSvcRetryPolicyPost(ctx context.Context) ApiPatchSvcRetryPolicyPostRequest {
	return ApiPatchSvcRetryPolicyPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PatchesPreviewApiService) PatchSvcRetryPolicyPostExecute(r ApiPatchSvcRetryPolicyPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PatchesPreviewApiService.PatchSvcRetryPolicyPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/patch/svc/retryPolicy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.retryPatchPolicyParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
