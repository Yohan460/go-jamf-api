/*
Jamf Pro API

## Overview The Jamf Pro API is a RESTful API for Jamf Pro built to enable consistent and efficient programmatic access to Jamf Pro.<br/><br/> The swagger schema can be found [here](/api/schema/). 

API version: production
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


type OnboardingAPI interface {

	/*
	V1OnboardingEligibleAppsGet Retrieves a list of applications that are eligible to be used in an onboarding configuration

	Retrieves a list of applications that are eligible to be used in an onboarding configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OnboardingAPIV1OnboardingEligibleAppsGetRequest
	*/
	V1OnboardingEligibleAppsGet(ctx context.Context) OnboardingAPIV1OnboardingEligibleAppsGetRequest

	// V1OnboardingEligibleAppsGetExecute executes the request
	//  @return OnboardingEligibleItemsSearchResult
	V1OnboardingEligibleAppsGetExecute(r OnboardingAPIV1OnboardingEligibleAppsGetRequest) (*OnboardingEligibleItemsSearchResult, *http.Response, error)

	/*
	V1OnboardingEligibleConfigurationProfilesGet Retrieves a list of configuration profiles that are eligible to be used in an onboarding configuration

	Retrieves a list of configuration profiles that are eligible to be used in an onboarding configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OnboardingAPIV1OnboardingEligibleConfigurationProfilesGetRequest
	*/
	V1OnboardingEligibleConfigurationProfilesGet(ctx context.Context) OnboardingAPIV1OnboardingEligibleConfigurationProfilesGetRequest

	// V1OnboardingEligibleConfigurationProfilesGetExecute executes the request
	//  @return OnboardingEligibleItemsSearchResult
	V1OnboardingEligibleConfigurationProfilesGetExecute(r OnboardingAPIV1OnboardingEligibleConfigurationProfilesGetRequest) (*OnboardingEligibleItemsSearchResult, *http.Response, error)

	/*
	V1OnboardingEligiblePoliciesGet Retrieves a list of policies that are eligible to be used in an onboarding configuration

	Retrieves a list of policies that are eligible to be used in an onboarding configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OnboardingAPIV1OnboardingEligiblePoliciesGetRequest
	*/
	V1OnboardingEligiblePoliciesGet(ctx context.Context) OnboardingAPIV1OnboardingEligiblePoliciesGetRequest

	// V1OnboardingEligiblePoliciesGetExecute executes the request
	//  @return OnboardingEligibleItemsSearchResult
	V1OnboardingEligiblePoliciesGetExecute(r OnboardingAPIV1OnboardingEligiblePoliciesGetRequest) (*OnboardingEligibleItemsSearchResult, *http.Response, error)

	/*
	V1OnboardingGet Get the current onboarding settings configuration.

	Get the current onboarding settings configuration.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OnboardingAPIV1OnboardingGetRequest
	*/
	V1OnboardingGet(ctx context.Context) OnboardingAPIV1OnboardingGetRequest

	// V1OnboardingGetExecute executes the request
	//  @return OnboardingConfiguration
	V1OnboardingGetExecute(r OnboardingAPIV1OnboardingGetRequest) (*OnboardingConfiguration, *http.Response, error)

	/*
	V1OnboardingHistoryExportPost Export history object collection in specified format for Onboarding 

	Export history object collection in specified format for Onboarding


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OnboardingAPIV1OnboardingHistoryExportPostRequest
	*/
	V1OnboardingHistoryExportPost(ctx context.Context) OnboardingAPIV1OnboardingHistoryExportPostRequest

	// V1OnboardingHistoryExportPostExecute executes the request
	//  @return interface{}
	V1OnboardingHistoryExportPostExecute(r OnboardingAPIV1OnboardingHistoryExportPostRequest) (interface{}, *http.Response, error)

	/*
	V1OnboardingHistoryGet Get Onboarding history object 

	Gets Onboarding history object


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OnboardingAPIV1OnboardingHistoryGetRequest
	*/
	V1OnboardingHistoryGet(ctx context.Context) OnboardingAPIV1OnboardingHistoryGetRequest

	// V1OnboardingHistoryGetExecute executes the request
	//  @return HistorySearchResults
	V1OnboardingHistoryGetExecute(r OnboardingAPIV1OnboardingHistoryGetRequest) (*HistorySearchResults, *http.Response, error)

	/*
	V1OnboardingHistoryPost Add Onboarding history object notes 

	Adds Onboarding history object notes


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OnboardingAPIV1OnboardingHistoryPostRequest
	*/
	V1OnboardingHistoryPost(ctx context.Context) OnboardingAPIV1OnboardingHistoryPostRequest

	// V1OnboardingHistoryPostExecute executes the request
	//  @return HrefResponse
	V1OnboardingHistoryPostExecute(r OnboardingAPIV1OnboardingHistoryPostRequest) (*HrefResponse, *http.Response, error)

	/*
	V1OnboardingPut Update the onboarding configuration.

	Update the onboarding configuration.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OnboardingAPIV1OnboardingPutRequest
	*/
	V1OnboardingPut(ctx context.Context) OnboardingAPIV1OnboardingPutRequest

	// V1OnboardingPutExecute executes the request
	//  @return OnboardingConfiguration
	V1OnboardingPutExecute(r OnboardingAPIV1OnboardingPutRequest) (*OnboardingConfiguration, *http.Response, error)
}

// OnboardingAPIService OnboardingAPI service
type OnboardingAPIService service

type OnboardingAPIV1OnboardingEligibleAppsGetRequest struct {
	ctx context.Context
	ApiService OnboardingAPI
	page *int64
	pageSize *int64
	sort *[]string
}

func (r OnboardingAPIV1OnboardingEligibleAppsGetRequest) Page(page int64) OnboardingAPIV1OnboardingEligibleAppsGetRequest {
	r.page = &page
	return r
}

func (r OnboardingAPIV1OnboardingEligibleAppsGetRequest) PageSize(pageSize int64) OnboardingAPIV1OnboardingEligibleAppsGetRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property:asc/desc. Default sort is id:asc. Multiple sort criteria are supported and must be separated with a comma. Example: sort&#x3D;date:desc,name:asc 
func (r OnboardingAPIV1OnboardingEligibleAppsGetRequest) Sort(sort []string) OnboardingAPIV1OnboardingEligibleAppsGetRequest {
	r.sort = &sort
	return r
}

func (r OnboardingAPIV1OnboardingEligibleAppsGetRequest) Execute() (*OnboardingEligibleItemsSearchResult, *http.Response, error) {
	return r.ApiService.V1OnboardingEligibleAppsGetExecute(r)
}

/*
V1OnboardingEligibleAppsGet Retrieves a list of applications that are eligible to be used in an onboarding configuration

Retrieves a list of applications that are eligible to be used in an onboarding configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OnboardingAPIV1OnboardingEligibleAppsGetRequest
*/
func (a *OnboardingAPIService) V1OnboardingEligibleAppsGet(ctx context.Context) OnboardingAPIV1OnboardingEligibleAppsGetRequest {
	return OnboardingAPIV1OnboardingEligibleAppsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OnboardingEligibleItemsSearchResult
func (a *OnboardingAPIService) V1OnboardingEligibleAppsGetExecute(r OnboardingAPIV1OnboardingEligibleAppsGetRequest) (*OnboardingEligibleItemsSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OnboardingEligibleItemsSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OnboardingAPIService.V1OnboardingEligibleAppsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/onboarding/eligible-apps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int64 = 0
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page-size", r.pageSize, "")
	} else {
		var defaultValue int64 = 100
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	} else {
		defaultValue := []string{"id:asc"}
		r.sort = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnboardingAPIV1OnboardingEligibleConfigurationProfilesGetRequest struct {
	ctx context.Context
	ApiService OnboardingAPI
	page *int64
	pageSize *int64
	sort *[]string
}

func (r OnboardingAPIV1OnboardingEligibleConfigurationProfilesGetRequest) Page(page int64) OnboardingAPIV1OnboardingEligibleConfigurationProfilesGetRequest {
	r.page = &page
	return r
}

func (r OnboardingAPIV1OnboardingEligibleConfigurationProfilesGetRequest) PageSize(pageSize int64) OnboardingAPIV1OnboardingEligibleConfigurationProfilesGetRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property:asc/desc. Default sort is id:asc. Multiple sort criteria are supported and must be separated with a comma. Example: sort&#x3D;date:desc,name:asc 
func (r OnboardingAPIV1OnboardingEligibleConfigurationProfilesGetRequest) Sort(sort []string) OnboardingAPIV1OnboardingEligibleConfigurationProfilesGetRequest {
	r.sort = &sort
	return r
}

func (r OnboardingAPIV1OnboardingEligibleConfigurationProfilesGetRequest) Execute() (*OnboardingEligibleItemsSearchResult, *http.Response, error) {
	return r.ApiService.V1OnboardingEligibleConfigurationProfilesGetExecute(r)
}

/*
V1OnboardingEligibleConfigurationProfilesGet Retrieves a list of configuration profiles that are eligible to be used in an onboarding configuration

Retrieves a list of configuration profiles that are eligible to be used in an onboarding configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OnboardingAPIV1OnboardingEligibleConfigurationProfilesGetRequest
*/
func (a *OnboardingAPIService) V1OnboardingEligibleConfigurationProfilesGet(ctx context.Context) OnboardingAPIV1OnboardingEligibleConfigurationProfilesGetRequest {
	return OnboardingAPIV1OnboardingEligibleConfigurationProfilesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OnboardingEligibleItemsSearchResult
func (a *OnboardingAPIService) V1OnboardingEligibleConfigurationProfilesGetExecute(r OnboardingAPIV1OnboardingEligibleConfigurationProfilesGetRequest) (*OnboardingEligibleItemsSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OnboardingEligibleItemsSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OnboardingAPIService.V1OnboardingEligibleConfigurationProfilesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/onboarding/eligible-configuration-profiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int64 = 0
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page-size", r.pageSize, "")
	} else {
		var defaultValue int64 = 100
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	} else {
		defaultValue := []string{"id:asc"}
		r.sort = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnboardingAPIV1OnboardingEligiblePoliciesGetRequest struct {
	ctx context.Context
	ApiService OnboardingAPI
	page *int64
	pageSize *int64
	sort *[]string
}

func (r OnboardingAPIV1OnboardingEligiblePoliciesGetRequest) Page(page int64) OnboardingAPIV1OnboardingEligiblePoliciesGetRequest {
	r.page = &page
	return r
}

func (r OnboardingAPIV1OnboardingEligiblePoliciesGetRequest) PageSize(pageSize int64) OnboardingAPIV1OnboardingEligiblePoliciesGetRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property:asc/desc. Default sort is id:asc. Multiple sort criteria are supported and must be separated with a comma. Example: sort&#x3D;date:desc,name:asc 
func (r OnboardingAPIV1OnboardingEligiblePoliciesGetRequest) Sort(sort []string) OnboardingAPIV1OnboardingEligiblePoliciesGetRequest {
	r.sort = &sort
	return r
}

func (r OnboardingAPIV1OnboardingEligiblePoliciesGetRequest) Execute() (*OnboardingEligibleItemsSearchResult, *http.Response, error) {
	return r.ApiService.V1OnboardingEligiblePoliciesGetExecute(r)
}

/*
V1OnboardingEligiblePoliciesGet Retrieves a list of policies that are eligible to be used in an onboarding configuration

Retrieves a list of policies that are eligible to be used in an onboarding configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OnboardingAPIV1OnboardingEligiblePoliciesGetRequest
*/
func (a *OnboardingAPIService) V1OnboardingEligiblePoliciesGet(ctx context.Context) OnboardingAPIV1OnboardingEligiblePoliciesGetRequest {
	return OnboardingAPIV1OnboardingEligiblePoliciesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OnboardingEligibleItemsSearchResult
func (a *OnboardingAPIService) V1OnboardingEligiblePoliciesGetExecute(r OnboardingAPIV1OnboardingEligiblePoliciesGetRequest) (*OnboardingEligibleItemsSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OnboardingEligibleItemsSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OnboardingAPIService.V1OnboardingEligiblePoliciesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/onboarding/eligible-policies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int64 = 0
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page-size", r.pageSize, "")
	} else {
		var defaultValue int64 = 100
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	} else {
		defaultValue := []string{"id:asc"}
		r.sort = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnboardingAPIV1OnboardingGetRequest struct {
	ctx context.Context
	ApiService OnboardingAPI
}

func (r OnboardingAPIV1OnboardingGetRequest) Execute() (*OnboardingConfiguration, *http.Response, error) {
	return r.ApiService.V1OnboardingGetExecute(r)
}

/*
V1OnboardingGet Get the current onboarding settings configuration.

Get the current onboarding settings configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OnboardingAPIV1OnboardingGetRequest
*/
func (a *OnboardingAPIService) V1OnboardingGet(ctx context.Context) OnboardingAPIV1OnboardingGetRequest {
	return OnboardingAPIV1OnboardingGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OnboardingConfiguration
func (a *OnboardingAPIService) V1OnboardingGetExecute(r OnboardingAPIV1OnboardingGetRequest) (*OnboardingConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OnboardingConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OnboardingAPIService.V1OnboardingGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/onboarding"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnboardingAPIV1OnboardingHistoryExportPostRequest struct {
	ctx context.Context
	ApiService OnboardingAPI
	exportFields *[]string
	exportLabels *[]string
	page *int64
	pageSize *int64
	sort *[]string
	filter *string
	exportParameters *ExportParameters
}

// Export fields parameter, used to change default order or ignore some of the response properties. Default is empty array, which means that all fields of the response entity will be serialized. Example: export-fields&#x3D;id,username
func (r OnboardingAPIV1OnboardingHistoryExportPostRequest) ExportFields(exportFields []string) OnboardingAPIV1OnboardingHistoryExportPostRequest {
	r.exportFields = &exportFields
	return r
}

// Export labels parameter, used to customize fieldnames/columns in the exported file. Default is empty array, which means that response properties names will be used. Number of the provided labels must match the number of export-fields Example: export-labels&#x3D;identifier,name with matching: export-fields&#x3D;id,username
func (r OnboardingAPIV1OnboardingHistoryExportPostRequest) ExportLabels(exportLabels []string) OnboardingAPIV1OnboardingHistoryExportPostRequest {
	r.exportLabels = &exportLabels
	return r
}

func (r OnboardingAPIV1OnboardingHistoryExportPostRequest) Page(page int64) OnboardingAPIV1OnboardingHistoryExportPostRequest {
	r.page = &page
	return r
}

func (r OnboardingAPIV1OnboardingHistoryExportPostRequest) PageSize(pageSize int64) OnboardingAPIV1OnboardingHistoryExportPostRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property:asc/desc. Default sort is date:desc. Multiple sort criteria are supported and must be separated with a comma. Example: sort&#x3D;date:desc,name:asc 
func (r OnboardingAPIV1OnboardingHistoryExportPostRequest) Sort(sort []string) OnboardingAPIV1OnboardingHistoryExportPostRequest {
	r.sort = &sort
	return r
}

// Query in the RSQL format, allowing to filter history notes collection. Default filter is empty query - returning all results for the requested page. Fields allowed in the query: username, date, note, details. This param can be combined with paging and sorting. Example: filter&#x3D;username!&#x3D;admin and date&lt;2019-12-15
func (r OnboardingAPIV1OnboardingHistoryExportPostRequest) Filter(filter string) OnboardingAPIV1OnboardingHistoryExportPostRequest {
	r.filter = &filter
	return r
}

// Optional. Override query parameters since they can make URI exceed 2,000 character limit.
func (r OnboardingAPIV1OnboardingHistoryExportPostRequest) ExportParameters(exportParameters ExportParameters) OnboardingAPIV1OnboardingHistoryExportPostRequest {
	r.exportParameters = &exportParameters
	return r
}

func (r OnboardingAPIV1OnboardingHistoryExportPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.V1OnboardingHistoryExportPostExecute(r)
}

/*
V1OnboardingHistoryExportPost Export history object collection in specified format for Onboarding 

Export history object collection in specified format for Onboarding


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OnboardingAPIV1OnboardingHistoryExportPostRequest
*/
func (a *OnboardingAPIService) V1OnboardingHistoryExportPost(ctx context.Context) OnboardingAPIV1OnboardingHistoryExportPostRequest {
	return OnboardingAPIV1OnboardingHistoryExportPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OnboardingAPIService) V1OnboardingHistoryExportPostExecute(r OnboardingAPIV1OnboardingHistoryExportPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OnboardingAPIService.V1OnboardingHistoryExportPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/onboarding/history/export"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.exportFields != nil {
		t := *r.exportFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "export-fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "export-fields", t, "multi")
		}
	} else {
		defaultValue := []string{}
		r.exportFields = &defaultValue
	}
	if r.exportLabels != nil {
		t := *r.exportLabels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "export-labels", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "export-labels", t, "multi")
		}
	} else {
		defaultValue := []string{}
		r.exportLabels = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int64 = 0
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page-size", r.pageSize, "")
	} else {
		var defaultValue int64 = 100
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	} else {
		defaultValue := []string{"date:desc"}
		r.sort = &defaultValue
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	} else {
		var defaultValue string = ""
		r.filter = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.exportParameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnboardingAPIV1OnboardingHistoryGetRequest struct {
	ctx context.Context
	ApiService OnboardingAPI
	page *int64
	pageSize *int64
	sort *[]string
	filter *string
}

func (r OnboardingAPIV1OnboardingHistoryGetRequest) Page(page int64) OnboardingAPIV1OnboardingHistoryGetRequest {
	r.page = &page
	return r
}

func (r OnboardingAPIV1OnboardingHistoryGetRequest) PageSize(pageSize int64) OnboardingAPIV1OnboardingHistoryGetRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property:asc/desc. Default sort is date:desc. Multiple sort criteria are supported and must be separated with a comma. Example: sort&#x3D;date:desc,name:asc 
func (r OnboardingAPIV1OnboardingHistoryGetRequest) Sort(sort []string) OnboardingAPIV1OnboardingHistoryGetRequest {
	r.sort = &sort
	return r
}

// Query in the RSQL format, allowing to filter history notes collection. Default filter is empty query - returning all results for the requested page. Fields allowed in the query: username, date, note, details. This param can be combined with paging and sorting. Example: filter&#x3D;username!&#x3D;admin and date&lt;2019-12-15
func (r OnboardingAPIV1OnboardingHistoryGetRequest) Filter(filter string) OnboardingAPIV1OnboardingHistoryGetRequest {
	r.filter = &filter
	return r
}

func (r OnboardingAPIV1OnboardingHistoryGetRequest) Execute() (*HistorySearchResults, *http.Response, error) {
	return r.ApiService.V1OnboardingHistoryGetExecute(r)
}

/*
V1OnboardingHistoryGet Get Onboarding history object 

Gets Onboarding history object


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OnboardingAPIV1OnboardingHistoryGetRequest
*/
func (a *OnboardingAPIService) V1OnboardingHistoryGet(ctx context.Context) OnboardingAPIV1OnboardingHistoryGetRequest {
	return OnboardingAPIV1OnboardingHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HistorySearchResults
func (a *OnboardingAPIService) V1OnboardingHistoryGetExecute(r OnboardingAPIV1OnboardingHistoryGetRequest) (*HistorySearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistorySearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OnboardingAPIService.V1OnboardingHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/onboarding/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int64 = 0
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page-size", r.pageSize, "")
	} else {
		var defaultValue int64 = 100
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	} else {
		defaultValue := []string{"date:desc"}
		r.sort = &defaultValue
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	} else {
		var defaultValue string = ""
		r.filter = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnboardingAPIV1OnboardingHistoryPostRequest struct {
	ctx context.Context
	ApiService OnboardingAPI
	objectHistoryNote *ObjectHistoryNote
}

// history notes to create
func (r OnboardingAPIV1OnboardingHistoryPostRequest) ObjectHistoryNote(objectHistoryNote ObjectHistoryNote) OnboardingAPIV1OnboardingHistoryPostRequest {
	r.objectHistoryNote = &objectHistoryNote
	return r
}

func (r OnboardingAPIV1OnboardingHistoryPostRequest) Execute() (*HrefResponse, *http.Response, error) {
	return r.ApiService.V1OnboardingHistoryPostExecute(r)
}

/*
V1OnboardingHistoryPost Add Onboarding history object notes 

Adds Onboarding history object notes


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OnboardingAPIV1OnboardingHistoryPostRequest
*/
func (a *OnboardingAPIService) V1OnboardingHistoryPost(ctx context.Context) OnboardingAPIV1OnboardingHistoryPostRequest {
	return OnboardingAPIV1OnboardingHistoryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HrefResponse
func (a *OnboardingAPIService) V1OnboardingHistoryPostExecute(r OnboardingAPIV1OnboardingHistoryPostRequest) (*HrefResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HrefResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OnboardingAPIService.V1OnboardingHistoryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/onboarding/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.objectHistoryNote == nil {
		return localVarReturnValue, nil, reportError("objectHistoryNote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.objectHistoryNote
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnboardingAPIV1OnboardingPutRequest struct {
	ctx context.Context
	ApiService OnboardingAPI
	onboardingConfiguration *OnboardingConfiguration
}

// Onboarding settings to save.
func (r OnboardingAPIV1OnboardingPutRequest) OnboardingConfiguration(onboardingConfiguration OnboardingConfiguration) OnboardingAPIV1OnboardingPutRequest {
	r.onboardingConfiguration = &onboardingConfiguration
	return r
}

func (r OnboardingAPIV1OnboardingPutRequest) Execute() (*OnboardingConfiguration, *http.Response, error) {
	return r.ApiService.V1OnboardingPutExecute(r)
}

/*
V1OnboardingPut Update the onboarding configuration.

Update the onboarding configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OnboardingAPIV1OnboardingPutRequest
*/
func (a *OnboardingAPIService) V1OnboardingPut(ctx context.Context) OnboardingAPIV1OnboardingPutRequest {
	return OnboardingAPIV1OnboardingPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OnboardingConfiguration
func (a *OnboardingAPIService) V1OnboardingPutExecute(r OnboardingAPIV1OnboardingPutRequest) (*OnboardingConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OnboardingConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OnboardingAPIService.V1OnboardingPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/onboarding"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.onboardingConfiguration == nil {
		return localVarReturnValue, nil, reportError("onboardingConfiguration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.onboardingConfiguration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
